<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kaushik Gopal's Website (中文)</title><link>https://kau.sh/</link><description>近期内容 - Kaushik Gopal 的个人网站</description><language>zh-CN</language><lastBuildDate>Tue, 13 Jan 2026 19:39:48 +0000</lastBuildDate><item><title>2026年1月AI模型选择</title><link>https://kau.sh/blog/ai-model-choices/</link><description>&lt;p&gt;我该用哪个AI模型？&lt;/p&gt;
&lt;p&gt;这是常被问及的问题，但模型迭代太快，总觉得给出的答案过一两个月就会过时。&lt;/p&gt;
&lt;p&gt;今年终于有了一套稳定的选择，这些模型总能给我不错的结果。我在此记录下来，既为广泛分享，也为追踪自己选择的变化轨迹。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GPT 5.2&lt;/strong&gt;（高度推荐）用于规划和写作，包括&lt;a href="https://kau.sh/blog/exec-plans/"&gt;制定计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Opus 4.5&lt;/strong&gt;用于编码、任务自动化和工具调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gemini&lt;/strong&gt;系列模型处理其他所有需求：&lt;ul&gt;
&lt;li&gt;Gemini 3（思考版）用于学习和理解概念（被低估了）&lt;/li&gt;
&lt;li&gt;Gemini 3（极速版）应对快速提问&lt;/li&gt;
&lt;li&gt;Nano Banana（显然）用于图像生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NVIDIA的&lt;strong&gt;Parakeet&lt;/strong&gt;用于语音转录&lt;/li&gt;
&lt;/ul&gt;</description><pubDate>Tue, 13 Jan 2026 19:39:48 +0000</pubDate></item><item><title>在AI编码会话中使用tmux分叉子代理</title><link>https://kau.sh/blog/agent-forking/</link><description>&lt;p&gt;随着智能体编码成为编程的主要范式，许多人试图构建流畅的子智能体工作流。这些方案大多合理，但都无法满足我真正想要的简洁性：只需启动一个拥有我精心构建的完整上下文的新智能体实例，就能在独立会话中交互式地探索分支思路。

有时是探索性的（理解子系统、追问细节），有时是并行工作（趁记忆清晰时编写测试、起草文档、尝试替代方案）。核心就是：新建标签页，恢复会话，选择不同路径。听起来简单，但加上几个额外需求后，就难以找到令人满意的解决方案。我一直使用轻量级shell脚本处理这个问题，效果很好。

我的核心需求包括：超薄粘合层——我刻意避免在现有智能体上构建复杂框架。日常使用Claude Code、Codex CLI和Gemini时，它们迭代速度极快，任何厚重封装（如UI界面）都会导致功能滞后。因此选择Bash脚本搭配tmux，这套组合几乎能在所有计算机上运行。

工具无关的分支能力——我希望能在不同工具间无缝切换会话并保持上下文连贯。例如用Codex开启规划会话，形成可行方案后，可携带完整上下文转入Claude Code进行编码，或从Gemini分支出子智能体，通过nanobanana MCP等工具构建前后流程图。

交互式而非单次请求——分支出子智能体后，我需要能持续交互的真实会话。很少能通过单次请求就获得理想结果，往往需要根据初始回应深入探索。现有方案多采用无头模式或自动合并结果，而实践中我只需通过tmux将所需内容从分支会话复制回主会话——这操作在tmux中轻而易举。&lt;a href="https://kau.sh/blog/ai-programming/#iii--agentic-coding"&gt;primary paradigm&lt;/a&gt; for coding, many
have tried to come up with a smooth subagent workflow.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Many of these solutions are reasonable, but none match the simplicity of what I
actually want:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spin up another agent instance with the exact same context I’ve painstakingly
built.&lt;/li&gt;
&lt;li&gt;Pursue a tangential thought &lt;em&gt;interactively&lt;/em&gt; in a separate session.&lt;/li&gt;
&lt;li&gt;Sometimes that’s exploratory (understand a subsystem, ask follow-ups).
Sometimes it’s parallel work (write tests while context is fresh, draft docs,
spike an alternative).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That’s it. Open a new tab, resume the session, take a different path.&lt;/p&gt;
&lt;p&gt;Sounds straightforward, but tack on a few more requirements and it becomes hard
to find a satisfying solution. I’ve been using a thin shell script for this and
it’s worked well.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;You can find the
&lt;a href="https://gist.github.com/kaushikgopal/3a67f71052cf10276315162012dcac1c"&gt;source&lt;/a&gt;
here.&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://kau.sh/agent-forking.webp"/&gt;
&lt;/figure&gt;
&lt;h1 id="my-requirements"&gt;
My requirements
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#my-requirements"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="super-thin-glue-layer"&gt;
Super thin glue layer
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#super-thin-glue-layer"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I’m deliberately &lt;strong&gt;not trying to build on top of existing agents&lt;/strong&gt;. I use claude
code, codex cli &amp;amp; gemini daily, and they change fast enough that anything with a
thick layer (like a UI) will lag behind on features.&lt;/p&gt;
&lt;p&gt;So: a Bash script and tmux. That’s it. Available on virtually any computer.&lt;/p&gt;
&lt;h2 id="tool-agnostic-forks"&gt;
Tool-agnostic forks
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#tool-agnostic-forks"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I want to start the main session in one tool and fork into another, keeping the
same context.&lt;/p&gt;
&lt;p&gt;So I might start a planning session with codex. After I have a decent plan, I
might want to fork into claude code (with all the context I’ve built) and start
a coding session. I might want to fork another subagent from gemini and, using
something like the nanobanana MCP, build a before/after flow diagram.&lt;/p&gt;
&lt;h2 id="interactive-not-one-shot"&gt;
Interactive, not one-shot
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#interactive-not-one-shot"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;When I fork a subagent, I want a real session I can keep interacting with. It’s
rare that I can one-shot a request and get exactly what I want. Based on the
initial response, I might want to go down the rabbit hole and explore more.&lt;/p&gt;
&lt;p&gt;Many existing solutions are headless or try to merge results back automatically.
In practice, I just copy-paste what I need from the fork back into the main
session — tmux makes this trivial.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我早期版本的脚本也有类似功能：能够手动从子代理“拉取”结果。但实际上我很少那样使用。我通常是从代理回复中复制粘贴相关行，再粘贴回主会话。在tmux中，只要用鼠标高亮选中文本，就会自动复制到剪贴板。移除这个功能让脚本更简洁、更健壮。

避免上下文膨胀

分叉的核心意义在于让主会话远离无关话题。我希望主会话专注于“主要”变更，而支线任务则在别处进行。

但我也希望控制传入分叉子代理的上下文。为此，脚本会从原始窗口（借助tmux）提取文本并检查长度。如果对话记录过长，我会先进行总结再输入子代理。

这样，脚本既能让主会话避开无关上下文，又能为子代理提供有用的背景信息。

无需角色设定

Claude等工具常围绕角色设定来构建子代理。我觉得这不太实用。

别误会，提示中的角色设定确实强大且能产生好结果。但我并不需要为此专门创建子代理容器。我发现自己更倾向于设计特定的代理技能，并将其植入提示中。这同样能带来理想效果。

给子代理打标签！

多代理并行工作时最棘手的部分，或许是跟踪每个代理的当前任务。

我目前的解决方案相当简单：每次生成代理时，我都会用便于记忆的内容给tmux窗口打标签。效果相当不错！

解决方案

欢迎查看此处的Bash脚本。

你也可以参考我的tmux.conf文件，不过里面没什么特别配置，子代理脚本应该能兼容大多数设置。

这个脚本在概念上相当简单：

在tmux中启动编码会话（就像你平时那样）。

将当前tmux窗格视为主代理或主会话。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="no-context-bloat"&gt;
No context bloat
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#no-context-bloat"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The whole point of forking is keeping tangents out of the main session. I want
the main session to stay focused on the “primary” change, while side quests
happen elsewhere.&lt;/p&gt;
&lt;p&gt;But I also want the context going into the forked subagent to be controlled. To
that end, the script pulls in the text from the original window (courtesy of
tmux) and checks the size. If the transcript is long, I summarize it before
feeding it into the subagent.&lt;/p&gt;
&lt;p&gt;In this way, the script keeps tangential context out of the main session while
still seeding useful context to the subagent.&lt;/p&gt;
&lt;h2 id="no-personas"&gt;
No personas
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#no-personas"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Claude and other tools frame subagents around personas. I don’t find them as
useful.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong, personas in prompts are powerful and can give good results.
But I don’t need a subagent container for that. I find myself crafting specific
agent skills and seeding those into the prompt. This gives me equally good
results.&lt;/p&gt;
&lt;h2 id="label-the-subagents"&gt;
Label the subagents!
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#label-the-subagents"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Perhaps the trickiest part of having multiple agents working in parallel is
keeping track of what each agent is doing.&lt;/p&gt;
&lt;p&gt;My current solution to this is rather trivial. Every time an agent is spawned, I
label the tmux window with something that will help me remember. It works rather
well!&lt;/p&gt;
&lt;h1 id="the-solution"&gt;
The solution
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#the-solution"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;video controls="controls" loop="loop" width="100%"&gt;
&lt;source src="https://kau.sh/agent-forking.webm" type="video/webm"/&gt;
&lt;span&gt;&lt;/span&gt;
&lt;/video&gt;
&lt;p&gt;Feel free to take a look at the Bash
&lt;a href="https://gist.github.com/kaushikgopal/3a67f71052cf10276315162012dcac1c"&gt;script here&lt;/a&gt;.
You can also see my
&lt;a href="https://gist.github.com/kaushikgopal/2327b09ae1a194704d62da48d135dd35"&gt;tmux.conf&lt;/a&gt; but
there’s nothing special in there, and the subagent script should work with most
configurations.&lt;/p&gt;
&lt;p&gt;The script is conceptually pretty simple:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Start a coding session in tmux (as you regularly do).&lt;/li&gt;
&lt;li&gt;Treat the current tmux pane as the main agent or session.&lt;/li&gt;
&lt;li&gt;当你想要生成子代理时，使用tmux捕获对话记录（可配置）。&lt;/li&gt;
&lt;li&gt;输入你想要执行的任务提示。&lt;/li&gt;
&lt;li&gt;在后台创建一个新的tmux窗口并运行选定的代理命令，然后粘贴有效载荷：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;context&amp;gt; ... &amp;lt;/context&amp;gt;&lt;/code&gt;（原始对话记录，或由其他代理生成的摘要）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;task&amp;gt; ... &amp;lt;/task&amp;gt;&lt;/code&gt;（你输入的提示）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="caveats"&gt;注意事项&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#caveats"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我一直在根据自己的设置（Ghostty终端 + fish shell + tmux）调整这个脚本。除了我的设置外，我没有对其他设置进行优化或测试，但应该很容易适应。&lt;/li&gt;
&lt;li&gt;很容易生成过多的分支。一旦你花在上下文切换上的时间超过实际构建的时间，边际价值就会迅速下降。&lt;/li&gt;
&lt;li&gt;摘要是可选的，但如果你使用它，就意味着你信任模型来压缩你的对话记录。如果准确性很重要，请将阈值设置得足够低，以确保原始上下文能够完整保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;以下是我发现的一些最引人注目的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://block.github.io/goose/docs/guides/subagents/"&gt;Goose&lt;/a&gt;有实现方式，但Goose本身是一个新的包装工具，基于我们实际使用的底层工具（claude code、codex cli、gemini-cli）。这意味着它的功能总是会滞后。&lt;/li&gt;
&lt;li&gt;Claude本身有&lt;a href="https://code.claude.com/docs/en/sub-agents"&gt;子代理&lt;/a&gt;但它对子代理的处理方式非常不同，更侧重于多角色方法。&lt;/li&gt;
&lt;li&gt;亚马逊有一个复杂的解决方案，叫做&lt;a href="https://github.com/awslabs/agents-for-amazon-bedrock-blueprints"&gt;CAO&lt;/a&gt;（CLI代理编排器），感觉最接近，但比必要的复杂得多，涉及MCP等。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.conductor.build/"&gt;Conductor&lt;/a&gt;是一个免费工具，看起来也很不错，但和Goose一样，它建立在代理之上，专注于独立的工作空间。&lt;/li&gt;
&lt;/ul&gt;
 &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;我对这个脚本进行了大量调整，它在我当前的Ghostty终端 + fish shell + tmux设置中运行良好。我没有尝试为其他shell优化它，也不打算这样做，所以请随意复制、分支和修改它，尽情发挥！&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Mon, 29 Dec 2025 08:00:00 +0000</pubDate></item><item><title>Wi-Fi共享是安卓系统的一大亮点功能</title><link>https://kau.sh/blog/wifi-sharing-android/</link><description>&lt;p&gt;Ubiquiti发布了一款全新旅行路由器。网络世界为之沸腾，我也同样兴奋。

但当我试图回忆上次真正需要旅行路由器的场景时，却发现——安卓设备多年来一直支持着"Wi-Fi共享"功能：手机连接现有Wi-Fi网络后，可将其重新分享为热点。

这听起来像普通热点功能？实则不然。iPhone虽能分享移动数据，却无法将Wi-Fi连接转为热点。而Wi-Fi共享的精妙之处在于：手机接收Wi-Fi信号后，能将其转化为独立的热点网络。

或许你会疑惑：多设备直接连Wi-Fi不行吗？且看四大实用场景：

1. 告别繁琐的认证门户
携带3-4台设备出行时，逐台登录验证令人疲惫。Chromecast等设备更是难以通过网页认证。通过热点共享，仅需一次认证即可惠及所有设备。

2. 破解"单设备限制"
飞机上需要同时使用笔记本和手机？某些付费Wi-Fi仅限单设备连接。与其支付双倍费用，不如通过Wi-Fi共享实现多设备接入。

3. 突破酒店会议限制
酒店和会议中心的Wi-Fi常设登录验证与设备数量限制，Wi-Fi共享可巧妙规避这些约束。

4. 重建设备互联网络
酒店Wi-Fi常启用客户端隔离，导致设备间无法相互发现。通过手机热点组网，Chromecast投屏、打印机共享等功能即刻恢复。

更妙的是，结合Tailscale还能构建安全私有网络。科技的魅力，往往藏在这些解决实际痛点的细节之中。&lt;a href="https://blog.ui.com/article/travel-in-style-unifi-style-unifi-travel-router"&gt;travel router&lt;/a&gt;.
Much of the internet is excited. So am I.&lt;/p&gt;
&lt;p&gt;Then I tried to remember the last time I actually &lt;em&gt;needed&lt;/em&gt; a travel router. You
see, Android has supported a feature I’ll call Wi-Fi sharing for
years.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; Your phone connects to an existing Wi-Fi network and
re-shares it as a hotspot.&lt;/p&gt;
&lt;p&gt;This might sound like a regular hotspot feature that most phones (including the
iPhone) come with. But it’s not. iPhones can share mobile data. They can’t
re-share a Wi-Fi connection as a hotspot.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;
Wi-Fi sharing
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;Your phone connects to Wi-Fi, and then re-shares that same Wi-Fi as a hotspot.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;This is different from typical hotspot functionality where the phone shares
its mobile data connection (vs Wi-Fi).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Neat trick, but why bother? Can’t you just connect each device to Wi-Fi?&lt;/p&gt;
&lt;h2 id="avoid-signing-every-device-into-a-captive-wi-fi-portal"&gt;
Avoid signing every device into a captive Wi-Fi portal
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#avoid-signing-every-device-into-a-captive-wi-fi-portal"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Captive portals are annoying when you’re carrying multiple devices. I typically
travel with 3-4 devices that want internet. Signing each one in, every time,
gets old fast.&lt;/p&gt;
&lt;p&gt;Some devices are worse: Chromecast and Fire TV sticks are particularly painful
to get past captive portals. If everything connects to your hotspot, you only
deal with the portal once.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id="work-around-one-device-at-a-time-wi-fi-plans"&gt;
Work around “one device at a time” Wi-Fi plans
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#work-around-one-device-at-a-time-wi-fi-plans"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;On a plane, I sometimes want both my laptop and phone online. Some paid Wi-Fi
plans only allow one device at a time. Unless you’re ok paying twice, Wi-Fi
sharing is simpler.&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Hotels and conference centers do the same: sign-in plus device limits. Wi-Fi
sharing works around it.&lt;/p&gt;
&lt;h2 id="fix-devices-cant-see-each-other-networking"&gt;
Fix “devices can’t see each other” networking
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#fix-devices-cant-see-each-other-networking"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This one is less obvious, but common in hotels and conference Wi-Fi: your
devices have internet, but they can’t see each other locally. Chromecast (or
printers) won’t show up as a cast target because it doesn’t appear on the
network.&lt;/p&gt;
&lt;p&gt;That’s usually client/AP isolation.&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt; Put your devices on your phone’s
hotspot, and local discovery usually works again.&lt;/p&gt;
&lt;h2 id="secure-networking-with-a-tailscale-setup"&gt;
Secure networking with a Tailscale setup
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#secure-networking-with-a-tailscale-setup"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;这算是进阶用法了。通过Tailscale设置并指定出口节点，你基本上就拥有了一个私有VPN。

在手机热点流量经过该VPN的情况下，你只需在安卓手机上完成设置，所有连接到该热点的设备都能通过同样的“安全”路径访问网络。

当我在漫游或连接“免费”Wi-Fi时需要登录银行账户时，这个功能让我更安心，因为我知道本地网络无法窥探或篡改我的流量内容。

如何开启Wi-Fi共享

将安卓手机连接到你想共享的Wi-Fi网络。如果该网络有强制门户，请按需登录。

进入设置→热点与网络共享→Wi-Fi热点（具体名称可能不同）并开启该功能。

通常，如果你的手机不支持Wi-Fi共享，该选项会自动禁用Wi-Fi功能。部分厂商会提供独立的切换开关来启用Wi-Fi共享。Pixel手机会自动开启此功能。

几乎所有安卓手机

我得暂时收起对iPhone的炫耀：少数安卓设备可能不支持此功能。

安卓系统虽然内置了Wi-Fi共享功能，但仍需硬件和驱动程序的支持。值得注意的例外包括Pixel 7a、Pixel 8a，以及（第一代）Pixel Fold。

技术细节

Wi-Fi共享需要支持同时作为客户端和接入点运行的Wi-Fi硬件（芯片组+驱动程序）。

芯片组可通过多种方式实现此功能。

安卓系统不强制要求特定模式，这取决于Wi-Fi芯片组。DBS/SBS使用多射频模块，因此手机可以真正同时维持上行连接和热点功能；MCC/SCC共享单个射频模块，热点要么保持相同信道，要么在不同信道间跳转。

如果手机无法良好支持STA+AP并发功能，厂商会直接禁用Wi-Fi共享选项。&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:5"&gt;5&lt;/a&gt;&lt;/sup&gt; On phones where hotspot traffic
routes through that VPN, you only have to set it up on your Android phone, and
every device that connects to your phone gets the same “safe” path out.&lt;/p&gt;
&lt;p&gt;If I have to log in to bank accounts when roaming or connecting to “free” Wi-Fi,
this helps me feel safer knowing the local network can’t see or tamper with the
contents of my traffic.&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:6"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h1 id="how-to-enable-wi-fi-sharing"&gt;
How to enable Wi-Fi sharing
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#how-to-enable-wi-fi-sharing"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Connect your Android phone to the Wi-Fi network you want to share. If it’s
behind a captive portal, sign in as needed.&lt;/li&gt;
&lt;li&gt;Go to Settings → Hotspot &amp;amp; tethering → Wi-Fi hotspot (wording varies) and
turn it on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Typically, if your phone does not support Wi-Fi sharing, it will disable Wi-Fi.
Some OEMs show a separate toggle to enable Wi-Fi sharing. On Pixel phones, it’s
automatic.&lt;/p&gt;
&lt;h1 id="almost-every-android-phone"&gt;
&lt;em&gt;Almost&lt;/em&gt; every Android phone
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#almost-every-android-phone"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;I should pause my gloating over iPhones for a second: a &lt;em&gt;few&lt;/em&gt; Android devices
may not support this feature.&lt;/p&gt;
&lt;p&gt;The Android OS has Wi-Fi sharing baked in, but it still requires hardware +
driver support. Notable exceptions include the Pixel 7a, the Pixel 8a, and yes
the (first generation) Pixel Fold.&lt;/p&gt;
&lt;h2 id="technical-details"&gt;
Technical Details
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#technical-details"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wi-Fi sharing requires Wi-Fi hardware (chipset + drivers) that can run as both a
client and an access point at the same time (STA + AP).&lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:7"&gt;7&lt;/a&gt;&lt;/sup&gt; Chipsets can
implement this in a few ways (DBS, SBS, MCC, SCC).&lt;sup id="fnref:8"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:8"&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Android doesn’t mandate one mode; it depends on the Wi-Fi chipset. DBS/SBS use
multiple radios, so the phone can keep the upstream connection and hotspot truly
simultaneous (for example, 5 GHz upstream and a 2.4 GHz hotspot). MCC/SCC share
a radio, so the hotspot either stays on the same channel (SCC) or the radio hops
channels (MCC).&lt;/p&gt;
&lt;p&gt;If a phone can’t do STA + AP concurrency well (or at all), OEMs disable Wi-Fi
sharing (which is why some phones and many older devices don’t support it).&lt;/p&gt;
&lt;p&gt;旅行路由器仍有其用武之地：以太网端口、更佳的无线模块，以及可常驻运行VPN的独立设备。但如果你使用安卓系统且手机支持Wi-Fi共享功能，便已掌握了核心技巧。

安卓系统在设置中并未直接使用这个名称，但"连接Wi-Fi后将其作为热点分享"是我能找到的最贴切描述。严格从网络技术角度来说，这并非二层桥接，而是典型的通过Wi-Fi上行链路进行网络共享（路由/NAT）。

其运作原理在于：强制门户认证页面仅能识别你的手机，其他所有设备都通过NAT隐藏在其后方。

感谢达美航空成为少数未设置此限制的美国国内航司——美联航说的就是你。

酒店和会议场所的Wi-Fi常会刻意阻断设备间通信（"客户端隔离"），以防止宾客相互发现、扫描或连接彼此设备。手机热点功能可创建独立的小型局域网，让您的设备重新实现互联。

我正在撰写相关文章：《使用Tailscale，您无需再为VPN付费》。

HTTPS虽能加密银行会话，但公共Wi-Fi仍不可信：恶意接入点可能篡改DNS并诱导您访问钓鱼网站。VPN（或Tailscale出口节点）通过将流量加密传输至可信端点，有效降低受攻击面。

现代设备支持AP（接入点）+STA（站点）双模式，可同时作为网络客户端和其他设备的热点，实现Wi-Fi扩展或网络共享。

以下定义源自安卓Wi-Fi供应商硬件抽象层：

DBS（双频并发）
SBS（单频并发）
MCC（多信道并发）
SCC（单信道并发）&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Android doesn’t call it this in Settings, but it’s the best term I have for
“connect to Wi-Fi, then share that Wi-Fi as a hotspot”. In strict networking
terms, this isn’t L2 bridging; it’s typically tethering (routing/NAT) with a
Wi-Fi upstream. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;This works because the captive portal only sees your phone; everything else
is NATed behind it. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Thank you Delta for being one of the few US domestic airlines that don’t
place this restriction. Looking at you United. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:3"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Hotel and conference Wi-Fi often blocks device-to-device traffic on purpose
(“client isolation”) so guests can’t discover, scan, or connect to each
other’s devices. Your phone’s hotspot creates a separate little LAN, so your
devices can talk to each other again. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:4"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;I have a post in the making about this: “With Tailscale you don’t need to
pay for a VPN”. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:5"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;HTTPS encrypts the bank session, but open Wi-Fi is still untrusted: a
malicious access point can tamper with DNS and try to steer you into
phishing. A VPN (or Tailscale exit node) reduces the surface area by
encrypting your traffic to a trusted endpoint. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:6"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;Modern devices support AP (Access Point) + STA (Station) Mode, letting them
act as both a client to one network and a hotspot for others, allowing Wi-Fi
extension or tethering. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:7"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:8"&gt;
&lt;p&gt;Definitions from Android’s Wi-Fi vendor HAL (&lt;code&gt;WifiNative.java&lt;/code&gt;):
&lt;a href="https://android.googlesource.com/platform/packages/modules/Wifi/+/refs/heads/main/service/java/com/android/server/wifi/WifiNative.java#3454"&gt;DBS&lt;/a&gt;
(Dual Band Simultaneous),
&lt;a href="https://android.googlesource.com/platform/packages/modules/Wifi/+/refs/heads/main/service/java/com/android/server/wifi/WifiNative.java#3445"&gt;SBS&lt;/a&gt;
(Single Band Simultaneous),
&lt;a href="https://android.googlesource.com/platform/packages/modules/Wifi/+/refs/heads/main/service/java/com/android/server/wifi/WifiNative.java#3427"&gt;MCC&lt;/a&gt;
(Multi Channel Concurrency),
&lt;a href="https://android.googlesource.com/platform/packages/modules/Wifi/+/refs/heads/main/service/java/com/android/server/wifi/WifiNative.java#3436"&gt;SCC&lt;/a&gt;
(Single Channel Concurrency). &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:8"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Fri, 26 Dec 2025 20:30:06 +0000</pubDate></item><item><title>人工智能是思维的摩托车。</title><link>https://kau.sh/blog/motorbike-for-the-mind/</link><description>&lt;p&gt;史蒂夫·乔布斯曾将计算机比作"思维的自行车"。他说："人类是工具的创造者……我们能打造出工具，将自身固有能力放大到惊人的程度。因此对我而言，计算机始终是思维的自行车，它能将我们带到远超自身固有能力的远方。"

如今这种理念再次显现出预见性，但载体已然改变。如果说个人电脑是自行车，那么人工智能就是思维的摩托车。

我慎重地选择这个比喻。骑好自行车需要锻炼肌肉，摩托车则不同——它能带你跨越遥远距离却无需体力消耗。但若长期依赖，曾经赖以生存的肌肉就会萎缩。跳过缓慢痛苦的过程直接生成文字或代码确实诱人，但正是在处理边界案例的挣扎中，我们才学会辨别何为"优秀"。这种能力在AI代笔的时代更需要磨砺。

速度也改变了失败的本质。时速10英里的跌倒只会造成淤伤：就像可以追溯学习的程序错误；而时速60英里的坠落则是致命的：那可能是潜藏在陌生代码中的错误，在你察觉之前就已造成全面破坏。若始终依赖氛围编码构建整个系统，却不理解每一行代码、每一个权衡取舍，终将面临崩溃。

摩托车的特性在于：人人都能转动油门。安全抵达者与事故者的区别，在于懂得何时刹车——在交付前停下脚步、审视思考、透彻理解。在这个众生皆可疾驰的时代，真正的技能不再是操控油门，而是掌控刹车。&lt;a href="https://youtu.be/NwccnuHz5fM?si=LZjHwYanUIhi9JWd"&gt;bicycle for the mind&lt;/a&gt;.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-quote" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;We humans are tool builders… We can fashion tools that amplify these
inherent abilities to spectacular magnitudes. So for me, a computer has always
been the bicycle of the mind. Something that takes us far beyond our inherent
abilities.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;That sentiment feels prescient again today but the vehicle has changed.&lt;/p&gt;
&lt;p&gt;If the personal computer was a bicycle, &lt;strong&gt;AI is a motorbike for the mind&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I choose this distinction carefully.&lt;/p&gt;
&lt;p&gt;To ride a bicycle well, you must build muscle. The motorbike is different. You
cover vast distances without any tax on your body. Ride it long enough, and the
muscles you once relied on atrophy. It’s seductive to ship words or code while
skipping the slow, painful work. But wrestling with edge cases is how you learn
what “good” looks like: a skill you’ll need to sharpen even more with AI doing
the typing.&lt;/p&gt;
&lt;p&gt;Speed also changes the nature of failure. A fall at 10 mph is a bruise: a bug
you can trace and learn from. A fall at 60 mph is fatal: a bug hidden in code
you never wrote, its damage everywhere before you notice. Keep vibe-coding your
entire system&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; without understanding every line, every trade-off;
you’ll eventually crash.&lt;/p&gt;
&lt;p&gt;Here’s the thing about motorbikes: everyone can twist the throttle. What
separates riders who arrive from those who crash is knowing when to brake – when
to stop, look, and understand before you ship. In an age where anyone can go
fast, the true skill is no longer the throttle. It’s the brake.&lt;/p&gt;
&lt;figure&gt;
&lt;div align="center"&gt;
&lt;img src="https://kau.sh/images/content/uploads/2025/motorbike-mind.webp"/&gt;
&lt;/div&gt;
&lt;/figure&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;as &lt;a href="https://kau.sh/blog/vibe-eng"&gt;opposed to engineering with AI&lt;/a&gt; &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Tue, 23 Dec 2025 06:01:28 +0000</pubDate></item><item><title>用Rust对抗AI编程能力退化</title><link>https://kau.sh/blog/learn-rust-ai-atrophy/</link><description>&lt;p&gt;我完全拥抱AI辅助编程已不是秘密。一个合理的担忧（也是我一直在深入思考的问题）是：帮助我编码的那部分大脑机能是否会因此萎缩。

为了对抗这种趋势，过去几个月我一直在业余时间学习Rust。我彻底爱上了这门语言。

为什么选择Rust？

# 系统级语言
Kotlin仍然是我的主力语言，我对它了如指掌。无论是手写还是AI生成的Kotlin代码，我都能快速理解并给出优化建议。但Kotlin毕竟是运行在JVM上的高级语言，其性能存在结构性限制——我的职业生涯大多在与垃圾回收语言打交道。

这次我想换个口味，尝试没有垃圾回收机制的系统级语言。

# 新范式
我还希望学习核心哲学不同的语言，迫使自己用新方式思考。我曾浅尝Go语言，但它与我已掌握的语言差异不够显著。与其花时间学习，不如直接让AI生成Go代码来得实用。

而Rust则不同：即使获得AI翻译的代码，盯着生成结果时我仍会发现自己缺失核心概念。这太棒了！首次遇到生命周期错误时，我完全缺乏对应的思维模型——这种困惑正是我渴求的。

在GC语言的世界里，内存管理往往无需深思。但Rust迫使你在每个环节都必须考虑数据的所有权与生命周期。有趣的是，AI让这种认知差距变得显而易见：它既暴露了我的知识盲区，又指引了值得深究的方向。

# Rust构建实例
以下软件或完全由Rust构建，或在其核心部分采用Rust：
• fd（我的文件查找工具）
• ripgrep（我的文件搜索工具）
• Fish shell&lt;a href="https://kau.sh/tags/ai/"&gt;embraced&lt;/a&gt; AI for my coding. A valid
concern (&lt;em&gt;and one I’ve been thinking about deeply&lt;/em&gt;) is the atrophying of the
part of my brain that helps me code.&lt;/p&gt;
&lt;p&gt;To push back on that, I’ve been learning &lt;a href="https://rust-lang.org/"&gt;Rust&lt;/a&gt; on the
side for the last few months. I am absolutely loving it.&lt;/p&gt;
&lt;h2 id="why-rust"&gt;
Why Rust?
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#why-rust"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="systems-level-language"&gt;
Systems level language
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#systems-level-language"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Kotlin remains my go-to language. It’s the language I know like the back of my
hand. If someone sends me a swath of Kotlin code, whether handwritten or AI
generated, I can quickly grok it and form a strong opinion on how to improve it.&lt;/p&gt;
&lt;p&gt;But Kotlin is a high-level language that runs on a JVM. There are structural
limits to the performance you can eke out of it, and for most of my career&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;
I’ve worked with garbage-collected languages.&lt;/p&gt;
&lt;p&gt;For a change, I wanted a systems-level language, one without the training wheels
of a garbage collector.&lt;/p&gt;
&lt;h3 id="new-paradigms"&gt;
New paradigms
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#new-paradigms"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;I also wanted a language with a different core philosophy, something that would
force me to think in new ways.&lt;/p&gt;
&lt;p&gt;I picked up Go casually but it didn’t feel like a big enough departure from the
languages I already knew.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-quote" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;It just felt more useful to ask AI to generate Go code than to learn it
myself.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;With Rust, I could get code translated, but then I’d stare at the generated code
and realize I was missing some core concepts and fundamentals. I loved that!&lt;/p&gt;
&lt;p&gt;The first time I hit a lifetime error, I had no mental model for it. That
confusion was exactly what I was looking for.&lt;/p&gt;
&lt;p&gt;Coming from a GC world, memory management is an afterthought — if it requires
any thought at all. Rust really pushes you to think through the ownership and
lifespan of your data, every step of the way.&lt;/p&gt;
&lt;p&gt;In a bizarre way, AI made this gap obvious. It showed me where I didn’t
understand things and pointed me toward something worth learning.&lt;/p&gt;
&lt;h3 id="built-with-rust"&gt;
Built with Rust
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#built-with-rust"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Here’s some software that’s either built entirely in Rust or uses it in
fundamental ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/sharkdp/fd"&gt;fd&lt;/a&gt; (my tool of choice for finding files)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/BurntSushi/ripgrep"&gt;ripgrep&lt;/a&gt; (my tool of choice for
searching files)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://fishshell.com/"&gt;Fish shell&lt;/a&gt;（我最近用Rust重写了常用的终端）  
Zed  
（我常用的文本/代码编辑器）  
Firefox  
（我常用的浏览器）  
Android？！没错：Rust现已驱动该操作系统的部分底层组件，包括近期推出的快速分享功能。  

我日常使用的许多重要工具都基于Rust构建。了解它们的开发语言总没有坏处。  

Kotlin开发者会感到熟悉  
#  
Rust与Kotlin在多方面颇为相似。两者都采用严格的静态类型系统并配备高级类型推断功能，同时支持空值安全并提供编译时保障。  

编译时的严格性及高层级结构让我能轻松掌握基础。从语法层面看，它令人倍感亲切。  

我的Rust学习路径  
#  
我从重写几个原本用Bash或Go编写的小型CLI工具起步。即便在这些微型程序中，借用检查器也迫使我厘清数据所有权与生命周期。这种思维训练时常颇具挑战，却恰好能有效防止技能生疏。  

此后我开始尝试编写稍大型的程序和小型服务。  

核心学习资源  
#  
我反复使用的主要资源有两个：  

被亲切称为“圣经”的《The Rust Programming Language》。配套还有便捷的YouTube系列讲解视频。  

谷歌推出的《Comprehensive Rust》课程（推测是为培训安卓团队而创建），甚至设有专门的安卓章节。这套课程对我效果极佳。  

将AI作为Rust导师  
#  
有时教材或课程提及某个概念时，我会希望深入探究。以往我通常需要花费时间搜索资料、查阅Stack Overflow、寻找参考文献、钻研代码片段，才能厘清细微差别。  

但AI彻底改变了这一过程。我早期使用AI的顿悟时刻，正是发现它能极大降低代码学习门槛。对于Rust这类新语言的学习同样如此。  

例如：这两者有何区别？  
`let mut x_coord: &amp;amp;i32`  
`let x_coord: &amp;amp;mut i32`&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zed.dev/"&gt;Zed&lt;/a&gt; (my text/code editor of choice)&lt;/li&gt;
&lt;li&gt;Firefox (&lt;a href="https://kau.sh/blog/how-to-firefox/"&gt;my browser&lt;/a&gt; of choice)&lt;/li&gt;
&lt;li&gt;Android?! That’s right: Rust now powers some of the
&lt;a href="https://security.googleblog.com/2025/11/rust-in-android-move-fast-fix-things.html"&gt;internals&lt;/a&gt;
of the OS, including the
&lt;a href="https://security.googleblog.com/2025/11/android-quick-share-support-for-airdrop-security.html"&gt;recent&lt;/a&gt;
Quick Share feature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many of the most important tools I use daily are built with Rust. Can’t hurt to
know the language they’re written in.&lt;/p&gt;
&lt;h3 id="kotlin-developers-will-feel-at-home"&gt;
Kotlin developers will feel at home
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#kotlin-developers-will-feel-at-home"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Rust is quite similar to Kotlin in many ways. Both use strict static typing with
advanced type inference. Both support null safety and provide compile-time
guarantees.&lt;/p&gt;
&lt;p&gt;The compile-time strictness and higher-level constructs made it fairly easy for
me to pick up the basics. Syntactically, it feels very familiar.&lt;/p&gt;
&lt;h2 id="how-im-learning-rust"&gt;
How I’m learning Rust
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#how-im-learning-rust"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I started by rewriting a couple of small CLI tools I used to keep in Bash or Go.
Even in these tiny programs, the borrow checker forced me to be clear about who
owns what and when data goes away. It can be quite the mental workout at times,
which is perfect for keeping that atrophy from setting in.&lt;/p&gt;
&lt;p&gt;After that, I started to graduate to slightly larger programs and small
services.&lt;/p&gt;
&lt;h3 id="main-resources"&gt;
Main Resources
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#main-resources"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;There are two main resources I keep coming back to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Fondly referred to as
“&lt;a href="https://doc.rust-lang.org/book/ch01-02-hello-world.html"&gt;The Book&lt;/a&gt;”.
There’s also a convenient
&lt;a href="https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8"&gt;YouTube series following the book&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Google’s &lt;a href="https://google.github.io/comprehensive-rust/"&gt;Comprehensive Rust&lt;/a&gt;
course, presumably created to ramp up their Android team. It even has a
dedicated
&lt;a href="https://google.github.io/comprehensive-rust/android.html"&gt;Android chapter&lt;/a&gt;.
This worked beautifully for me.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="using-ai-as-a-rust-tutor"&gt;
Using AI as a Rust tutor
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#using-ai-as-a-rust-tutor"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;There are times when the book or course mentions a concept and I want to go
deeper. Typically, I’d spend time googling, searching Stack Overflow, finding
references, diving into code snippets, and trying to clear up small nuances.&lt;/p&gt;
&lt;p&gt;But that’s changed dramatically with AI. One of my early aha moments with AI was
how easy it made ramping up on code. The same is true for learning a new
language like Rust.&lt;/p&gt;
&lt;p&gt;For example, what’s the difference&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt; between these two:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-rust"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;let&lt;/span&gt; &lt;span style="color: #66d9ef;"&gt;mut&lt;/span&gt; x_coord: &lt;span style="color: #66d9ef;"&gt;&amp;amp;&lt;/span&gt;&lt;span style="color: #66d9ef;"&gt;i32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #a6e22e;"&gt;let&lt;/span&gt; x_coord: &lt;span style="color: #66d9ef;"&gt;&amp;amp;&lt;/span&gt;&lt;span style="color: #a6e22e;"&gt;mut&lt;/span&gt; &lt;span style="color: #66d9ef;"&gt;i32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我喜欢的另一件事是询问AI：人们使用这些概念有哪些惯用方式？这是我学习时给Gemini的一个提示：

我正在学习Rust；特别关注可变性、共享引用和独占引用等概念。以下是我的笔记：

&amp;gt; [!tip] 以下是各个概念：
&amp;gt; 
&amp;gt; 1. 可变性与不可变性（通过`mut`关键字）
&amp;gt; 
&amp;gt; 2. 引用与借用（通过`&amp;amp;`和`*`实现）
&amp;gt; 
&amp;gt; - 当你看到`&amp;amp;`时，立即想到读取/“借用”
&amp;gt; 
&amp;gt; 3. 当结合使用`&amp;amp;mut`（独占引用）时，情况变得有趣

在Rust中，有哪些使用上述概念组合的用例？我想了解，如果我成为一名日常的Rust程序员，应该熟悉哪些惯用的常用模式？

以下是简要回复（完整回复非常有用）：

好问题！让我分解你在Rust中每天会遇到的最常见惯用模式：

**关键日常模式需牢记：**

1. **默认使用`&amp;amp;T`** - 除非需要修改，否则使用不可变引用  
2. **使用`&amp;amp;mut T`进行原地操作** - 排序、过滤、修改  
3. **仅在必要时克隆** - 优先借用而非克隆  
4. **方法接收者说明意图** - `&amp;amp;self`读取，`&amp;amp;mut self`修改，`self`消耗  
5. **迭代器无处不在** - 掌握`.iter()`、`.iter_mut()`和`.into_iter()`

Rust的美妙之处在于编译器会引导你——如果你尝试了错误的借用模式，它会建议正确的模式。几周后，这些模式就会成为你的第二本能！

很容易对AI在编程中的角色感到悲观——“我们都会忘记如何编程”的焦虑是真实存在的。但我希望这能提供一个更有希望的视角。如果你是一位担心技能退化的经验丰富的开发者，那就学习一门迫使你以不同方式思考的语言。AI可以帮助你更快地跨越这个鸿沟。把它当作导师，而不仅仅是代码生成器。

我在高中时学过一点C/C++，但远未达到熟练水平。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-markdown"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;i'm learning Rust; specifically focusing on the concepts of mutability, shared
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;and exclusive references etc. This is from my notes:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;&amp;gt; &lt;/span&gt;&lt;span style="font-style: italic;"&gt;[!tip] There are individual concepts:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="font-style: italic;"&gt;&lt;/span&gt;&lt;span style="color: #66d9ef;"&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;&lt;/span&gt;&lt;span style="font-style: italic;"&gt;&amp;gt; 1. Mutability and immutability (through `mut`) keyword
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="font-style: italic;"&gt;&lt;/span&gt;&lt;span style="color: #66d9ef;"&gt;&amp;gt; &lt;/span&gt;&lt;span style="font-style: italic;"&gt;2. There is References and borrowing (enabled through `&amp;amp;` and `*`)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="font-style: italic;"&gt;&lt;/span&gt;&lt;span style="color: #66d9ef;"&gt;&amp;gt; &lt;/span&gt;&lt;span style="font-style: italic;"&gt; - when you see `&amp;amp;` - immediately think reading/"borrowing"
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="font-style: italic;"&gt;&lt;/span&gt;&lt;span style="color: #66d9ef;"&gt;&amp;gt; &lt;/span&gt;&lt;span style="font-style: italic;"&gt;3. Things get interesting when you combine `&amp;amp;mut` which is exclusive
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="font-style: italic;"&gt;&lt;/span&gt;&lt;span style="color: #66d9ef;"&gt;&amp;gt; &lt;/span&gt;&lt;span style="font-style: italic;"&gt; references
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="font-style: italic;"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;what are some usecases in rust where we use some combination of the above. i
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;want to understand if i become a daily rust programmer, what are some idiomatic
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;commonly used patterns I should get familiar with?
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here’s an abbreviated response (the full response was &lt;strong&gt;incredibly&lt;/strong&gt; useful):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-markdown"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Great question! Let me break down the most common idiomatic patterns you'll
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;encounter daily in Rust with these concepts:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Key Daily Patterns to Remember:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;1.&lt;/span&gt; Default to &amp;amp;T - Use immutable references unless you need mutation
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;2.&lt;/span&gt; Use &amp;amp;mut T for in-place operations - Sorting, filtering, modifying
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;3.&lt;/span&gt; Clone only when necessary - Prefer borrowing over cloning
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;4.&lt;/span&gt; Method receivers tell a story - &amp;amp;self reads, &amp;amp;mut self modifies, self
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; consumes
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;5.&lt;/span&gt; Iterators are everywhere - Master .iter(), .iter_mut(), and .into_iter()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;The beauty of Rust is that the compiler guides you - if you try the wrong
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;borrowing pattern, it'll suggest the right one. After a few weeks, these
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;patterns become second nature!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It’s easy to be doom and gloom about AI in coding — the “we’ll all forget how to
program” anxiety is real. But I hope this offers a more hopeful perspective.&lt;/p&gt;
&lt;p&gt;If you’re an experienced developer worried about skill atrophy, learn a language
that forces you to think differently. AI can help you cross that gap faster. Use
it as a tutor, not just a code generator.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;I did a little C/C++ in high school, but nowhere close to proficiency. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;将可变变量视为“共享引用”，而将不可变变量视为“独占引用”。&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Fri, 05 Dec 2025 08:00:00 +0000</pubDate></item><item><title>AI辅助编程 → 氛围工程 ← 氛围编程</title><link>https://kau.sh/blog/vibe-eng/</link><description>&lt;figure&gt;
&lt;div align="center"&gt;
&lt;img alt="We should go from AI assisted coding to Vibe Engineering not Vibe Coding" src="https://kau.sh/images/content/uploads/2025/ai-coding.webp"/&gt;
&lt;/div&gt;
&lt;/figure&gt;
&lt;p&gt;我们仍在纠结AI在日常编程中该占多大比重。有三个概念总被混为一谈：

AI辅助编程  
氛围编码  
氛围工程  

它们并不相同。

|          | AI辅助编程 | 氛围编码 | 氛围工程 |
|----------|------------|----------|----------|
| 代码生成者 | 👨‍💻 (+ 🤖) | 🤖       | 🤖       |
| 设计负责人 | 👨‍💻       | ︎🤖      | 👨‍💻 ︎    |

区别在于两个维度：  
**谁生成大部分代码**  
与  
**谁掌控设计标准与质量**

### 1. AI辅助编程 #
这是我们的起点。  
程序员编写大部分代码，AI充当超级自动补全工具。  
你亲自输入大部分代码，AI负责补全、模板代码、部分逻辑和小规模重构。你的目光始终关注每一行代码，AI很少在你未明确放置或接受建议时自行操作。这仍是“你驾驶，AI坐副驾”的模式。  
GitHub Copilot是早期代表。这是我早期尝试Copilot和脚本的视频。如今，Cursor Tab已夺得桂冠：它提供快速、内联的帮助，同时不放弃对代码库的控制权。  
我尤其欣赏Cursor在预测下一个代码输入或编辑点时的精准度。当它运行良好时，它会融入背景，默默提升你的生产力。一旦出错，你会立刻对AI感到沮丧。

### 2. 氛围编码 #
这曾席卷全球。  
AI生成大部分甚至全部代码。  
程序员用英语反馈进行互动，对实际代码形态的把握不再那么紧密。  
你放弃了有意识的设计。实际上，你让模型做出架构决策：文件结构、抽象、命名等一切。随着代码库增长并需要持续维护，氛围编码会崩溃。你的代码变成“神秘肉块”：它能运行，但没人清楚其原理或原因。  
这就是为什么经验丰富的老手会敲响警钟，抱怨AI机器人侵入了他们的领域。  
但氛围编码在少数场景中确实表现出色：  
- 非程序员需要能运行的东西，且不关心内部实现  
- 快速概念验证和一次性脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AI-assisted coding&lt;/li&gt;
&lt;li&gt;Vibe coding&lt;/li&gt;
&lt;li&gt;Vibe engineering&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are not the same.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;AI Assisted&lt;/th&gt;
&lt;th&gt;Vibe coding&lt;/th&gt;
&lt;th&gt;Vibe engineering&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Generates the code&lt;/td&gt;
&lt;td&gt;👨‍💻 (+ 🤖)&lt;/td&gt;
&lt;td&gt;🤖&lt;/td&gt;
&lt;td&gt;🤖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Owns the design&lt;/td&gt;
&lt;td&gt;👨‍💻&lt;/td&gt;
&lt;td&gt;︎🤖&lt;/td&gt;
&lt;td&gt;👨‍💻 ︎&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;They differ along two dimensions: &lt;em&gt;who generates most of the code&lt;/em&gt; and &lt;em&gt;who owns
the design and quality bar&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="1-ai-assisted-coding"&gt;
1. AI-assisted coding
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#1-ai-assisted-coding"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This is where we started.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;ul&gt;
&lt;li&gt;You, the programmer, write most of the code.&lt;/li&gt;
&lt;li&gt;AI acts as super-powered autocomplete.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;You type most of the code yourself. AI handles completions, boilerplate, pieces
of the logic and maybe small refactors. Your eyes stay on every line, and the AI
rarely acts without you explicitly placing or accepting a suggestion. This is
still “you drive, AI rides shotgun”.&lt;/p&gt;
&lt;div class="aside text-ht-lighter italic"&gt;&lt;p&gt;GitHub Copilot was the early poster child. Here’s an
&lt;a href="https://www.youtube.com/watch?v=Tr2YBmecdw4"&gt;early video&lt;/a&gt; of me dabbling with
Copilot and scripts. Today, &lt;a href="https://cursor.com/docs/tab/overview"&gt;Cursor Tab&lt;/a&gt;
has taken the crown: fast, inline help without giving up control of the
codebase.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;I particularly like how accurate Cursor is at predicting the next point of code
entry or edit. When it works well, it disappears into the background and
silently increases your productivity. Get it wrong, and you’re immediately
frustrated with AI.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="2-vibe-coding"&gt;
2. Vibe coding
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#2-vibe-coding"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This took the world by storm.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;ul&gt;
&lt;li&gt;AI generates most if not all of the code.&lt;/li&gt;
&lt;li&gt;You, the programmer, react with feedback in English and are not as in tune
with what the actual code shapes up to be.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;You give up intentional design. In practice, you’re letting the model make the
architectural calls: file structure, abstractions, naming, everything. As your
codebase grows and needs ongoing maintenance, vibe coding breaks down. Your code
turns into mystery‑meat: it runs, but nobody understands clearly how or why.&lt;/p&gt;
&lt;p&gt;This is why experienced greybeards raise alarms and complain about AI bots on
their lawns.&lt;/p&gt;
&lt;p&gt;But Vibe coding does shine in a few scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Non‑programmers who need something working without caring about internals&lt;/li&gt;
&lt;li&gt;Fast proofs of concept and one‑off scripts&lt;/li&gt;
&lt;li&gt;探索一个陌生的平台或技术栈，你甚至不知道“优秀”的标准是什么&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="aside text-ht-lighter italic"&gt;&lt;p&gt;安德烈·卡帕西，这位&lt;a href="https://www.youtube.com/c/AndrejKarpathy"&gt;大语言模型的&lt;/a&gt;教父，&lt;a href="https://x.com/karpathy/status/1886192184808149383"&gt;创造了这个术语。有人带着喜爱说起它，也有人带着不屑。无论好坏，这个词已经深入人心。&lt;/a&gt;我曾凭感觉编写了一个&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;脚本来检查你的USB-C线缆是否合格&lt;a href="https://kau.sh/blog/usbi/"&gt;，并且可以证实其中的一些情况。它最初是一个bash shell脚本，为了一个更跨平台的版本，我请AI把它转换成Go语言。这花了几分钟；实际上我对Go了解甚少（但我足够了解，知道生成的代码质量并不高）。即使在那篇文章变得有些流行之后，我仍然没有逐行检查那个脚本。&lt;/a&gt;而这正是感觉编码的全部意义：你很快就能得到一个基本可用的东西。它达到了目的，即使这段代码不是你愿意长期自豪地拥有的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;3. 感觉工程&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="3-vibe-engineering"&gt;#&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#3-vibe-engineering"&gt;我认为这就是AI软件工程的未来方向。&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;AI生成大部分代码，但要在你明确的约束之内。&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;ul&gt;
&lt;li&gt;你负责设计架构、设定边界，并审查结构和行为。&lt;/li&gt;
&lt;li&gt;感觉编码和感觉工程都让AI生成大部分代码。区别在于谁拥有设计权：在感觉编码中，模型实际上拥有它；在感觉工程中，你仍然是架构师。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;西蒙·威利森，这位&lt;/p&gt;
&lt;p&gt;LLM命令行工具&lt;a href="https://simonwillison.net/2025/May/27/llm-tools/"&gt;的大师和熟练的  
鹈鹕爱好者，正试图推广&lt;/a&gt;感觉工程&lt;a href="https://simonwillison.net/2025/Oct/7/vibe-engineering/"&gt;这个术语。他用它来描述那些经验丰富的工程师，他们使用LLM和编码代理来加快速度，但仍对设计、质量和长期可维护性负责。我知道“感觉”这个词会让一些人感到恼火，但说实话我并不介意。&lt;/a&gt;1&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;与AI辅助编程的区别在于自主性。氛围工程让AI以更大模块运作：执行命令、编辑文件、重构模块；而你只需把握整体设计与行为逻辑，无需逐键操控。你仍在进行真正的工程实践：研究方法、制定架构决策、定义成功标准，并投入代码审查与质量保障。

它放大了资深工程师的经典习惯：测试、规划、文档编写、版本控制以及严格的代码审查。

我通过氛围工程开发了一个相当复杂的Firefox扩展（对此深感自豪，这是少数具备测试功能的Firefox扩展之一）。这段经历让我确信了这种方法的有效性。我并非在进行氛围编码：我决定了架构，撰写了规范，设定了约束条件，然后利用大语言模型与智能体探索实施方案、生成代码，并根据测试结果与审查进行迭代。

实践中，你为AI塑造工作场域：
- 撰写简明设计文档：模块划分、职责分配、关键接口
- 提供明确指令（技术选型、需规避的依赖项、安全约束）
- 要求智能体分步实施（单个功能/模块/重构），运用执行计划
- 审查代码差异的结构与行为：边界是否清晰、测试是否有效、日志是否合理？
- 若框架有误则及时修正；若框架正确则放手细节

正如我在编程范式探讨中所言，我们已完全进入智能体编码时代。这一转变要求氛围工程的纪律性。放任自流的智能体氛围编码只会助长混乱蔓延。

这种方法或可称为智能体驱动编码，但氛围工程似乎更具韵味？氛围编码；AI辅助编码；智能体驱动编码。嗯… ↩︎&lt;/p&gt;
&lt;p&gt;It amplifies classic senior‑engineer habits: tests, planning, documentation,
version control, and ruthless code review.&lt;/p&gt;
&lt;div class="aside text-ht-lighter italic"&gt;&lt;p&gt;I &lt;a href="https://kau.sh/blog/container-traffic-control/"&gt;vibe‑engineered&lt;/a&gt; a fairly complex Firefox
add‑on (very proud of this one; it’s one of the few Firefox extensions with
tests). That experience sold me on this approach. I wasn’t vibe coding: I
decided the architecture, wrote the spec, set constraints, and then used LLMs
and agents to explore implementations, generate code, and iterate based on test
results and reviews.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;In practice, you shape the playground for the AI:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write a quick design doc: modules, responsibilities, key interfaces&lt;/li&gt;
&lt;li&gt;Provide strong instructions (tech choices, dependencies to avoid, safety
constraints)&lt;/li&gt;
&lt;li&gt;Ask agents to implement one slice at a time (a feature, a module, a refactor),
using &lt;a href="https://kau.sh/blog/exec-plans/"&gt;exec-plans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Review diffs for structure and behavior: are the boundaries clean, tests
meaningful, logs sane?&lt;/li&gt;
&lt;li&gt;If the shape is wrong, steer; if the shape is right, let the details go&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;As I explored in &lt;a href="https://kau.sh/blog/ai-programming/"&gt;programming paradigms&lt;/a&gt;, we’re fully in
the agentic coding era. That shift demands vibe engineering discipline. Agentic
vibe-coding feels like a recipe for scaling chaos.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;An alternative name to this could be agent-driven coding but
vibe-engineering has a better ring to it? Vibe Coding; AI Assisted Coding;
Agent Driven Coding. hmm… &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Tue, 18 Nov 2025 00:00:00 +0000</pubDate></item><item><title>与朋友们一起订阅月度AI服务吧</title><link>https://kau.sh/blog/ai-monthly-subs/</link><description>&lt;p&gt;朋友们，选AI月付订阅吧&lt;/p&gt;
&lt;p&gt;虽然忘了在哪看过这个建议，但考虑到AI实验室模型迭代的速度，坚持用月付计划比锁定年付更明智——哪怕年费价格看起来更诱人。&lt;/p&gt;
&lt;p&gt;我最近在安卓上遇到&lt;a href="https://developer.android.com/training/dependency-injection"&gt;依赖注入问题&lt;/a&gt;懒得自己调试，就扔给两个模型处理。GPT Codex给出了最简洁正确的修复方案，Claude Sonnet 4.5虽然也找到解法，但代码不够地道且改动过于激进。&lt;/p&gt;
&lt;p&gt;放在一个月前，我写代码根本不会考虑Claude之外的模型。但现在Codex明显领先了。听说谷歌&lt;a href="https://x.com/sundarpichai/status/1989481514393121239"&gt;即将&lt;/a&gt;发布新版Gemini模型，而且据说会强得离谱。&lt;/p&gt;
&lt;p&gt;在这美妙的不稳定时代，月付才是王道。&lt;/p&gt;</description><pubDate>Sun, 16 Nov 2025 18:46:05 +0000</pubDate></item><item><title>火狐浏览器搭配uBlock Origin插件，依然胜过Brave、Edge或任何基于Chromium内核的浏览器方案。</title><link>https://kau.sh/blog/firefox-ubo-vs-brave-chromium/</link><description>&lt;p&gt;我经常看到有人声称Brave、Edge或其他基于Chromium的浏览器在隐私保护方面能达到与Firefox + uBlock Origin（uBO）同等的水平。

这完全不符合事实。

Brave等Chromium浏览器受限于谷歌的Manifest V3规范。虽然Brave通过修改Chromium代码并自行托管部分MV2扩展来应对，但这本质上是在与底层引擎逆向而行。

Firefox则不受MV3限制，因此Firefox上的uBlock Origin能提供比受MV3约束的Brave + uBO Lite等方案更强大、用户可控性更高的拦截功能。

Brave是优秀的产品，我曾长期使用。但这类比较往往忽略了结构性差异。正是这些关键细节，使得Firefox成为注重隐私用户更具未来保障的平台。

Manifest V3从根本上削弱了基于Chromium的浏览器

核心问题在于Manifest V3（MV3）。这是谷歌为Chromium（Chrome、Brave和Edge均基于此构建）设计的新扩展架构。

在Manifest V2架构下，uBO等拦截器通过使用阻塞式API（webRequest + blocking）在每个网络请求上运行自有代码，自主决定是否取消、重定向或修改请求。

MV3废弃了常规扩展的阻塞路径，取而代之的是声明式网络请求（DNR）API：扩展必须预先声明一组数量受限的静态规则，浏览器直接执行这些规则而无需为每个请求运行扩展代码。这虽然保留了基础拦截功能，但正如uBO开发者所记录的，这移除了uBO所依赖的整类过滤能力。

而谷歌正通过逐步淘汰MV2来强制推行这一变更。

确实令人遗憾。

Brave对Manifest V3的应对方案

为应对此问题，Brave实质上是在与其自身引擎逆向抗衡。主要通过两种方式：

原生代码修改：在浏览器核心层使用C++/Rust原生实现广告拦截功能（Shields），以绕过扩展限制。

手动托管扩展：Brave现在不得不手动托管并更新部分扩展。&lt;/p&gt;
&lt;p&gt;This is simply not true.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;Brave and other Chromium browsers are constrained by Google’s Manifest V3.
Brave works around this by patching Chromium and self-hosting some MV2
extensions, but it is still swimming upstream against the underlying engine.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Firefox does not have these MV3 constraints, so uBlock Origin on Firefox
retains more powerful, user-controllable blocking than MV3-constrained setups
like Brave + uBO Lite.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Brave is an excellent product and what I used for a long time. But the
comparison often ignores structural realities. There are important nuances that
make Firefox the more future-proof platform for privacy-conscious users.&lt;/p&gt;
&lt;h1 id="manifest-v3-permanently-nerfs-chromium-based-browsers"&gt;
Manifest V3 permanently nerfs Chromium-based browsers
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#manifest-v3-permanently-nerfs-chromium-based-browsers"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;The core issue is Manifest V3 (MV3). This is Google’s new extension architecture
for Chromium (what Chrome, Brave, and Edge are built on).&lt;/p&gt;
&lt;p&gt;Under Manifest V2, blockers like uBO used the blocking version of the
&lt;code&gt;webRequest&lt;/code&gt; API (&lt;code&gt;webRequest&lt;/code&gt; + &lt;code&gt;webRequestBlocking&lt;/code&gt;) to run their own code on
each network request and decide whether to cancel, redirect, or modify it.&lt;/p&gt;
&lt;p&gt;MV3
&lt;a href="https://developer.chrome.com/docs/extensions/develop/migrate/what-is-mv3"&gt;deprecates that blocking path&lt;/a&gt;
for normal extensions and replaces it with the &lt;code&gt;declarativeNetRequest&lt;/code&gt; (DNR)
API: extensions must declare a capped set of static rules in advance, and the
browser enforces those rules without running extension code per request. This
preserves basic blocking but, as uBO’s developer documents,
&lt;a href="https://github.com/uBlockOrigin/uBOL-home/wiki/Frequently-asked-questions-%28FAQ%29#filtering-capabilities-which-cant-be-ported-to-mv3"&gt;removes whole classes of filtering capabilities&lt;/a&gt;
uBO relies on.&lt;/p&gt;
&lt;p&gt;And Google is forcing this change by
&lt;a href="https://developer.chrome.com/docs/extensions/develop/migrate/mv2-deprecation-timeline"&gt;deprecating MV2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Yeah, shitty.&lt;/p&gt;
&lt;h1 id="braves-workaround-for-manifest-v3"&gt;
Brave’s workaround for Manifest V3
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#braves-workaround-for-manifest-v3"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;To get around the problem, Brave is effectively swimming upstream against its
own engine. It does this in two ways:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Native patching:&lt;/strong&gt; It implements ad-blocking (Shields) natively in
C++/Rust within the browser core to bypass extension limitations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Manual extension hosting:&lt;/strong&gt; Brave now has to
&lt;a href="https://brave.com/blog/brave-shields-manifest-v3/"&gt;manually host and update&lt;/a&gt;Brave在其自有服务器上托管特定的Manifest V2扩展（如uBO和AdGuard），以在谷歌将其从商店中清除后维持其生命力。  
他们还就此撰写了一篇精彩的文章。  
Brave做得很好，但它的运营犹如达摩克利斯之剑悬顶。团队必须手动修补一个充满敌意的基础引擎，以维持Firefox开箱即用的功能。  
uBlock Origin Lite ≠ uBlock Origin  
很多人也说，等等，我们现在有了“uBlock Origin Lite”，它功能相同且更轻量！  
并非如此。  
它之所以“轻量”是有原因的。你无法获得相同的拦截保护。uBO Lite是受谷歌API限制而不得不推出的精简版本。  
正如uBlock Origin常见问题中详述的，“Lite”版本在以下方面存在不足：  
无按需列表更新：uBO Lite将过滤列表编译进扩展包中。生成的声明式规则集仅在扩展本身更新时刷新，因此你无法从扩展内触发立即的过滤列表或恶意软件列表更新。  
无“严格拦截”：uBO Lite不支持uBlock Origin的严格拦截模式或其按站点的动态矩阵。在Firefox上使用完整版uBO时，我的设置定义并暴露了一个自定义的、按站点的规则集，确保Facebook永远无法看到我在其他网站上的活动。uBO Lite不允许我表达或维护这种自定义策略；我必须完全依赖扩展自带的拦截逻辑。  
无动态过滤：你失去了按站点拦截特定脚本或框架的高级矩阵。  
有限元素选择器：“指向并移除”项目需要特定的、权限控制的步骤，而非无缝操作。  
无自定义过滤器：你无法编写自己的自定义规则来拦截几乎任何内容，从烦人的小部件到整个域名。  
Firefox与uBlock Origin搭配提供最佳体验  
uBlock Origin被广泛认为是最有效的内容拦截器。其创建者gorhill已明确表示&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;They wrote a great &lt;a href="https://brave.com/blog/brave-shields-manifest-v3/"&gt;post&lt;/a&gt;
about this too.&lt;/p&gt;
&lt;p&gt;Brave is doing a great job, but it is operating with a sword of Damocles hanging
over it. The team must manually patch a hostile underlying engine to maintain
functionality that Firefox simply provides out of the box.&lt;/p&gt;
&lt;h1 id="ublock-origin-lite--ublock-origin"&gt;
uBlock Origin Lite != uBlock Origin
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#ublock-origin-lite--ublock-origin"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;A lot of people also say, wait, we now have “uBlock Origin Lite” that does the
same thing and is even more lightweight!&lt;/p&gt;
&lt;p&gt;Nope.&lt;/p&gt;
&lt;p&gt;It is “lite” for a reason. You are not getting the same blocking safeguards. uBO
Lite is a stripped-down version necessitated by Google’s API restrictions.&lt;/p&gt;
&lt;p&gt;As detailed in the
&lt;a href="https://github.com/uBlockOrigin/uBOL-home/wiki/Frequently-asked-questions-%28FAQ%29"&gt;uBlock Origin FAQ&lt;/a&gt;,
the “Lite” version lacks in the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No on-demand list updates:&lt;/strong&gt; uBO Lite compiles filter lists into the
extension package. The resulting declarative rulesets are refreshed only when
the extension itself updates, so you cannot trigger an immediate filter-list
or malware-list update from within the extension.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No “Strict Blocking”:&lt;/strong&gt; uBO Lite does not support uBlock Origin’s strict
blocking modes or its per-site dynamic matrix. With full uBO on Firefox, my
&lt;a href="https://kau.sh/blog/how-to-firefox/#block-outgoing-network-traffic-to-facebook"&gt;setup&lt;/a&gt;
defines and exposes a custom, per-site rule set that ensures Facebook never
sees my activity on other sites. uBO Lite does not let me express or maintain
that kind of custom policy; I have to rely entirely on whatever blocking logic
ships with the extension.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No dynamic filtering:&lt;/strong&gt; You lose the advanced matrix to block specific
scripts or frames per site.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Limited element picker:&lt;/strong&gt; “Pointing and zapping” items requires specific,
permission-gated steps rather than being seamless.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No custom filters:&lt;/strong&gt; You cannot write your own custom rules to block nearly
anything, from annoying widgets to entire domains.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="firefox-offers-the-best-experience-with-ublock-origin"&gt;
Firefox offers the best experience with uBlock Origin
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#firefox-offers-the-best-experience-with-ublock-origin"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;uBlock Origin is widely accepted as the most effective content blocker
available. Its creator, gorhill, has explicitly stated that
&lt;a href="https://github.com/gorhill/uBlock/wiki/uBlock-Origin-works-best-on-Firefox"&gt;uBlock Origin在Firefox上表现最佳。

因此，虽然使用Brave这类浏览器优于Chrome或其他缺乏全面拦截功能的浏览器，但它仍无法与Firefox搭配uBlock Origin相提并论。

Brave在Chromium基础上提供了强大且基本自动化的拦截功能，但这最终受限于谷歌的MV3政策。而Firefox搭配uBlock Origin则提供了功能全面、用户可控的拦截器，其运行引擎不受MV3约束——如果您关注长期、最大限度地控制网页加载内容及流量可见性，这一点至关重要。&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So while using a browser like Brave is better than using Chrome or other
browsers that lack a comprehensive blocker, it is not equivalent to Firefox +
uBlock Origin.&lt;/p&gt;
&lt;p&gt;Brave gives you strong, mostly automatic blocking on a Chromium base that is
ultimately constrained by Google’s MV3 decisions. Firefox + uBlock Origin gives
you a full-featured, user-controllable blocker on an engine that is not tied to
MV3, which matters if you care about long-term, maximum control over what loads
and who sees your traffic.&lt;/p&gt;</description><pubDate>Fri, 14 Nov 2025 04:38:50 +0000</pubDate></item><item><title>认知负担</title><link>https://kau.sh/blog/cognitive-burden/</link><description>&lt;p&gt;我常听到一种反对AI工具的说法："它做得没我快也没我好，那我用它干嘛？"

简单答案：认知负担。

AI带给我的最大启发是，我之所以能完成更多工作，并非因为速度更快，而是因为不必再为无谓的繁琐事务绞尽脑汁。即便耗时更长或需要更多修改，完成时也不那么筋疲力尽——正是这个顿悟时刻让我彻底信服。

**关于写作**  
简单示例：撰写技术文章时，我会先列出要点，偶尔加入自己喜欢的妙语或幽默元素。随后，一个根据我写作风格训练的自定义智能体会生成符合我语气的初稿。

生成初稿后，我仍会逐字审阅。质疑者可能会问："既然每个字都要审，那何不从头自己写？"

因为不必费力推敲、堆砌介词来搭建全文框架，整个过程会轻松愉快得多。我已把握核心要点并注入个人创意，剩余工作交给AI处理。以远低于以往的精力消耗，我能更快发布文章——这并非源于绝对速度，而是因为流程轻量化，让我能专注于赋予作品独特个性的部分。

认知负担↓。

**关于编程**  
大约两年前，我在员工会议上反驳CEO的观点："工程师浪费的时间大多不在写代码环节，而是在会议、设计讨论、与产品经理沟通、细化需求这些地方——这才是AI应该优先发力的领域。"

我当时也陷入了同样的思维盲区。确实，我享受精心雕琢每行代码的过程，这个环节本身并不令我困扰，但它确实会产生认知消耗。甚至可以说，在需要休息充电之前，我仍能比某些大语言模型更快构建出功能（综合考虑质量和迭代次数）。而现在，我通常能并行推进3-4个功能开发（附带必要的文档、测试及多个变体版本）。&lt;/p&gt;
&lt;p&gt;Simple answer: cognitive burden.&lt;/p&gt;
&lt;p&gt;My biggest unlock with AI was realizing I could get more done, not because I was
&lt;em&gt;faster&lt;/em&gt;, but because I wasn’t wringing my brain with needless tedium. Even if
it took longer or needed more iterations, I’d finish less exhausted. That was
the aha moment that sold me.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id="on-writing"&gt;
On Writing
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#on-writing"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Simple example: when writing a technical&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; post, I start with bullet
points. Sometimes there’s a turn of phrase or a bit of humor I enjoy, and I’ll
throw those in too. Then a custom agent trained on my writing generates a draft
in my voice.&lt;/p&gt;
&lt;p&gt;After it drafts, I still review every single word.&lt;/p&gt;
&lt;p&gt;A naysayer might ask: “Well, if you’re reviewing every single word anyway, at
that point, why not just write the post from scratch?”&lt;/p&gt;
&lt;p&gt;Because it’s &lt;em&gt;dramatically&lt;/em&gt; easier and more enjoyable not to grind through and
string together a bunch of prepositions to draft the whole post. I’ve captured
the main points and added my creative touch; the AI handles the rest. With far
less &lt;em&gt;effort&lt;/em&gt;, I can publish more quickly — not due to raw speed, but because
it’s low‑touch and I focus only on what makes it uniquely me.&lt;/p&gt;
&lt;p&gt;Cognitive burden ↓.&lt;/p&gt;
&lt;h1 id="on-coding"&gt;
On Coding
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#on-coding"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;About two years ago I pushed back on our CEO in a staff meeting: “Most of the
time we engineers waste isn’t in writing the code. It’s the meetings, design
discussions, working with PMs, fleshing out requirements — that’s where we
should focus our AI efforts first.”&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;I missed the same point. Yes, I enjoy crafting every line of code and I’m not
bogged down by that process per se, but there’s a cognitive tax to pay. I’d even
say I could still build a feature faster than some LLMs today (accounting for
quality and iterations) before needing to take a break and recharge. Now I
typically have 3–4 features in flight (with requisite docs, tests, and multiple
variants to boot).&lt;/p&gt;
&lt;p&gt;是的，我效率更高了。当然，我交付的速度可能也更快了。但这是相关性，而非因果关系。速度只是副产品。真正的驱动力是认知负担的减轻，这让我能承载更多。

作为一名产品工程师，更让我振奋的是，我现在把大量时间真正投入到打造优质产品上。

并非我不懂如何撰写每一条语句；只是……这不再让我感到有趣。

其他人感受不同。这很好！各有所爱。

对我来说，那是一个让我信服AI的顿悟时刻。减轻认知负担让我更高效；其他一切都随之而来。

我仍然从头开始撰写那些简短的个人帖子。我这样做主要是因为，写下每个字的过程有助于我的思维演进——这是多年来在此写作形成的一种肌肉记忆。

回想起来，这或许不是我最有说服力的论点，尤其考虑到我最近的热情。公平地说，虽然我承认我的反驳是错误的，但我认为当时的领导者们也未能完全整合出正确的推理。&lt;/p&gt;
&lt;p&gt;What’s invigorated me further as a product engineer is that I’m spending a lot
more time on actually &lt;strong&gt;building a good product&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It’s not that I don’t know how to write every &lt;code&gt;if&lt;/code&gt; statement; it’s just… no
longer interesting.
&lt;a href="https://world.hey.com/dhh/coding-should-be-a-vibe-50908f49"&gt;Others&lt;/a&gt; feel
differently. Great! To each their own.&lt;/p&gt;
&lt;p&gt;For me, that was the aha moment that sold me on AI. Reducing cognitive burden
made me more effective; everything else followed.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;I still craft the smaller personal posts from scratch. I do this mostly
because it helps evolve my thinking as I write each word down — a sort of
muscle memory formed over the years of writing here. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;In hindsight, maybe not one of my finest arguments especially given my
&lt;a href="https://kau.sh/tags/ai-coding-agent/"&gt;recent fervor&lt;/a&gt;. To be fair, while I concede my
pushback was wrong, I don’t think leaders then had the correct reasoning
fully synthesized. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Tue, 04 Nov 2025 22:24:00 +0000</pubDate></item><item><title>使用 ⌘ O ⌘ P 标准化操作，降低认知负荷</title><link>https://kau.sh/blog/cmd-o-cmd-p-cognitive-load/</link><description>&lt;p&gt;在macOS上，有几款文本处理类应用我最终投入了大量时间。比如：Obsidian（记笔记）、Zed（文本编辑器+轻量IDE）、Android Studio和Intellij（强化版IDE）、Cursor（IDE+AI）等等。

这些应用都有两类我常用的命令：打开特定文件或笔记，以及打开命令面板（或任意操作菜单）。但默认情况下，这些应用的快捷键设置总有细微差别——有的用⌘P，有的用⌘⇧P等等。

我发现花几分钟时间把这些特定快捷键统一起来会带来难以置信的便利。现在我的操作习惯是：⌘O打开文件/笔记，⌘P打开命令面板（或类似功能菜单）。

这个微小的调整显著降低了认知负担。我不再需要思考当前在用哪个应用，也不必记忆特定应用的快捷键。肌肉记忆会自动接管，让我能更高效地完成任务。强烈推荐这个做法！&lt;a href="https://obsidian.md/"&gt;Obsidian&lt;/a&gt; (for notes), &lt;a href="https://zed.dev/"&gt;Zed&lt;/a&gt; (text editor + IDE lite), Android Studio &amp;amp; Intellij (IDE++), Cursor (IDE + AI), etc.&lt;/p&gt;
&lt;p&gt;All these apps have two types of commands that I frequently use:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open a specific file or note&lt;/li&gt;
&lt;li&gt;Open the command palette (or find any action menu)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But by default, these apps use ever so slightly different shortcuts. One might use ⌘ P, another might use ⌘ ⇧ P, etc.&lt;/p&gt;
&lt;p&gt;I’ve found it incredibly helpful to take a few minutes and make these specific keyboard shortcuts the same everywhere. So now I use:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;⌘ O&lt;/strong&gt; – Open a file/note&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;⌘ P&lt;/strong&gt; – Open the command palette (or equivalent action menu)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This small change has reduced cognitive load significantly. I no longer have to think about which app I’m in, and what the shortcut is for that specific app. Muscle memory takes over, and I can just get things done faster. Highly recommended!&lt;/p&gt;</description><pubDate>Sat, 01 Nov 2025 00:38:50 +0000</pubDate></item><item><title>产品创新与模式创新</title><link>https://kau.sh/blog/product-vs-model-innovation/</link><description>&lt;p&gt;Cursor被誉为史上增长最快的SaaS公司。然而，由于他们不掌控底层模型，我始终觉得危机暗藏。他们本质上是AI工具而非AI产品，工具型公司极易被模型供应商颠覆——后者完全能在自家平台上打造竞品工具。

但Cursor持续证明了他们能交付最高质量的产品。他们开创的范式为AI融入开发者工作流程树立了标杆。当Claude Code等工具以更流畅的智能编辑功能出现时，我曾好奇Cursor将如何应对。

果然，Cursor 2.0通过引入智能IDE领域最优秀的UI范式，证明了他们能保持领先。Cursor的持续动力源于产品创新而非模型创新，他们本就不打算参与模型竞赛。

尽管许多人担忧危机将至，他们却持续引领着IDE融合AI的变革节奏。

后记：随着深入阅读他们关于内核技术及训练Composer（新型定制模型）的后续文章，我开始转变对Cursor的看法，甚至略微倾向于认为危机或许并未真正逼近。他们凭借卓越产品的先发优势，积累了编程IDE场景的独特数据，如今已能训练出高效的定制模型，足以与Sonnet 4.5和GPT Codex等顶尖模型一较高下。

是的，我注意到他们已拥有定制模型，"Cursor Tab"正是其在该领域的惊艳成果。但他们的"产品"仍重度依赖主流模型。举例来说，若Cursor不再支持Sonnet 4.5，对多数用户而言将失去使用价值。&lt;a href="https://sacra.com/research/cursor-at-100m-arr/"&gt;company in history&lt;/a&gt;. Yet, because they don’t control the underlying model, I’ve always felt the writing was on the wall. They are an AI tool, not an AI product, and tool companies risk disruption from model providers who can build competing tools on their own platforms.&lt;/p&gt;
&lt;p&gt;But Cursor has consistently shown they can deliver the highest quality product. The paradigms they introduce set the standard for how AI integrates into developer workflows. When Claude Code and other TUIs emerged with smoother agentic editing, I wondered how Cursor would respond.&lt;/p&gt;
&lt;p&gt;Sure enough, Cursor 2.0 proves they can stay ahead by introducing some of the best UI paradigms for an agentic IDE.&lt;/p&gt;
&lt;p&gt;What keeps Cursor going is &lt;strong&gt;product innovation&lt;/strong&gt;, not model innovation. They aren’t trying to win the model game.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; And while many worry the writing is on the wall, they continue to set the pace for how IDEs adopt AI.&lt;/p&gt;
&lt;h2 id="addendum"&gt;
Addendum
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#addendum"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The more I read their subsequent post on &lt;a href="https://cursor.com/blog/kernels"&gt;kernels&lt;/a&gt; and how they went about training Composer (their new custom model), I’m starting to change my thinking about Cursor and ever so slightly more bullish on the writing not being on the wall for them after all. Their first mover advantage (with a fantastic product) allowed them to collect data that’s unique to the coding IDE use case. This has now given them the ability to train a highly effective custom model that could potentially give the Sonnet 4.5s and GPT codexes of the world a run for their money.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Yes, I’m aware they have custom models and “Cursor Tab” is an example of them doing &lt;a href="https://cursor.com/blog/composer"&gt;amazing&lt;/a&gt; work in that area. But their “product” still relies heavily on the primary model. If Cursor didn’t support Sonnet 4.5, for example, it would be a non-starter for most users. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Wed, 29 Oct 2025 19:32:07 +0000</pubDate></item><item><title>智能体技能：与指令及其他工具有何不同？</title><link>https://kau.sh/blog/claude-skills/</link><description>&lt;p&gt;Anthropic宣布推出Claude Skills时，我的第一反应是：“那又怎样？”我们已经有斜杠命令、嵌套指令甚至MCP了。这有什么新意？

但如果Simon W认为这很重要，那就算天塌下来也得信——我肯定漏掉了什么。于是我逐字剖析了Anthropic工程博客的每句话，想找出自己遗漏的信息。

我认为创新之处不在于Skills能做什么或实现什么，而在于它的实现方式非常有趣。这延续了他们将上下文工程作为下一个前沿阵地的推进思路。

补充说明：Skills已推出一段时间，Anthropic甚至将其设为开放标准。请务必阅读文末的补充说明，那里分享了我写完初稿后的一些新认识。

Skills及其运作原理

Skills是带有YAML前置元数据的简单Markdown文件。但其独特之处在于渐进式披露的设计理念：

渐进式披露是使Agent Skills灵活可扩展的核心设计原则。就像编排精良的手册先提供目录，再展开具体章节，最后附上详细附录那样，Skills让Claude能够按需加载信息：

具体运作方式如下：

启动扫描：Claude扫描可用Skills，仅读取其YAML描述（名称、摘要、使用时机）
构建轻量索引：创建能力目录（消耗极少量token），每个技能仅需数十token
按需加载：只有当Claude推理判定某个Skill与当前任务相关时，其完整内容才会注入上下文

这种动态上下文加载机制具有极高的token效率——这才是真正有趣的发展。在这个token稀缺的AI经济时代，这简直是💰。其他解决方案在这方面都不够理想。

为何替代方案不够好

AGENTS.md（单体式）
✓ 自动发现并加载
✗ 静态：所有上下文预先加载（大规模时会膨胀上下文窗口）

为什么不把所有内容都塞进……&lt;a href="https://www.anthropic.com/news/skills"&gt;Claude Skills&lt;/a&gt; and
my first reaction was: “So what?” We already have &lt;code&gt;AGENTS.md&lt;/code&gt;, slash commands,
nested instructions, or even MCPs. What’s new here?&lt;/p&gt;
&lt;p&gt;But if
&lt;a href="https://simonwillison.net/2025/Oct/16/claude-skills/"&gt;Simon W thinks this is a big deal&lt;/a&gt;,
then pelicans be damned; I must be missing something. So I dissected every word
of Anthropic’s
&lt;a href="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills"&gt;eng. blog post&lt;/a&gt;
to find what I missed.&lt;/p&gt;
&lt;p&gt;I don’t think the innovation is &lt;em&gt;what&lt;/em&gt; Skills does or achieves, but rather &lt;em&gt;how&lt;/em&gt;
it does it that’s super interesting. This continues their push on
&lt;a href="https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents"&gt;context engineering&lt;/a&gt;
as the next frontier.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-info" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="12" cy="12" r="10"&gt;&lt;/circle&gt;&lt;path d="M12 16v-4"&gt;&lt;/path&gt;&lt;path d="M12 8h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;
Addendum
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;Skills has been out for sometime and Anthropic has even made it an
&lt;a href="https://claude.com/blog/organization-skills-and-directory"&gt;open standard&lt;/a&gt;.
Make sure to read the addedum at the end of this post, where I share some
newer realizations I’ve had since first writing it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id="skills-and-how-it-works"&gt;
Skills and how it works
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#skills-and-how-it-works"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Skills are simple markdown files with YAML frontmatter. But what makes them
different is the idea of &lt;strong&gt;progressive disclosure&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-quote" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;
Progressive disclosure is the core design principle that makes Agent
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;Skills flexible and scalable. Like a well-organized manual that starts with a
table of contents, then specific chapters, and finally a detailed appendix,
skills let Claude load information only as needed:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So here’s how it works:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Scan at startup&lt;/strong&gt;: Claude scans available Skills and reads only their YAML
descriptions (name, summary, when to use)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build lightweight index&lt;/strong&gt;: This creates a catalog of capabilities (with
minimal token cost); so think dozens of tokens per skill&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Load on demand&lt;/strong&gt;: The full content of a Skill only gets injected into
context when Claude’s reasoning determines it’s relevant to the current task&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This dynamic context loading mechanism is very &lt;strong&gt;token efficient&lt;/strong&gt;; that’s the
interesting development here. In this token-starved AI economy, that’s 🤑. Other
solutions aren’t as good in this specific way.&lt;/p&gt;
&lt;h1 id="why-the-alternatives-arent-as-good"&gt;
Why the alternatives aren’t as good
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#why-the-alternatives-arent-as-good"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="agentsmd-monolithic"&gt;
AGENTS.md (monolithic)
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#agentsmd-monolithic"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;✓ Auto-discovered and loaded&lt;/li&gt;
&lt;li&gt;✗ Static: all context loaded upfront (bloats context window at scale)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why not throw everything into &lt;code&gt;AGENTS.md&lt;/code&gt;你可以把所有信息直接加进去，代理会在会话开始时加载。问题在于：加载所有内容会迅速占满上下文窗口，除非采用其他策略，否则模型会开始输出无意义内容。这不可扩展。

嵌套式 AGENTS.md

#

✓ 限定在目录范围内

✗ 无法跨文件夹移植；是覆盖行为而非组合

在每个子文件夹中放置 AGENTS.md 文件，代理会读取树状结构中最接近的文件。这能将上下文分散到各个文件夹，解决令牌膨胀问题。但它无法跨目录移植，且创建的是覆盖行为而非真正的组合。

引用式指令文件

#

✓ 组织有序且模块化

✗ 被引用时仍需静态加载

将指令放在单独文件中，并在 AGENTS.md 中引用。这解决了嵌套方法在移植性上的问题。但当被引用时，完整内容仍需静态加载。最接近技能模式，但缺乏即时加载机制。

斜杠命令

#

✓ 功能强大且流程化

✗ 手动调用破坏代理自主性

斜杠命令（或 Codex 中的 `&lt;/p&gt;
&lt;h2 id="nested-agentsmd"&gt;`）让你能为大语言模型提供组织有序、高度具体的指令。你甚至可以编写动作序列脚本，就像技能一样。问题在于：这些命令无法自动发现。你必须手动调用，这破坏了代理的自主性。

MCP（模型上下文协议）

#

✓ 可访问外部数据源

✗ 过于笨重；存在供应商锁定；对流程化知识处理过度

技能以 10% 的复杂度解决了 80% 的 MCP 用例。如果你能放一个说明“要访问 GitHub API，请使用 `&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#nested-agentsmd"&gt;` 配合 `&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;`”的 Markdown 文件，就不需要网络协议。老实说，我从来不是 MCP 的忠实粉丝。我认为它们在服务间通信方面很有意义，但大多数情况下都显得过度设计。

最终结论

#

令牌高效的上下文加载是真正的创新。其他所有功能都可通过现有工具实现。

如果这个方案得到采用，它可能会取代斜杠命令并简化 MCP 的用例。&lt;/li&gt;
&lt;li&gt;✗ Not portable across folders; overrides behavior, not composition&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Place an AGENTS.md in each subfolder and agents read the nearest file in the
tree. This splits context across folders and solves token bloat. But it’s not
portable across directories and creates an override behavior instead of true
composition.&lt;/p&gt;
&lt;h2 id="referenced-instruction-files"&gt;
Referenced instruction files
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#referenced-instruction-files"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;✓ Organized and modular&lt;/li&gt;
&lt;li&gt;✗ Still requires static loading when referenced&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Place instructions in separate files and reference them in AGENTS.md. This fixes
the portability problem vs the nested approach. But when referenced, the full
content still loads statically. Feels closest to Skills, but lacks the JIT
loading mechanism.&lt;/p&gt;
&lt;h2 id="slash-commands"&gt;
Slash commands
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#slash-commands"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;✓ Powerful and procedural&lt;/li&gt;
&lt;li&gt;✗ Manual invocation breaks agent autonomy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slash commands (or &lt;code&gt;/prompts&lt;/code&gt; in Codex) let you provide organized,
hyper-specific instructions to the LLM. You can even script sequences of
actions, just like Skills. The problem: these aren’t auto-discovered. You must
manually invoke them, which breaks agent autonomy.&lt;/p&gt;
&lt;h2 id="mcps-model-context-protocol"&gt;
MCPs (Model Context Protocol)
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#mcps-model-context-protocol"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;✓ Access to external data sources&lt;/li&gt;
&lt;li&gt;✗ Heavyweight; vendor lock-in; overkill for procedural knowledge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Skills handle 80% of MCP use cases with 10% of the complexity. You don’t need a
network protocol if you can drop a markdown file that says “to access GitHub
API, use &lt;code&gt;curl api.github.com&lt;/code&gt; with &lt;code&gt;$GITHUB_API_KEY&lt;/code&gt;.” To be quite honest, I’ve
never been a big fan of MCPs. I think they make a lot of sense for the
inter-service communication but more often than not they’re overkill.&lt;/p&gt;
&lt;h1 id="the-verdict"&gt;
The Verdict
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#the-verdict"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;ul&gt;
&lt;li&gt;Token-efficient context loading is the innovation. Everything else you can
already do with existing tools.&lt;/li&gt;
&lt;li&gt;If this gets adoption, it could replace slash commands and simplify MCP use
cases.&lt;/li&gt;
&lt;li&gt;我总是忘记，这是针对整个Claude产品（不只是Claude Code），这很酷。

Skills功能正在着手解决一个更大的问题：“如何让我的智能体具备深度专业知识，又无需预先支付完整的上下文成本？”这确实是一个值得解决的架构改进，Skills看起来是个不错的尝试。

补充说明

2025年12月25日

Skills功能推出已有一段时间。以下是我近期的一些认识：

Skills已成为开放标准

Anthropic宣布他们已将Agent Skills设为开放标准。值得注意的是，各AI实验室和公司采纳Agent Skills的速度非常快。我认为这意味着智能体技能可能会逐渐取代其他等效机制和工具。例如，Codex已经拥有比斜杠命令更完善的技能版本（尽管斜杠命令是早于Skills的功能）。

Skills具有普适性

我第一次接触时忽略了这一点：你可以在开发环境之外使用自定义Skills。例如claude.ai支持上传zip文件作为自定义技能。这对非开发者来说非常强大。如果我编写一个Python脚本，能够根据三个上传文件和一些自定义文本生成定制PDF，将其打包成自定义技能并上传到claude.ai，那么我的父母无需编写任何代码就能利用这个功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Skills is starting to solve the larger problem: “How do I give my agent deep
expertise without paying the full context cost upfront?” That’s an architectural
improvement definitely worth solving and Skills looks like a good attempt.&lt;/p&gt;
&lt;h1 id="addendum"&gt;
Addendum
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#addendum"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Dec 25, 2025&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Skills has been out for sometime now. Here are some of the realizations I’ve
since had:&lt;/p&gt;
&lt;h3 id="skills-are-an-open-standard"&gt;
Skills are an open standard
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#skills-are-an-open-standard"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Anthropic &lt;a href="https://claude.com/blog/organization-skills-and-directory"&gt;announced&lt;/a&gt;
that they’ve made Agent Skills an &lt;a href="https://agentskills.io/home"&gt;open standard&lt;/a&gt;
now. It’s telling how quickly the various AI labs &amp;amp; companies have adopted Agent
Skills. I think the implication here is that agent skills will probably subsume
other equivalent mechanisms and tools. Codex for example has a more
&lt;a href="https://x.com/kaushikgopal/status/2004662229158035736?s=20"&gt;flushed out version&lt;/a&gt;
of skills than slash commands (even though slash commands was a feature that predates skills).&lt;/p&gt;
&lt;h3 id="skills-is-universal"&gt;
Skills is universal
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#skills-is-universal"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;I missed this the first time around, but you can use custom Skills outside of
developer environments. For example claude.ai supports
&lt;a href="https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview#claude-ai"&gt;uploading zip files as custom skills&lt;/a&gt;.
This can be pretty powerful for non-developers. If I build a python script that
generates a custom pdf from three uploads and some custom text, package it up as
a custom skill and upload to claude.ai, mom and dad can leverage this without
having to write a lick of code.&lt;/p&gt;</description><pubDate>Mon, 20 Oct 2025 11:45:11 +0000</pubDate></item><item><title>货物崇拜</title><link>https://kau.sh/blog/cargo-culting/</link><description>&lt;p&gt;如果你在软件工程领域待得够久，总会遇到一些资深前辈，他们常会抛出些意想不到的短语来传递行业智慧。比如，你总该知道自己是在"剃牦牛毛"还是"给自行车棚刷漆"，甚至该明白这些行为何时反而有益。

最近一篇Hacker News的文章让我想起另一个经典概念——货物崇拜编程。其定义为：在不理解原理的情况下将流程仪式化。在编程语境中，特指盲目套用设计模式或编码风格而不究其本质的行为。

借此机会，我想吐槽一个自己深恶痛绝的货物崇拜现象——"万物皆应微型化"。每当代码审查中出现"这个类太长了，必须拆分！"的反馈，我就忍不住要开启长篇大论：你们混淆了"物理短小"与"逻辑紧凑"的区别，这是在把代码行数当作仪式性指标，却忽略了内聚性本质。通过删除空格、将逻辑压缩成单行表达式、使用晦涩简写确实能让代码变短，但这只会降低可读性。一个完整实现单一功能的函数，远胜过散落在多个文件里的零碎小函数。

这个术语的典故来自二战后的寓言：土著部落相信只要他们修筑跑道、在跑道旁点燃篝火、戴着木刻耳机坐在仿造的控制塔里举行仪式，补给物资就会随飞机再度降临。表面看似荒诞，但深究其历史成因（价值霸权、语言与安全壁垒）却令人唏嘘。我认为这不应成为完全禁用该术语的理由。作为人类，我们有时必须直面历史的阴影，承认过错并在心中培育善意。过去无法改变，但我们可以塑造现在与未来。

下次当团队里有人在不理解的情况下机械套用模式时，你就知道该如何称呼这种现象了。话说回来，这些精妙的术语究竟是谁发明的呢？&lt;/p&gt;
&lt;p&gt;For example, you should know if you’re &lt;a href="https://kau.sh/blog/yak-shaving-bike-shedding/"&gt;yak-shaving or bike-shedding&lt;/a&gt;, and when that’s even a good thing.&lt;/p&gt;
&lt;p&gt;A recent &lt;a href="https://news.ycombinator.com/item?id=45618350"&gt;HN article&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; reminded me of another nugget – Cargo Culting (or Cargo Cult Programming).&lt;/p&gt;
&lt;h3 id="definition"&gt;
Definition
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#definition"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Cargo Culting&lt;/strong&gt;: ritualizing a process without understanding it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the context of programming:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;practice of applying a design pattern or coding style blindly without understanding the reasons behind it&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="example"&gt;
Example
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#example"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;I’m going to take this opportunity to air one of my personal cargo-culting pet peeves, sure to kick up another storm: &lt;strong&gt;Making everything small&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;When I get PR feedback saying “this class is too long, split this!”, I get ready to launch into a tirade: you’re confusing &lt;em&gt;small&lt;/em&gt; with &lt;em&gt;logically small&lt;/em&gt; – ritualizing line count without understanding cohesion. You can make code small by being terse: removing whitespace, cramming logic into one-liners, using clever shorthand.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt; But you’ve just made it harder to read. A function that does one cohesive thing beats multiple smaller functions scattered across files.&lt;/p&gt;
&lt;h3 id="etymology"&gt;
Etymology
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#etymology"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;As the &lt;a href="https://en.wikipedia.org/wiki/Cargo_cult_programming"&gt;parable&lt;/a&gt; goes, after the end of the Second World War, indigenous tribes believed that air delivery of cargo would resume if they carried out the proper rituals, such as building runways, lighting fires next to them, and wearing headphones carved from wood while sitting in fabricated control towers.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;While on the surface amusing, there’s sadness if you dig into the history and contributing factors (value dominance, language &amp;amp; security barriers). I don’t think that’s reason to avoid the term altogether. We as humans sometimes have to embrace our dark history, acknowledge our wrongs and build kindness in our hearts. We cannot change our past, but we can change our present and future.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The next time someone on your team ritualizes a pattern without understanding it, you’ll know what to call it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Jargon_File"&gt;Who&lt;/a&gt; comes up with these terms anyway?&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;既然你知道了这个词，你就会发现原文对“货物崇拜”一词的使用充其量是牵强的。在HN的风格下，评论很快指出了这一点。

↩︎

同为Kotlin程序员，你完全明白我在想什么。

↩︎&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;You know exactly what I’m thinking of, fellow Kotlin programmers. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Sat, 18 Oct 2025 16:37:23 +0000</pubDate></item><item><title>执行计划——如何让你的编码助手持续运行数小时</title><link>https://kau.sh/blog/exec-plans/</link><description>&lt;p&gt;我一直认为，AI编程助手中最关键的一环是规划步骤。在上一篇文章中，我描述了如何通过目录结构，要求助手在执行前后认真记录任务清单。如今大多数编程助手都已将此作为标准功能，比如Cursor近期就将其列为明确特性。

虽然这些进展令人欣慰，但我在返程航班上观看OpenAI开发者大会时，Aaron Friel在《用Codex交付项目》环节展示的"ExecPlans"方法论让我深受震撼。起初觉得似曾相识，但很快意识到这是规划领域的巅峰之作。

尽管OpenAI即将发布他的PLANS.md文档，但我已按捺不住。在航班颠簸的网络环境下，我根据演讲内容重构了自己的规划体系，将雏形方案升级为成熟框架——效果立竿见影。后来我在BlueSky联系Aaron获取完整文档，他慷慨分享了即将合并的PR详情。

这简直是件艺术品！Aaron显然投入了大量心血打磨。目前我在两个PR中实践这套方法，效果惊艳。虽然还需在大型项目中进一步验证，但我已敢断言这是规划领域的黄金标准。

我的实践方案微调如下：
- 要求助手将规划写入（适用于各类编程助手）
- 在AGENTS.md中设定临时方案存放路径（已加入gitignore）
- 将Aaron分享的权威版本保存在

朋友们，这确实是重大突破。立即行动吧！最新版PLANS.md可在Aaron的PR中获取，建议将其作为模板放入目录，并通过AGENTS.md要求助手处理复杂任务时务必制定ExecPlan。

强烈推荐观看Aaron在《用Codex交付项目》环节的演讲。待PR合并或有新进展时，我会同步更新本文。&lt;a href="https://kau.sh/blog/agentic-coding-flow-state/#step-1-plan-with-the-agent"&gt;previous post&lt;/a&gt;, I describe how I use a &lt;code&gt;.ai/plans&lt;/code&gt; directory and ask the agent to diligently write down its tasks before and during execution.&lt;/p&gt;
&lt;p&gt;Most coding agents now include this as a feature. Cursor, for example, introduced it as an &lt;a href="https://cursor.com/blog/plan-mode"&gt;explicit feature&lt;/a&gt; recently.&lt;/p&gt;
&lt;p&gt;While that all felt validating, on a plane ride home I watched OpenAI’s DevDay. One of the most valuable sessions was &lt;a href="https://youtu.be/Gr41tYOzE20?si=ZqfoPD7mnKeXtN4-&amp;amp;t=756"&gt;Shipping with Codex&lt;/a&gt;. Aaron Friel — credited with record-long sessions and token output — walked through his process and the idea of “ExecPlans.” It felt similar at first, but I quickly realized this was some god-level planning.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;He said OpenAI would release his PLANS.md soon, but I couldn’t wait. On that flight, with janky wifi, I rebuilt what I could from the talk and grew my baby plan into something more mature — and I was already seeing &lt;em&gt;better&lt;/em&gt; results. I pinged Aaron on BlueSky for the full doc, and he very kindly &lt;a href="https://bsky.app/profile/aaronfriel.bsky.social/post/3m2sqosxldc25"&gt;shared&lt;/a&gt; the &lt;a href="https://github.com/openai/openai-cookbook/pull/2185/"&gt;PR&lt;/a&gt; that’s about to get merged with detailed information.&lt;/p&gt;
&lt;p&gt;My god, this thing is a work of art. Aaron clearly spent a lot of time honing it. I’ve tried it on two PRs so far, and it’s working fantastically. I still need to put it through its paces on some larger work projects, but I feel comfortable preemptively calling it the gold standard for planning.&lt;/p&gt;
&lt;p&gt;I’ve made a few small tactical tweaks to how I use it:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I instruct the agent to write plans to &lt;code&gt;.ai/plans&lt;/code&gt; (works across coding agents)&lt;/li&gt;
&lt;li&gt;In my &lt;a href="https://kau.sh/blog/agents-md"&gt;AGENTS.md&lt;/a&gt; I tell agents to put temporary plans in &lt;code&gt;.ai/plans/tmp&lt;/code&gt; (which I’ve gitignored)&lt;/li&gt;
&lt;li&gt;I keep the master &lt;code&gt;PLANS.md&lt;/code&gt; Aaron shared at &lt;code&gt;@.ai/plans/PLANS.md&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is &lt;strong&gt;really&lt;/strong&gt; a big unlock, folks. Try it now.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;The latest PLANS.md can be found in &lt;a href="https://github.com/openai/openai-cookbook/pull/2185"&gt;Aaron’s PR&lt;/a&gt;. Use it as a template in your &lt;code&gt;.ai/plans&lt;/code&gt; folder. Then instruct your agent via AGENTS.md to always write an ExecPlan when working on complex tasks.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;I highly recommend you go watch Aaron’s part of the talk &lt;a href="https://youtu.be/Gr41tYOzE20?si=ZqfoPD7mnKeXtN4-&amp;amp;t=756"&gt;Shipping with Codex&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I’ll update this post once it’s merged or if anything changes.&lt;/p&gt;
&lt;p&gt;更新：过去几天我一直在使用这个（大约处理了8个PR），平均来看，我的代理程序确实能够成功运行更长时间（最长大约1小时，但经常超过30分钟）。这方法确实有效。&lt;/p&gt;</description><pubDate>Mon, 13 Oct 2025 01:01:48 +0000</pubDate></item><item><title>我们正成为软件指挥家。</title><link>https://kau.sh/blog/software-conductors/</link><description>&lt;p&gt;工程师不会被更擅长执行任务的工具取代；他们将被那些让任务变得不再必要的系统取代。Sangeet Paul Choudary撰写了一篇关于人工智能驱动岗位替代的深刻文章，并提出了一种更具变革性的思考方式：要真正理解人工智能如何影响工作，我们必须超越单个任务，去理解人工智能对我们工作流程和组织的影响。以任务为中心的视角将人工智能视为改进单个任务执行方式的工具。工作结构保持不变，人工智能只是叠加其上以提高速度或降低成本。……在这种框架下，主要风险在于更智能的工具可能会取代执行任务的人。另一方面，以系统为中心的视角关注人工智能如何重塑工作组织本身。它着眼于任务如何融入更广泛的工作流程，以及它们的价值如何由整体系统的逻辑决定。在这种视角下，即使任务仍然存在，一旦人工智能改变了系统结构，将它们归入特定岗位、甚至在公司内部执行的理由可能就不再成立。如果我们采用以系统为中心的视角，软件工程师的角色将如何演变？一段时间以来，我有个想法——这个角色将转变为软件“指挥家”。软件指挥家如同音乐指挥家，指挥是通过手势引导多名演奏者或歌手同时表演的艺术。软件指挥家必须掌握的任务与当今软件工程师不同。以下是我能想到的一些转变：任务编排精通&lt;/p&gt;
&lt;p&gt;Sangeet Paul Choudary wrote an &lt;a href="https://www.ai-supremacy.com/i/172078340/why-ai-experts-get-their-predictions-on-jobs-so-wrong"&gt;insightful piece&lt;/a&gt; on AI-driven job displacement and a more transformative way to think about it:&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-quote" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;To truly understand how AI affects jobs, we must look beyond individual tasks to comprehend AI’s impact on our workflows and organizations.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;The task-centric view sees AI as a tool that improves how individual tasks are performed. Work remains structurally unchanged. AI is simply layered on top to improve speed or lower costs.
…In this framing, the main risk is that a smarter tool might replace the person doing the task.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;The system-centric view, on the other hand, looks at how AI reshapes the organization of work itself. It focuses on how tasks fit into broader workflows and how their value is determined by the logic of the overall system. In this view, even if tasks persist, the rationale for grouping them into a particular job, or even performing them within the company, may no longer hold once AI changes the system’s structure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;If we adopt a system-centric view, how does the role of a software engineer evolve?&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; I’ve had a notion for some time — the role will transform into a software “conductor”.&lt;/p&gt;
&lt;h1 id="software-conductors"&gt;
Software conductors
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#software-conductors"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-info" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="12" cy="12" r="10"&gt;&lt;/circle&gt;&lt;path d="M12 16v-4"&gt;&lt;/path&gt;&lt;path d="M12 8h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;
music conductors
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;&lt;em&gt;conducting is the art of directing the simultaneous performance of several players or singers by the use of gesture&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The tasks a software conductor must master differ from those of today’s software engineer. Here are some of the shifts I can think of:&lt;/p&gt;
&lt;h2 id="task-orchestration-mastery"&gt;
Task Orchestration Mastery
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#task-orchestration-mastery"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;这门技艺在于精准把握提示的细节量：太少则模型茫然无措，太多则导致过拟合或虚构约束。你需要撰写规范级提示，明确定义接口、验收标准和边界——将任务拆分为足够原子化的执行单元，同时保持足够规模以维系上下文。同样关键的是：懂得何时介入与转向——在偏离初期敏锐捕捉，通过精准编辑而非昂贵的重试或循环来引导航向。

AI兼容的系统设计

你需要设计既能被AI流畅操作又可优雅扩展的系统。这意味着清晰的模块边界与明确接口、模型能推断用途的描述性命名、以及兼具可执行规范功能的测试。目标在于：让AI智能体能快速高效地进行精准修改，而不会引发连锁技术债务。

并行实验

我们正从构建单一方案转向同步探索多元路径。这开启了三个层次的实验空间：

功能变体
——并行构建不同产品方案。一个智能体实现仅手机验证，另一个构建传统邮箱密码验证。两者皆通过功能开关发布，让用户决定胜负。

实现变体
——以不同架构实现相同功能。A路径采用Redis缓存，B路径使用SQLite。通过离线基准测试与线上灰度发布，衡量实际负载下的性能优劣。

个性化变体&lt;/p&gt;
&lt;h2 id="ai-compatible-system-design"&gt;
AI-Compatible System Design
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#ai-compatible-system-design"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;You’ll need to design systems that AI can both navigate and extend elegantly. This means clear module boundaries with explicit interfaces, descriptive naming that models can infer purpose from, and tests that double as executable specs. The goal: systems where AI agents can make surgical changes quickly and efficiently without cascading tech debt.&lt;/p&gt;
&lt;h2 id="parallel-experimentation"&gt;
Parallel Experimentation
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#parallel-experimentation"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;We’re moving from building one solution to exploring many simultaneously. This unlocks three levels of experimentation:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Feature variants&lt;/strong&gt; — Build competing product approaches in parallel. One agent implements phone-only authentication while another builds traditional email/password. Both ship behind feature flags. Let users decide which wins.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implementation variants&lt;/strong&gt; — Build the same feature with different architectures. Redis caching on path A, SQLite on path B. Run offline benchmarks and online canaries to measure which performs better under real load.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Personalized variants&lt;/strong&gt;别再寻找唯一的赢家。最根本的转变在于：每位用户都可能获得专属版本。这不仅是企业版与个人版的区别，更是系统根据你的具体需求进行个性化适配——重度用户获得快捷键与密集信息流，轻度用户获得渐进式引导流程；易受社交证明影响的用户看到案例展示，理性分析型用户看到功能对比。人工智能让这种经济模式成为可能：原本需要手动维护成千上万条个性化代码路径的高昂成本，在AI自动生成、测试并同步多个变体时变得可行。

核心技能在于：运行严谨的评估体系，用指标衡量取舍，并统筹管理多个实时变体的复杂性。

实时成本效益权衡

每个API调用都涉及价格、延迟预算与质量取舍。你需要精通如何在昂贵推理模型与廉价模型之间进行权衡，掌握何时调用MCP协议、本地工具或云端API。理解模型处理代码重构、新功能开发与故障修复的不同逻辑，据此调整提示词、上下文窗口和路由策略。

将可观测性与评估体系视为专业学科

必须建立黄金测试集，追踪模型运行轨迹，对故障模式进行分类，并将评估体系视作单元测试。构建包含基线数据集、回归测试套件和自动化预警机制的评估框架已成为必备条件——这些能赶在生产环境前捕捉质量漂移。缺乏可观测性，就无法安全迭代，也无法验证改进是否真正有效。

通才思维优于专精技能

当人工智能接管语法细节时，框架熟练度便失去价值。真正重要的是三个领域的深度：

计算机科学核心基础&lt;/p&gt;
&lt;p&gt;The skill: running rigorous evals, measuring trade-offs with metrics, and orchestrating the complexity of multiple live variants.&lt;/p&gt;
&lt;h2 id="real-time-cost-performance-arbitrage"&gt;
Real-time Cost-Performance Arbitrage
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#real-time-cost-performance-arbitrage"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Every API call has a price, a latency budget, and quality trade-offs. You’ll need to master arbitrage between expensive reasoning models and cheaper models, knowing when to leverage MCPs, local tools, or cloud APIs. Learn how models approach refactors differently from new features or bug fixes, then tune prompts, context windows, and routing strategies accordingly.&lt;/p&gt;
&lt;h2 id="observability--evals-as-a-discipline"&gt;
Observability &amp;amp; Evals as a Discipline
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#observability--evals-as-a-discipline"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;You’ll need to build golden test sets, trace model runs, classify failure modes, and treat evals like unit tests. Evaluation frameworks with baseline datasets, regression suites, and automated canaries that catch quality drift before production become non-negotiable. Without observability, you can’t iterate safely or validate that changes actually improve outcomes.&lt;/p&gt;
&lt;h2 id="generalist-thinking-over-specialist-skills"&gt;
Generalist Thinking Over Specialist Skills
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#generalist-thinking-over-specialist-skills"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Framework fluency loses value when AI handles syntax. What matters is depth in three areas:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Core computer science fundamentals&lt;/strong&gt;——不是因为AI不知道它们，而是因为你需要确认AI针对你的具体限制条件做出了正确的权衡。当你的数据集始终只有10项时，AI可能选择快速排序算法；它可能优化一个每天仅运行一次的函数，却忽略了关键路径上的N+1查询问题——比如你循环处理1000个用户时逐条调用数据库而非批量操作。你的价值在于结合上下文进行代码审查：发现AI何时为错误目标优化，判断何时简单方案胜过巧妙设计，并在性能隐患发布前及时捕捉。

产品判断力

——懂得该解决什么问题，而不仅是解决方法。AI能构建你描述的任何功能，但无法判断这个功能是否重要。理解用户需求、果断确定优先级、识别过度开发何时成为瓶颈，这些才是关键。

领域专业知识

——对你所处领域（无论是支付、医疗、物流还是图形处理）的深刻认知。AI能编写通用代码，却难以应对特定领域的边缘情况、行业规范以及专家熟知的潜规则。你的专业领域越细分，就越难以被取代。

这些是未来三年至关重要的能力。但三年之后我无法预言。以AI目前的发展速度，甚至指挥家的角色也可能被AI更出色地替代。整个编排过程都可能自动化，届时我们将面对新一轮进化提出同样的疑问。

就当下而言，学会"指挥"是我们保持价值的方式。

企业的运作模式也将改变；但更迫近的转变在于个人角色的演化，因此本文聚焦于此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Product judgment&lt;/strong&gt; — Knowing which problem to solve, not just how to solve it. AI can build any feature you describe, but it can’t tell you whether that feature matters. Understanding user needs, prioritizing ruthlessly, and recognizing when you’re overbuilding becomes the bottleneck.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Domain expertise&lt;/strong&gt; — Deep knowledge of your problem space — whether it’s payments, healthcare, logistics, or graphics. AI can write generic code, but it struggles with domain-specific edge cases, regulations, and the unwritten rules experts know. The more niche your expertise, the harder you are to replace.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;These are the skills that matter for the next three years. But I don’t have a crystal ball beyond that. At the pace AI is evolving, even conductors might become a role that AI plays better. The orchestration itself could be automated, leaving us asking the same questions about the next evolution.&lt;/p&gt;
&lt;p&gt;For now, learning to conduct is how we stay relevant.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Companies will change how they ship too; but the nearer shift is the individual’s role, so that’s my focus for this post. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Sat, 11 Oct 2025 18:59:38 +0000</pubDate></item><item><title>排序提示——大型语言模型没有错，你只是捕捉到了它们思考的瞬间</title><link>https://kau.sh/blog/sorting-prompt/</link><description>&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-quote" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;良好的意义构建过程需要迭代。我们先形成初步理论，留意一些替代方案，然后将这些理论进行对比，逐一权衡证据。在此过程中，我们始终关注其他可能的解释以待验证。当新的解释不再出现，且证据模式明显倾向于某个观点时，我们便告一段落。

大型语言模型也是如此。那些常被视为"错误"的回应，往往只是对现有观点的初步描述。解决方法同样在于：迭代这一过程。

具体来说，我发现推动模型进行第二轮思考而不预设立场，几乎总能带来更好的结果。为此，我使用所谓的"分类陈述"来实现多种目的。

迈克·考尔菲尔德是一位注重信息真实性的人。整篇文章引人入胜，让我对大型语言模型的搜索结果有了全新的认识。

我现在有一个Raycast代码片段，

展开后是这样的：

"对于刚才提出的主张/指导，支持和反对的证据分别是什么？"

我已经看到了显著改善的效果。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;LLMs are no different. What often is deemed a “wrong” response is often4 merely a first pass at describing the beliefs out there. And the solution is the same: iterate the process.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;What I’ve found specifically is that pushing it to do a second pass without putting a thumb on the scale almost always leads to a better result. To do this I use what I call “sorting statements” that try to do a variety of things&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mike Caulfield is someone who cares about the veracity of information. The entire post is fascinating and has painted LLM search results in a new way for me.&lt;/p&gt;
&lt;p&gt;I now have a Raycast Snippet &lt;code&gt;aiprompt;&lt;/code&gt; which expands to this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-markdown"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;What is the evidence for and against the claim/guidance just stated?
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Already I’m seeing much better results.&lt;/p&gt;</description><pubDate>Fri, 10 Oct 2025 16:19:26 +0000</pubDate></item><item><title>构建你自己的 /init 命令，类似于 Claude Code</title><link>https://kau.sh/blog/build-ai-init-command/</link><description>&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-clipboard-list" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect height="4" rx="1" ry="1" width="8" x="8" y="2"&gt;&lt;/rect&gt;&lt;path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"&gt;&lt;/path&gt;&lt;path d="M12 11h4"&gt;&lt;/path&gt;&lt;path d="M12 16h4"&gt;&lt;/path&gt;&lt;path d="M8 11h.01"&gt;&lt;/path&gt;&lt;path d="M8 16h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;构建你自己的  
Claude指令  
可以轻松添加清晰的仓库说明。  
构建你自己的指令，与任何智能体配合使用，以补充或改进现有的AGENTS.md文件。  

以下是我设计的指令：  

Claude Code在智能体编程的入门体验上做得非常出色。打开它，输入指令，就能获得比没有合适系统说明的仓库（或AGENTS.md文件）更好的效果。  

这是一种快速启动仓库的巧妙方法。正如我上次提到的，它抓住了成功进行AI编程的三个关键杠杆之一——植入正确的上下文。即使是Codex CLI现在也内置了初始化提示。  

这并非什么秘密配方：指令本质上就是一个强大的提示，用于编写（或改进）说明文件。  

根据逆向工程该功能的人士提供的提示如下：  

请分析此代码库，并创建一个CLAUDE.md文件，该文件将提供给未来的Claude Code实例，以便在此仓库中操作。  

需要添加的内容：  
1. 常用命令，例如如何构建、代码检查和运行测试。包括在此代码库中进行开发所需的必要命令，例如如何运行单个测试。  
2. 高层代码架构和结构，以便未来的实例能够更快地投入工作。重点关注需要阅读多个文件才能理解的“大局”架构。  

使用说明：  
- 如果已存在CLAUDE.md文件，请提出改进建议。  
- 在创建初始CLAUDE.md文件时，请避免重复内容，不要包含显而易见的说明，例如“向用户提供有用的错误信息”、“为所有新工具编写单元测试”、“切勿在代码或提交中包含敏感信息（API密钥、令牌）”。  
- 避免列出可以轻松发现的每个组件或文件结构。  
- 不要包含通用的开发实践。  
- 如果存在Cursor规则（位于.cursor/rules/或.cursorrules中）或Copilot规则（位于.github/copilot-instructions.md中），请确保包含重要部分。  
- 如果存在README.md文件，请确保包含重要部分。&lt;code&gt;/init&lt;/code&gt; command
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;Claude’s &lt;code&gt;/init&lt;/code&gt; makes it easy to add clear repo instructions.
Build your own and use it with any agent to add or improve on an existing AGENTS.md
&lt;a href="https://gist.github.com/kaushikgopal/92e3a2fe89d602f6cdd94969c771989e"&gt;Here’s the one I came up with&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Claude Code really nailed the onboarding experience for agentic coding. Open it, type &lt;code&gt;/init&lt;/code&gt;, and you get a &lt;code&gt;CLAUDE.md&lt;/code&gt; that delivers better results than a repo without proper system instructions (or an &lt;code&gt;AGENTS.md&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;It’s a clever way to ramp a repo fast. As I wrote last time, it hits one of the &lt;a href="https://kau.sh/blog/three-req-ai-coding/"&gt;three levers for successful AI coding&lt;/a&gt; - seeding the right context. Even &lt;a href="https://openai.com/index/codex-now-generally-available/"&gt;Codex CLI&lt;/a&gt; now comes with a built-in init prompt.&lt;/p&gt;
&lt;p&gt;There’s no secret&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; sauce: &lt;code&gt;/init&lt;/code&gt; is just a strong prompt that writes (or improves) an instructions file.&lt;/p&gt;
&lt;p&gt;Here’s the prompt, &lt;a href="https://www.reddit.com/r/ClaudeAI/comments/1loa1c1/comment/n0lqqla/"&gt;per&lt;/a&gt; folks who’ve reverse‑engineered it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-markdown"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Please analyze this codebase and create a CLAUDE.md file, which will be given to future instances of Claude Code to operate in this repository.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;What to add:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;1.&lt;/span&gt; Commands that will be commonly used, such as how to build, lint, and run tests. Include the necessary commands to develop in this codebase, such as how to run a single test.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;2.&lt;/span&gt; High-level code architecture and structure so that future instances can be productive more quickly. Focus on the "big picture" architecture that requires reading multiple files to understand
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Usage notes:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; If there's already a CLAUDE.md, suggest improvements to it.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; When you make the initial CLAUDE.md, do not repeat yourself and do not include obvious instructions like "Provide helpful error messages to users", "Write unit tests for all new utilities", "Never include sensitive information (API keys, tokens) in code or commits"
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Avoid listing every component or file structure that can be easily discovered
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Don't include generic development practices
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; If there are Cursor rules (in .cursor/rules/ or .cursorrules) or Copilot rules (in .github/copilot-instructions.md), make sure to include the important parts.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; If there is a README.md, make sure to include the important parts.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt;你可以自己编写并达到相同效果。我在新仓库中使用自定义指令来快速启动项目。

我调整了它，使其能在不同的编码代理中工作，并加入了一些沿途收集的小技巧。

它应该创建一个相关的文件；如果文件已存在，则会更新它。将此提示保存为自定义命令，并搭配任何工具使用——Gemini CLI、Codex、Amp、Firebender 等。你不必局限于单一工具。

还有一个建议：对于这类命令，使用推理模型效果最佳。

我必须说：使用这些工具越久，我越常遇到“皇帝的新衣”时刻。

这些东西的某些运作方式简单得令人意外。

Claude 还会做一些其他事情，比如指示其内部代理工具（BatchTool 和 GlobTool）收集相关文件和现有指令（如 README.md、CONTRIBUTING.md、CODE_OF_CONDUCT.md、LICENSE 等）作为生成或更新文件的上下文。但提示本身才是核心。

↩︎

我在为 Firefox 扩展进行氛围工程以保持其可维护性时使用了这个提示。

↩︎&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Be sure to prefix the file with the following text:
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can write your own and get the same result. I use a &lt;a href="https://gist.github.com/kaushikgopal/92e3a2fe89d602f6cdd94969c771989e"&gt;custom &lt;code&gt;/initialize&lt;/code&gt;&lt;/a&gt; on new repos to get up and running fast.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt; I tweaked it to work across different coding agents and sprinkled in a few tips I collected along the way.&lt;/p&gt;
&lt;p&gt;It should create a relevant &lt;code&gt;AGENTS.md&lt;/code&gt;; if one exists, it updates it. Save this prompt as a custom command and use it with any tool — Gemini CLI, Codex, Amp, Firebender, etc. You aren’t stuck with any single tool.&lt;/p&gt;
&lt;p&gt;One more tip: a reasoning model works best for these types of commands.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;I must say: the more time I spend with these tools, the more “emperor‑has‑no‑clothes” moments I have.&lt;/em&gt; Some of the ways these things work are deceptively simple.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Claude does a few other things, like instructing its inner agent tools (BatchTool &amp;amp; GlobTool) to collect related files and existing instructions (&lt;code&gt;package*.json&lt;/code&gt;, &lt;code&gt;*.md&lt;/code&gt;, &lt;code&gt;.cursor/rules/**&lt;/code&gt;, &lt;code&gt;.github/copilot-instructions.md&lt;/code&gt;, etc.) as context for generating or updating &lt;code&gt;CLAUDE.md&lt;/code&gt;. But the prompt is the meat. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;I used this prompt when I &lt;a href="https://kau.sh/blog/container-traffic-control/"&gt;vibe‑engineered a maintainable Firefox add‑on&lt;/a&gt;. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Tue, 07 Oct 2025 15:58:06 +0000</pubDate></item><item><title>成功实现AI编程需把握三大关键要素</title><link>https://kau.sh/blog/three-req-ai-coding/</link><description>&lt;p&gt;我常听人说AI编程感觉不稳定或效果不佳。对此我很惊讶，因为大多数时候我都能得到不错的结果。

在使用任何AI助手（或任何大语言模型工具）时，真正决定你成果的只有三件事：你提供的上下文、你写的提示词，以及分块执行。

这听起来可能简单得令人沮丧，但每次向Claude Code、ChatGPT等发送请求时，有意识地把握这三点，效果会有显著不同。而且，做到80%的正确率其实很直接。

**上下文**

大语言模型是口袋里的世界知识机器。每次处理任务时，你都需要把这台机器修剪成一台只专注于手头任务的手术刀。方法就是植入上下文。

最简单的方法（尤其对于AI编程）：
1.  **系统规则与助手指令**：这基本上就是你的 `README.md` 文件，简要说明项目是什么、架构、仓库中使用的约定以及项目导航。
2.  **工具链**：很多人会忽略这点，但在你的 `AGENTS.md` 中，明确指明你自己用来构建、测试和验证的命令。我非常推崇维护一个包含最重要命令的 `Makefile`，这样助手就能轻松从命令行调用它们。
3.  **实时数据（MCP）**：当你需要实时数据或连接外部工具时，使用MCP。人们喜欢谈论复杂的MCP设置，但不要过度依赖。例如，与其使用GitHub MCP，不如安装 `gh` CLI命令，让助手直接运行这些命令。如果不小心使用MCP，可能会浪费token。当然，对于像Figma/JIRA这样没有其他明显连接路径的工具，可以放心使用。

还有很多其他方法，而设计更好的上下文传递方式正迅速成为AI发展的下一个前沿领域。

**提示词**

把提示词当作规格说明书，而不是搜索查询。例如：“给我写一个这个认证类的单元测试” 🙅‍♂️。

我不会用这样一句话，而是这样开始同一个提示词：

**角色**：&lt;/p&gt;
&lt;p&gt;When working with any AI agent (&lt;em&gt;or any LLM tool&lt;/em&gt;), there are really just three things that drive your results:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the context you provide&lt;/li&gt;
&lt;li&gt;the prompt you write&lt;/li&gt;
&lt;li&gt;executing in chunks&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This may sound discouragingly obvious, but being deliberate about these three (every time you send a request to Claude Code, ChatGPT etc.) makes a noticeable difference.&lt;/p&gt;
&lt;p&gt;…and it’s straightforward to get 80% of this right.&lt;/p&gt;
&lt;h1 id="context"&gt;
Context
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#context"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;LLMs are pocket‑sized world knowledge machines. Every time you work on a task, you need to trim that machine to a surgical one that’s only focused on the task at hand. You do this by seeding context.&lt;/p&gt;
&lt;p&gt;The simplest way to do this, especially for AI Coding:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;System rules &amp;amp; agent instructions&lt;/strong&gt;: This is basically your &lt;strong&gt;&lt;code&gt;AGENTS.md&lt;/code&gt;&lt;/strong&gt; file where you briefly explain what the project is, the architecture, conventions used in the repository, and navigation the project.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tooling&lt;/strong&gt;: Lot of folks miss this, but in your AGENTS.md, explicitly point to the commands you use yourself to build, test and verify. I’m a big fan of maintaining a single &lt;strong&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/strong&gt; with the most important commands, that the assistant can invoke easily from the command line.&lt;/li&gt;
&lt;li&gt;Real‑time data (&lt;strong&gt;MCP&lt;/strong&gt;): when you need real-time data or connect to external tools, use MCPs. People love to go on about complex MCP setup but don’t over index on this. For e.g. instead of a github MCP just install the &lt;code&gt;gh&lt;/code&gt; cli command let the agent run these directly. You can burn tokens if you’re not careful with MCPs. But of course, for things like Figma/JIRA where there’s no other obvious connection path, use it liberally.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are many other ways, and engineering better context delivery is fast becoming the next frontier in AI development.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h1 id="prompt"&gt;
Prompt
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#prompt"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Think of prompts as specs, not search queries. For example: ‘Write me a unit test for this authentication class’ 🙅‍♂️.&lt;/p&gt;
&lt;p&gt;Instead of that one‑liner, here’s how I would start that same prompt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-md"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Persona:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt;计划：

1. **分析现有模式**：首先查看 `RuleEngineService.kt` 的测试文件，了解项目中的测试结构、命名约定、依赖注入方式以及常用的 Fake 类。

2. **检查 AuthService.kt**：查看 `AuthService` 的三个公共方法（`login`、`logout`、`refreshToken`）的签名、依赖项和可能的异常情况。

3. **确定依赖项**：识别 `AuthService` 依赖的外部组件（如网络客户端、数据库、令牌管理器等），并为每个依赖项决定：
   - 如果已有 Fake 类，则直接使用
   - 如果没有，则创建合适的 Fake 实现

4. **测试策略**：
   - 为每个公共方法编写测试
   - 覆盖成功路径（happy path）
   - 覆盖主要错误情况（如网络错误、无效凭证、令牌过期等）
   - 遵循 `methodName_condition_expectedResult` 的命名约定

5. **测试结构**：
   - 使用 JUnit 5
   - 使用 Mockito 进行必要的模拟（但优先使用 Fake）
   - 确保不进行真实的网络或数据库调用

6. **覆盖率目标**：设计测试以达到至少 80% 的代码覆盖率。

7. **输出**：生成 `AuthServiceTest.kt` 文件，放在正确的测试目录中。

在开始编写代码之前，请确认这个计划是否可行。&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; You only use Kotlin, JUnit 5, and Mockito
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Task:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Write the unit tests for @AuthService.kt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Context/Constraints:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Follow the existing testing patterns as demonstrated in @RuleEngineService.kt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Start by writing the tests for the three public methods first - &lt;span style="color: #e6db74;"&gt;`login`&lt;/span&gt;, &lt;span style="color: #e6db74;"&gt;`logout`&lt;/span&gt;, &lt;span style="color: #e6db74;"&gt;`refreshToken`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Prefer fakes over mocks; if we don't have a convenient fake class, add one
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Remember, never make real network or database calls in these tests
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Make sure to cover happy paths and error cases as well
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Output:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; AuthServiceTest.kt in folder &amp;lt;src/test/...&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Test names: methodName_condition_expectedResult
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Verify:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Use &lt;span style="color: #e6db74;"&gt;`make test AuthService`&lt;/span&gt; to test just this class
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Don't run lint while iterating; it will take a long time
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; I need to hit a code coverage of at least 80%.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; You can check coverage for this class with &lt;span style="color: #e6db74;"&gt;`make test-coverage AuthService`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;First propose a plan before you start making changes or coding. Proceed only after I accept
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I use a text‑expansion snippet, &lt;code&gt;aiprompt;&lt;/code&gt;, almost every single time. It reminds me to structure any prompt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-markdown"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Persona:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; {cursor}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Task:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;-
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Context/Details/Constraints:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;-
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Output:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;-
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;Verify:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;-
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This structure forces you to think through the problem and gives the AI what it needs to make good decisions.&lt;/p&gt;
&lt;h3 id="custom-commands"&gt;
Custom commands
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#custom-commands"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Writing detailed prompts every single time gets tedious. So you might want to create “&lt;a href="https://docs.anthropic.com/claude/docs/claude-code#slash-commands"&gt;command&lt;/a&gt;” templates. These are just markdown files that capture your detailed prompts.&lt;/p&gt;
&lt;p&gt;People don’t leverage this enough. If your team maintains a shared folder of commands that everyone iterates on, you end up with a powerful set of prompts you can quickly reuse for strong results. I have commands like &lt;code&gt;/write-unit-test.md&lt;/code&gt;, &lt;code&gt;/write-pr-desc.md&lt;/code&gt;, &lt;code&gt;/debug-ticket.md&lt;/code&gt;, &lt;code&gt;/understand-feature.md&lt;/code&gt; etc.&lt;/p&gt;
&lt;h1 id="chunking"&gt;
Chunking
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#chunking"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;AI agents hit limits: context windows fill up, attention drifts, hallucinations creep in, results suffer. Newer models can run hours‑long coding sessions, but until that’s common, the simpler fix is to break work into discrete chunks and plan before coding.&lt;/p&gt;
&lt;p&gt;很多开发者都忽略了这一点。我无法强调这有多重要，尤其是在处理较长的任务时。我的文章详细讨论了这一点；这曾是我个人AI编程实践中最大的一次阶跃式提升。

简单来说，我的做法如下：

**第一阶段——仅规划**

- 分享高层次目标并与智能体反复沟通
- 此阶段不编写代码，仅用于告知智能体后续任务内容
- 确认思路清晰后，要求智能体在项目文件夹中撰写详细的Markdown格式计划
- 开始执行前重置对话上下文

**第二阶段起——逐项执行任务**

- 创建新的智能体实例，加载对应任务
- 仅实现该单项任务，完成验证后提交代码
- 重置或清理当前会话
- 继续处理下一项任务并循环此流程

单次请求迫使智能体同时进行规划和执行——这很少能产生理想结果。试想如果你要向同事提交代码评审，你会如何拆分任务？你肯定不会一次性提交上万行代码，对待智能体也应如此。

规划→拆分→执行→验证。

因此，下次当你未能获得满意结果时，请自问以下三个问题：

- 我是否提供了所有必要的上下文信息？
- 我的提示词是否构成清晰的规范说明？
- 我是否以可验证的小模块为单位进行执行？

顺带一提，我曾撰写过关于整合不同智能体与工具操作指南的文章。此外，Anthropic近期发布的"上下文工程"文章也对相关技术做了很好的概述。&lt;a href="https://kau.sh/blog/agentic-coding-flow-state/"&gt;post&lt;/a&gt; covers this; it was the single biggest step‑function improvement in my own AI coding practice.&lt;/p&gt;
&lt;p&gt;Briefly, here’s how I go about it:&lt;/p&gt;
&lt;h3 id="session-1--plan-only"&gt;
Session 1 — Plan only
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#session-1--plan-only"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Share the high‑level goal and iterate with the agent&lt;/li&gt;
&lt;li&gt;Don’t write code in this session; use it to tell the agent what it’s about to do.&lt;/li&gt;
&lt;li&gt;Once you’re convinced, ask the agent to write the plan in detailed markdown in your &lt;code&gt;.ai/plans/&lt;/code&gt; folder&lt;/li&gt;
&lt;li&gt;Reset context before you start executing&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="session-2--execute-one-task-at-a-time"&gt;
Session 2+ — Execute one task at a time
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#session-2--execute-one-task-at-a-time"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spawn a fresh agent, load &lt;code&gt;task-1.md&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Implement only that task, verify &amp;amp; commit.&lt;/li&gt;
&lt;li&gt;Reset or clear your session.&lt;/li&gt;
&lt;li&gt;Proceed to &lt;code&gt;task-2.md&lt;/code&gt; and repeat.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One‑shot requests force the agent to plan and execute simultaneously — which rarely produces great results. If you were to submit these as PRs to your colleagues for review, how would you break them up? You wouldn’t ship 10,000 lines, so don’t do that with your agents either.&lt;/p&gt;
&lt;p&gt;Plan → chunk → execute → verify.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;So the next time you’re not getting good results, ask yourself these three things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Am I providing all the necessary context?&lt;/li&gt;
&lt;li&gt;Is my prompt a clear spec?&lt;/li&gt;
&lt;li&gt;Am I executing in small, verifiable chunks?&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;I wrote a &lt;a href="https://kau.sh/blog/agents-md/"&gt;post&lt;/a&gt; about this btw, on consolidating these instructions for various agents and tools. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Anthropic’s recent &lt;a href="https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents"&gt;post&lt;/a&gt; on “context engineering” is a good overview of techniques. &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Sun, 05 Oct 2025 16:54:46 +0000</pubDate></item><item><title>氛围工程：Firefox扩展“容器流量控制”</title><link>https://kau.sh/blog/container-traffic-control/</link><description>&lt;p&gt;我想验证一个简单的观点：你可以通过氛围工程（vibe-engineering）端到端地交付可维护的软件。我设定了严格的约束条件：

- 新平台（我从未构建过浏览器扩展/插件）
- 我不再熟练的语言（JavaScript）
- 零手动代码编辑
- 大约一天内完成

结果：

1. 我得到了一个可以提交审核的可用 Firefox 插件。代码达到了我对可读性和长期可维护性的标准。甚至连图标都来自图像模型。

2. 介绍 **Container Traffic Control**。
   - 安装：Firefox 插件列表
   - 代码：github.com/kaushikgopal/ff-container-traffic-control

关于氛围工程的过程：

# 现在流行分享氛围编码导致代码库混乱的恐怖故事。

3. 但我坚信，只要掌握正确的基本原则，你可以通过氛围工程

4. 构建出一个可以放心交给其他工程师的代码库。

这就是我为了验证自己在这个问题上的感受所做的实验。当然，这是一个规模较小、可以说非常简单的代码库，但就我个人而言，我也在中等规模的代码库上取得了成功。

关键在于 **严谨的修剪**：更新系统指令、细致的提示和代码审查。我计划以后详细讨论这一点，但现在让我们谈谈具体实施过程中的一些机制：

我没有手动编写一行 JavaScript 代码。当我需要修改、更好的结构、可复用的模式或小的重构时，我都会向智能体（agent）提出请求。整个过程的目标很简单：保持代码库的可读性和可维护性。现在，这个代码库具备了我们认为一个良好代码库应有的许多重要特性：

- 测试（针对重要部分）
- 组织良好的代码
- 清晰、有用的日志记录
- 代码注释（采用了一种名为 **航天飞机风格编程** 的风格，我认为这在氛围工程中越来越有价值）

最棒的部分是：大部分工作是在两天内完成的。

5. 以下是代码库中的一些示例拉取请求，包含了我使用的确切提示和生成的计划：

这是我用来生成代码核心部分的第一个提示：

# 角色/人设：&lt;a href="https://kau.sh/blog/vibe-eng"&gt;vibe-engineering&lt;/a&gt; end to end. I set strict constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New platform (I haven’t built a browser extension/add-on)&lt;/li&gt;
&lt;li&gt;Language I’m no longer proficient in (JavaScript)&lt;/li&gt;
&lt;li&gt;Zero manual code editing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In about a day&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; I had a working Firefox add-on I could submit for review. The code meets my bar for readability and long‑term change. Even the icon came from an image model.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Introducing &lt;a href="https://addons.mozilla.org/en-US/firefox/addon/ctc/"&gt;Container Traffic Control&lt;/a&gt;.&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-info" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="12" cy="12" r="10"&gt;&lt;/circle&gt;&lt;path d="M12 16v-4"&gt;&lt;/path&gt;&lt;path d="M12 8h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;
Install and source
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;• Install: &lt;a href="https://addons.mozilla.org/en-US/firefox/addon/ctc/"&gt;Firefox add-on listing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;• Code: &lt;a href="https://github.com/kaushikgopal/ff-container-traffic-control"&gt;github.com/kaushikgopal/ff-container-traffic-control&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;figure class="rounded-2xl!"&gt;
&lt;div align="center"&gt;
&lt;img alt="Container Traffic Control Icon" class="rounded-2xl!" src="https://raw.githubusercontent.com/kaushikgopal/ff-container-traffic-control/refs/heads/master/icons/icon.png" width="300"/&gt;
&lt;/div&gt;
&lt;/figure&gt;
&lt;h2 id="on-the-vibe-engineering-process"&gt;
On the vibe-engineering process
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#on-the-vibe-engineering-process"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;It’s in vogue to share horror stories of decimated vibe-coded repos.&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt; But I’m convinced that with the right fundamentals, you can vibe-engineer&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt; a codebase you’d comfortably hand to another engineer.&lt;/p&gt;
&lt;p&gt;This was my experiment to vet my feelings on the subject. Granted, this was a small and arguably very simple repository, but I’ve also seen success with moderately larger codebases personally.&lt;/p&gt;
&lt;p&gt;It comes down to &lt;strong&gt;scrupulous pruning&lt;/strong&gt;: updating system instructions, diligent prompting, and code review. I plan to write much more about this later, but let’s talk about some of the mechanics of how it went:&lt;/p&gt;
&lt;p&gt;I didn’t write a single line of JavaScript by hand. When I needed changes, better structure, reusable patterns, small refactors — I asked the agent. The goal throughout was simple: keep the codebase readable and maintainable. It now has a lot of the things we consider important for a decent codebase:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tests (for the important parts)&lt;/li&gt;
&lt;li&gt;Well-organized code&lt;/li&gt;
&lt;li&gt;Clear, useful logging&lt;/li&gt;
&lt;li&gt;Code comments (uses a style called &lt;a href="https://kau.sh/blog/space-shuttle-style-programming/"&gt;space-shuttle style programming&lt;/a&gt;, which I think is increasingly valuable with vibe-engineering)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The best part: most of this came together over two days.&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:5"&gt;5&lt;/a&gt;&lt;/sup&gt; Some example pull requests from the repository with the exact prompt I used and the plan that was generated:&lt;/p&gt;
&lt;p&gt;Here’s the very first prompt I used to generate the guts of the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-markdown"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;# Role/Persona:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt;```javascript
// background.js - Container Traffic Control (CTC) Firefox Extension
// Main background script for rule management and validation

// Storage key for rules
const RULES_STORAGE_KEY = 'ctc_rules';

// Initialize rules array
let redirectRules = [];

/**
 * Load rules from browser storage
 */
async function loadRules() {
  try {
    const result = await browser.storage.local.get(RULES_STORAGE_KEY);
    redirectRules = result[RULES_STORAGE_KEY] || [];
    console.debug('CTC: Rules loaded from storage:', redirectRules);
  } catch (error) {
    console.error('CTC: Failed to load rules:', error);
    redirectRules = [];
  }
}

/**
 * Save rules to browser storage
 */
async function saveRules() {
  try {
    await browser.storage.local.set({ [RULES_STORAGE_KEY]: redirectRules });
    console.debug('CTC: Rules saved to storage');
  } catch (error) {
    console.error('CTC: Failed to save rules:', error);
  }
}

/**
 * Validate a single rule
 * @param {Object} rule - Rule object to validate
 * @returns {Object} Validation result with isValid and message
 */
function validateRule(rule) {
  // Check required fields
  if (!rule.containerName || !rule.action || !rule.urlPattern) {
    return {
      isValid: false,
      message: 'Missing required fields: containerName, action, and urlPattern are required'
    };
  }

  // Validate action
  if (!['allow', 'block'].includes(rule.action)) {
    return {
      isValid: false,
      message: 'Action must be either "allow" or "block"'
    };
  }

  // Validate URL pattern (basic regex validation)
  try {
    new RegExp(rule.urlPattern);
  } catch (error) {
    return {
      isValid: false,
      message: `Invalid URL pattern regex: ${error.message}`
    };
  }

  // Validate highPriority is boolean
  if (typeof rule.highPriority !== 'boolean') {
    return {
      isValid: false,
      message: 'highPriority must be a boolean value'
    };
  }

  return { isValid: true, message: 'Rule is valid' };
}

/**
 * Validate all rules for conflicts and constraints
 * @returns {Object} Validation result with isValid and messages
 */
function validateAllRules() {
  const messages = [];
  const urlPatternMap = new Map();
  const conflicts = new Set();

  // Check each rule
  for (let i = 0; i &amp;lt; redirectRules.length; i++) {
    const rule = redirectRules[i];
    const ruleId = `${rule.urlPattern}_${i}`;

    // Individual rule validation
    const ruleValidation = validateRule(rule);
    if (!ruleValidation.isValid) {
      messages.push(`Rule ${i + 1}: ${ruleValidation.message}`);
      conflicts.add(ruleId);
    }

    // Track URL patterns for conflict detection
    if (!urlPatternMap.has(rule.urlPattern)) {
      urlPatternMap.set(rule.urlPattern, {
        highPriorityContainers: new Set(),
        actions: new Set()
      });
    }

    const patternData = urlPatternMap.get(rule.urlPattern);

    // Check for multiple high priority containers on same URL pattern
    if (rule.highPriority) {
      patternData.highPriorityContainers.add(rule.containerName);
      if (patternData.highPriorityContainers.size &amp;gt; 1) {
        messages.push(`URL pattern "${rule.urlPattern}" has multiple high priority containers`);
        conflicts.add(ruleId);
      }
    }

    // Check for both allow and block on same URL pattern
    patternData.actions.add(rule.action);
    if (patternData.actions.has('allow') &amp;amp;&amp;amp; patternData.actions.has('block')) {
      messages.push(`URL pattern "${rule.urlPattern}" has both allow and block actions`);
      conflicts.add(ruleId);
    }
  }

  // Special validation for "*" pattern with allow action
  const starPatternRules = redirectRules.filter(rule =&amp;gt; rule.urlPattern === '*');
  if (starPatternRules.length &amp;gt; 0) {
    const hasAllowStar = starPatternRules.some(rule =&amp;gt; rule.action === 'allow');
    if (hasAllowStar) {
      messages.push('URL pattern "*" with allow action is invalid');
      starPatternRules.forEach((rule, index) =&amp;gt; {
        const originalIndex = redirectRules.indexOf(rule);
        conflicts.add(`${rule.urlPattern}_${originalIndex}`);
      });
    }
  }

  const isValid = conflicts.size === 0;
  return {
    isValid,
    messages: isValid ? ['All rules are valid'] : messages,
    invalidRuleIds: Array.from(conflicts)
  };
}

/**
 * Add a new rule with validation
 * @param {Object} newRule - Rule object to add
 * @returns {Object} Result with success status and message
 */
async function addRule(newRule) {
  console.debug('CTC: Attempting to add new rule:', newRule);

  // Validate the new rule
  const ruleValidation = validateRule(newRule);
  if (!ruleValidation.isValid) {
    console.error('CTC: New rule validation failed:', ruleValidation.message);
    return {
      success: false,
      message: ruleValidation.message
    };
  }

  // Add rule temporarily for validation
  const tempRules = [...redirectRules, newRule];
  const originalRules = redirectRules;
  redirectRules = tempRules;

  // Validate all rules including the new one
  const allValidation = validateAllRules();
  
  if (!allValidation.isValid) {
    // Restore original rules
    redirectRules = originalRules;
    console.error('CTC: Rule conflicts detected:', allValidation.messages);
    return {
      success: false,
      message: `Rule conflicts: ${allValidation.messages.join('; ')}`
    };
  }

  // Save the valid rule
  await saveRules();
  
  // Print debug output of all rules
  printRulesDebug();
  
  console.debug('CTC: Rule added successfully');
  return {
    success: true,
    message: 'Rule added successfully'
  };
}

/**
 * Update an existing rule
 * @param {number} index - Index of rule to update
 * @param {Object} updatedRule - Updated rule object
 * @returns {Object} Result with success status and message
 */
async function updateRule(index, updatedRule) {
  console.debug('CTC: Attempting to update rule at index', index, ':', updatedRule);

  if (index &amp;lt; 0 || index &amp;gt;= redirectRules.length) {
    return {
      success: false,
      message: 'Invalid rule index'
    };
  }

  // Validate the updated rule
  const ruleValidation = validateRule(updatedRule);
  if (!ruleValidation.isValid) {
    console.error('CTC: Updated rule validation failed:', ruleValidation.message);
    return {
      success: false,
      message: ruleValidation.message
    };
  }

  // Update rule temporarily for validation
  const tempRules = [...redirectRules];
  tempRules[index] = updatedRule;
  const originalRules = redirectRules;
  redirectRules = tempRules;

  // Validate all rules
  const allValidation = validateAllRules();
  
  if (!allValidation.isValid) {
    // Restore original rules
    redirectRules = originalRules;
    console.error('CTC: Rule conflicts detected after update:', allValidation.messages);
    return {
      success: false,
      message: `Rule conflicts: ${allValidation.messages.join('; ')}`
    };
  }

  // Save the updated rules
  await saveRules();
  
  // Print debug output
  printRulesDebug();
  
  console.debug('CTC: Rule updated successfully');
  return {
    success: true,
    message: 'Rule updated successfully'
  };
}

/**
 * Delete a rule by index
 * @param {number} index - Index of rule to delete
 */
async function deleteRule(index) {
  if (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; redirectRules.length) {
    redirectRules.splice(index, 1);
    await saveRules();
    printRulesDebug();
    console.debug(`CTC: Rule at index ${index} deleted`);
  }
}

/**
 * Print debug output of all rules in a readable format
 */
function printRulesDebug() {
  console.group('CTC: Current Rules');
  console.log('Total rules:', redirectRules.length);
  
  if (redirectRules.length === 0) {
    console.log('No rules configured');
  } else {
    console.table(redirectRules.map((rule, index) =&amp;gt; ({
      '#': index + 1,
      'Container': rule.containerName,
      'Action': rule.action,
      'URL Pattern': rule.urlPattern,
      'High Priority': rule.highPriority ? 'Yes' : 'No'
    })));
  }
  
  console.groupEnd();
}

/**
 * Clear all rules
 */
async function clearAllRules() {
  redirectRules = [];
  await saveRules();
  console.debug('CTC: All rules cleared');
  printRulesDebug();
}

/**
 * Get all rules (for UI or other components)
 * @returns {Array} Copy of all rules
 */
function getAllRules() {
  return [...redirectRules];
}

/**
 * Get validation status of all rules
 * @returns {Object} Validation result
 */
function getValidationStatus() {
  return validateAllRules();
}

// Initialize when extension loads
loadRules().then(() =&amp;gt; {
  console.debug('CTC: Extension initialized');
  printRulesDebug();
});

// Export functions for use in other modules
if (typeof module !== 'undefined' &amp;amp;&amp;amp; module.exports) {
  module.exports = {
    addRule,
    updateRule,
    deleteRule,
    clearAllRules,
    getAllRules,
    getValidationStatus,
    validateRule,
    validateAllRules,
    printRulesDebug
  };
}
```&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; you have a strong propensity to write clearly legible code with simple to understand code comments.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;# Task/Goal:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; write the functionality for the firefox add-on "Container Traffic Control" (CTC). I will provide you with the
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;requirements
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; work on first task which is adding the rules, running the validation check, then outputting clear debug logs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;# Details:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; the container takes in rules from the preferences panel; it does it similarly to how the extension (see
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;screenshot)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; you can find all the relevant code for the extension "conductor" that does something similar
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;https://github.com/mcortt/Conductor - this is where the screenshot is from
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; where CTC is different from conductor is that CTC takes in a rule with 4 possible fields (each rule will have 4
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;fields)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; 1. container name (name of firefox container)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; 2. allow/block (drop down that says this rule should either "block" or "allow"
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; 3. url pattern (regex pattern that will match the website url someone is about to navigate to)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; 4. high prioirty (is this rule a high prioirty rule)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; CTC will build a redirectRules object similar to Conductor based on the rules that a user inputs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;[Image #1]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; on attempting to save a rule, CTC will always run a "validation check" on all rules:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; same url pattern cannot have more than one high priority container
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; same url pattern cannot have both allow and block
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt; &lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; Allow Only + &lt;span style="color: #e6db74;"&gt;`*`&lt;/span&gt; - invalid rule
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;in a future task i will provide how to process these rules. but for now, i would like to achieve the following:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; allow a user to input rules
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; rule is saved if validated
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; on each save, print an output log showing the table or list of rules object
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;the code must be extremely legible, simple and clean
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; avoid overly nesting or including too many classes of fancy javascript
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;# Context:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; https://github.com/mcortt/Conductor/blob/6daa9ce23f2de0dc43f9e07378da03f141195fec/background.js is the main file
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;从conductor中你可以汲取灵感  
-  
我也喜欢这个附加组件 https://github.com/kemayo/firefox-sticky-containers/blob/master/background.js，它的代码注释和细节风格清晰——可以参考其编写代码、添加注释和调试日志的方式。  
-  
container-redirect 是一个高级附加组件，提供了与CTC最终将实现的几乎相同复杂程度/功能集——代码可在此处找到：https://github.com/max-dw-i/container-redirect/blob/master/src/index.js；你可以通过它了解Firefox容器的工作原理、可实现的不同功能等。  
如有必要，你可以搜索这些插件的代码库。  
# 输出格式：  
-  
我希望你仔细阅读这些要求  
-  
如果有不清楚的地方，请提出并向我提问  
-  
首先提出一套任务或计划，说明你打算如何实现此功能。  
一旦我同意该计划，我希望你在 @.ai/plans/ctc-add-rule.md 中撰写一份详细的检查点文档。  
我记录了我的提示，但未在拉取请求中充分展示；以下是我确实记录的几个：  
这是一个拉取请求，其中我中途记录了一个主要功能变更：附加组件的原始版本使用了非常不同的规则捕获方式，不够直观，因此我决定进行更改。  
这更像是一个有趣的尝试，我要求它以HN读者的身份批评代码。其中提出了一些好建议，但明确指定角色在此特定情况下并未产生有帮助的内容。  
代码是开源的，所以请随意查看。  
关于附加组件本身  
#  
在我上一篇文章《如何玩转Firefox》中，我介绍了“隐私增强：容器”。  
“容器”功能让你无需使用独立的浏览器配置文件即可登录多个Gmail账户。加上“总Cookie保护”，就能实现强大的隔离效果。  
这很棒，但自动管理容器很快会变得繁琐。例如：  
将搜索保留在一个容器中，但在我的默认容器中打开结果链接。&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; i also like the addon https://github.com/kemayo/firefox-sticky-containers/blob/master/background.js which has a
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;clean style of code commenting and details - use this for inspiration in terms of how to write the code, add
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;comments, and debug logs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; container-redirect is an advanced add-on which provides almost the same set of complexity/functionality that CTC
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;will eventually achieve - code can be found here
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;https://github.com/max-dw-i/container-redirect/blob/master/src/index.js ; you may use this to figure out how
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;containers in firefox work, differnet functionality that can be achieved etc.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;you are allowed to search the codebases of these plugins if necessary.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;# Output Format:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; i want you to go through the asks
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; if there are things that are unclear, raise them and ask me questions
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #66d9ef;"&gt;-&lt;/span&gt; propose a set of tasks or plan on how you intend to go about achieving this feature first.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;once i agree to the plan, i want you to write down a detailed checkpoint document in @.ai/plans/ctc-add-rule.md
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I captured my prompts but wasn’t diligent about surfacing them in pull requests; here are a few I did capture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Here’s a &lt;a href="https://github.com/kaushikgopal/ff-container-traffic-control/pull/2"&gt;PR&lt;/a&gt; where midway I captured a major feature change: the original version of the add-on used a very different way of capturing the rules. It wasn’t as intuitive, so I decided to change it up.&lt;/li&gt;
&lt;li&gt;This was more a &lt;a href="https://github.com/kaushikgopal/ff-container-traffic-control/pull/1"&gt;fun one&lt;/a&gt; where I asked it to critique the code as an HN reader would. Some good suggestions came out of it, but the explicit persona callout didn’t generate anything helpful in this specific case.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code is open source, so go ahead and &lt;a href="https://github.com/kaushikgopal/ff-container-traffic-control/"&gt;check it out&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="about-the-add-on-itself"&gt;
About the add-on itself
&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#about-the-add-on-itself"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In my last post, &lt;a href="https://kau.sh/blog/how-to-firefox/#privacy-power-up-containers"&gt;How to Firefox&lt;/a&gt;, I covered “Privacy power-up: Containers”.&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:6"&gt;6&lt;/a&gt;&lt;/sup&gt; “Containers” let you log in to multiple Gmail accounts without separate browser profiles. Add &lt;a href="https://support.mozilla.org/en-US/kb/introducing-total-cookie-protection-standard-mode"&gt;Total Cookie Protection&lt;/a&gt; and you get strong isolation.&lt;/p&gt;
&lt;p&gt;That’s great, but managing it automatically gets tedious fast. Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keep &lt;code&gt;google.com&lt;/code&gt; searches in one container, but open result links in my default container.&lt;/li&gt;
&lt;li&gt;从工作Gmail点击GitHub链接时：若为&lt;code&gt;github.com/instacart&lt;/code&gt;，则在工作环境打开；若为&lt;code&gt;github.com/kaushikgopal&lt;/code&gt;，则在个人环境打开。&lt;/li&gt;
&lt;li&gt;在个人版Google Docs中点击Sheets或Drive链接时，应保持在个人环境——即使我的Sheets默认设置是工作环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-info" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="12" cy="12" r="10"&gt;&lt;/circle&gt;&lt;path d="M12 16v-4"&gt;&lt;/path&gt;&lt;path d="M12 8h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;已添加这些测试用例&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;撰写本文时我意识到，或许应该对这些具体场景进行测试，于是&lt;a href="https://github.com/kaushikgopal/ff-container-traffic-control/pull/3"&gt;我立刻着手实施&lt;/a&gt;……在继续完善这篇文章的过程中。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;若仅依赖默认容器配置，你无法实现如此精细的控制——除非逐条管理每个场景，即便如此仍有部分情况无法解决。我尝试过&lt;a href="https://github.com/kintesh/containerise"&gt;多种&lt;/a&gt; &lt;a href="https://github.com/mcortt/Conductor/tree/main"&gt;扩展程序&lt;/a&gt;，但总会遇到&lt;a href="https://github.com/kintesh/containerise/issues/24"&gt;某些&lt;/a&gt; &lt;a href="https://github.com/kintesh/containerise/pull/167"&gt;始终&lt;/a&gt; &lt;a href="https://github.com/kintesh/containerise/issues/53"&gt;无法&lt;/a&gt;生效&lt;/p&gt;
&lt;p&gt;的情况。&lt;/p&gt;
&lt;figure&gt;
&lt;div align="center"&gt;
&lt;img alt="Rule setup" src="https://kau.sh/images/content/uploads/2025/ctc-1.webp"/&gt;
&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;div align="center"&gt;
&lt;img alt="How the rules work" src="https://kau.sh/images/content/uploads/2025/ctc-2.webp"/&gt;
&lt;/div&gt;
&lt;/figure&gt;
&lt;p&gt;因此我构建了自己的工具。这款扩展的规则设置方式也更符合我的偏好：&lt;a href="https://addons.mozilla.org/en-US/firefox/addon/ctc/"&gt;总体而言，这次实验令我受益匪浅。目前我正愉快地使用着自研的&lt;/a&gt;扩展程序&lt;/p&gt;
&lt;p&gt;，并且确信若需调整功能，能在可维护的代码基础上轻松实现。&lt;/p&gt;
&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-info" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="12" cy="12" r="10"&gt;&lt;/circle&gt;&lt;path d="M12 16v-4"&gt;&lt;/path&gt;&lt;path d="M12 8h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;敬请期待我关于如何更高效运用AI编程的后续建议。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;氛围编码与氛围工程&lt;a href="https://simonwillison.net/2025/Oct/7/vibe-engineering/"&gt;西蒙·威利森开始使用&lt;/a&gt;氛围工程&lt;a href="https://kau.sh/blog/vibe-eng"&gt;这个术语，特指具备严谨性的氛围编码实践。我正努力深化这种工作方式。更多关于二者差异的探讨可参阅我的&lt;/a&gt;后续文章&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;。&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;核心功能耗时数小时；其余调整穿插在其他工作间隙完成。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="https://gemini.google/overview/image-generation/"&gt;↩︎&lt;/a&gt;谷歌最新推出的🍌模型&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;↩︎&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:3"&gt;我从未否认其存在性。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;↩︎&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:4"&gt;此处我刻意避免使用“氛围编码”一词。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;↩︎&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:5"&gt;坦率说，实际工作量可能就几小时。我主要通过侧边栏指令操作，处理其他事务后会抽空返回调整和优化。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;↩︎&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:6"&gt;本文现已更新指向我新开发的Firefox扩展。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Mon, 29 Sep 2025 02:31:35 +0000</pubDate></item><item><title>找出问题USB-C数据线的终端命令</title><link>https://kau.sh/blog/usbi/</link><description>&lt;div class="callout"&gt;
&lt;div class="callout-icon"&gt;
&lt;svg class="svg-icon lucide-info" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="12" cy="12" r="10"&gt;&lt;/circle&gt;&lt;path d="M12 16v-4"&gt;&lt;/path&gt;&lt;path d="M12 8h.01"&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;div class="callout-title" dir="auto"&gt;
&lt;div class="callout-title-inner"&gt;现已支持macOS Tahoe系统&lt;/div&gt;
&lt;/div&gt;
&lt;div class="callout-content"&gt;
&lt;p&gt;苹果对Tahoe的系统指令做了微调&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;抽屉里塞满USB线，一半是连充电都费劲的电子垃圾，另一半却能全速传输数据——你分得清吗？&lt;/p&gt;
&lt;p&gt;Android Studio早就解决了这个问题，新版本在连接低速数据线时会主动提醒：&lt;/p&gt;
&lt;figure class="w-[80%] rounded-2xl!"&gt;
&lt;div align="center"&gt;
&lt;img alt="Android Studio Warning" class="w-[80%] rounded-2xl!" src="https://developer.android.com/static/studio/images/usb-check.png"/&gt;
&lt;figcaption&gt;
&lt;a class="center" href="https://developer.android.com/studio/releases/past-releases/as-koala-feature-drop-release-notes#usb-check"&gt;developers.android.com&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/div&gt;
&lt;/figure&gt;
&lt;p&gt;现在我把这个功能搬到了命令行，于是“造”出了&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;a href="https://gist.github.com/kaushikgopal/7e1555569cd5bb3138cb5ca67bb7a4ae"&gt;&lt;code&gt;usbi&lt;/code&gt;&lt;/a&gt;这个检测USB连接速度的脚本&lt;/p&gt;
更多
&lt;p&gt;脚本通过解析macOS的&lt;code&gt;system_profiler SPUSBHostDataType&lt;/code&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;指令实现，原始输出信息密集难以阅读：&lt;/p&gt;
&lt;figure&gt;
&lt;img alt="raw output form macos command" src="https://kau.sh/images/content/uploads/2025/usbi-0.webp"/&gt;
&lt;/figure&gt;
&lt;p&gt;经过简单脚本处理，输出立刻清爽起来：&lt;/p&gt;
&lt;figure&gt;
&lt;img alt="usbi --speed output sample" src="https://kau.sh/images/content/uploads/2025/usbi-1.webp"/&gt;
&lt;/figure&gt;
&lt;p&gt;连接Pixel&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kau.sh/feed.xml#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;时的检测效果：&lt;/p&gt;
&lt;figure&gt;
&lt;img alt="usbi output with pixel phone attached" src="https://kau.sh/images/content/uploads/2025/usbi-2.webp"/&gt;
&lt;/figure&gt;
&lt;h2 id="quick-notes-on-the-vibe-coding-experience"&gt;关于氛围编程的几点心得&lt;a class="heading-anchor" href="https://kau.sh/feed.xml#quick-notes-on-the-vibe-coding-experience"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;初版是用AI拼凑的bash脚本，虽然能用但维护起来一团糟。因为完全交给AI主导，连修改输出颜色这种小调整都很困难&lt;/p&gt;
&lt;p&gt;第二次我决定继续氛围编程，但让AI用&lt;a href="https://go.dev/"&gt;Go&lt;/a&gt;彻底重写。选择Go是因为代码结构更清晰易改，而且独特的跨平台编译能力让我能在任何机器上运行&lt;/p&gt;
&lt;p&gt;但最关键的是——AI只用了10分钟就完成重写。我这边忙着回邮件，Claude在后台默默就把活干完了&lt;/p&gt;
&lt;p&gt;换作两年前，我根本不会考虑重写，甚至最初都不会创建这个脚本。开发阻力太大了。而现在，构建这类小工具几乎零成本&lt;/p&gt;
&lt;p&gt;这才是重点：重要的不是脚本本身，而是AI如何重塑我们衡量时间价值的标尺&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;没错，就是氛围编程，而且我毫不避讳这一点&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:1"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;早期macOS版本使用&lt;code&gt;SPUSBDataType&lt;/code&gt; &lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:2"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;我让Claude整理了主流Pixel手机的规格参数。如果哪天换回iPhone，也会如法炮制&lt;a class="footnote-backref" href="https://kau.sh/feed.xml#fnref:3"&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><pubDate>Tue, 16 Sep 2025 03:50:45 +0000</pubDate></item></channel></rss>