<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Willison's Weblog (中文)</title><link>http://simonwillison.net/</link><description/><language>zh-CN</language><lastBuildDate>Wed, 25 Feb 2026 17:33:24 +0000</lastBuildDate><item><title>Claude 代码远程控制</title><link>https://simonwillison.net/2026/Feb/25/claude-code-remote-control/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://code.claude.com/docs/en/remote-control"&gt;Claude Code 远程控制&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
昨天推出了新的 Claude Code 功能：你现在可以在电脑上运行一个“远程控制”会话，然后使用 Claude Code 的网页界面（网页版、iOS 版和原生桌面应用）向该会话发送指令。
&lt;p&gt;目前它还有点不稳定。我最初尝试时遇到了错误“您的账户未启用远程控制功能。请联系您的管理员。”（但我&lt;em&gt;就是&lt;/em&gt;我的管理员？）——然后我退出并重新登录 Claude Code 终端应用，它就开始工作了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;claude remote-control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你一次只能在一台机器上运行一个会话。如果你升级了 Claude iOS 应用，它会在 Code 标签页中显示为“远程控制会话（Mac）”。&lt;/p&gt;
&lt;p&gt;它似乎不支持 &lt;code&gt;--dangerously-skip-permissions&lt;/code&gt; 标志（我将其传递给 &lt;code&gt;claude remote-control&lt;/code&gt;，它没有拒绝该选项，但似乎也没有效果）——这意味着你必须批准它采取的每一个新操作。&lt;/p&gt;
&lt;p&gt;我还设法让它进入了一种状态，即我尝试的每个指令都会遇到 API 500 错误。&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img alt="“远程控制会话”（Mac:dev:817b）聊天界面的截图。用户消息：“在音乐应用中播放 Olivia Rodrigo 的 vampire”。响应显示一个 API 错误：500 {&amp;quot;type&amp;quot;:&amp;quot;error&amp;quot;,&amp;quot;error&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;api_error&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Internal server error&amp;quot;},&amp;quot;request_id&amp;quot;:&amp;quot;req_011CYVBLH9yt2ze2qehrX8nk&amp;quot;}，带有一个“重试”按钮。下方，助手回复：“我将使用 AppleScript 在音乐应用中播放 Olivia Rodrigo 的‘Vampire’。”一个 Bash 命令面板打开，显示一个 osascript 命令：osascript -e 'tell application &amp;quot;Music&amp;quot; activate set searchResults to search playlist &amp;quot;Library&amp;quot; for &amp;quot;vampire Olivia Rodrigo&amp;quot; if (count of searchResults) &amp;gt; 0 then play item 1 of searchResults else return &amp;quot;Song not found in library&amp;quot; end if end tell'" src="https://static.simonwillison.net/static/2026/vampire-remote.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;在机器上重启程序也会导致现有会话开始返回神秘的 API 错误，而不是清晰地说明会话已终止。&lt;/p&gt;
&lt;p&gt;我预计他们会相对较快地解决所有这些问题。有趣的是，可以将此与 OpenClaw 等解决方案进行对比，后者的主要卖点之一就是能够从手机控制你的个人设备。&lt;/p&gt;
&lt;p&gt;Claude Code 仍然没有记录在案的机制来按计划运行任务，而这是 Claw 类软件的另一个杀手级功能。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：我话说得太早了：今天Anthropic还宣布了&lt;a href="https://support.claude.com/en/articles/13854387-schedule-recurring-tasks-in-cowork"&gt;在Cowork中安排重复任务&lt;/a&gt;，这是Claude Code的&lt;a href="https://simonwillison.net/2026/Jan/12/claude-cowork/"&gt;通用智能体兄弟产品&lt;/a&gt;。这其中确实包含一个重要限制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计划任务仅在您的计算机处于唤醒状态且Claude桌面应用程序处于打开状态时运行。如果任务计划运行时您的计算机处于睡眠状态或应用程序已关闭，Cowork将跳过该任务，并在您的计算机唤醒或您再次打开桌面应用程序后自动运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我真心希望他们正在开发Cowork云端产品。

    &lt;p&gt;&lt;small&gt;&lt;/small&gt;通过&lt;a href="https://twitter.com/claudeai/status/2026418433911603668"&gt;@claudeai&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/applescript"&gt;applescript&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/anthropic"&gt;anthropic&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/claude"&gt;claude&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/claude-code"&gt;claude-code&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/openclaw"&gt;openclaw&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 17:33:24 +0000</pubDate></item><item><title>我通过氛围编码打造了我的梦想macOS演示应用</title><link>https://simonwillison.net/2026/Feb/25/present/#atom-everything</link><description>&lt;p&gt;这个周末，我在山景城的社会科学FOO营做了一场演讲。活动采用经典的“非会议”形式，任何人都可以上台演讲，无需提前提交提案。我抢到了一个时段，演讲题目是“2026年2月版LLM现状”，副标题是“自十一月以来，一切都变了！”。演讲前一晚，我即兴编写了一个定制的macOS应用程序来做演示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="FOO营公告板上的一张便利贴。上面写着：LLM现状，2026年2月版 - 自十一月以来，一切都变了！Simon Willison - 卡片上布满了新模型的名字：Qwen 3.5, DeepSeek 3.2, Sonnet 4.6, Kimi K2.5, GLM5, Opus 4.5/4.6, Gemini 3.1 Pro, Codex 5.3。旁边的卡片上写着：为什么社会科学家认为他们需要遗传学？Bill January（并不全是因为AI）" src="https://static.simonwillison.net/static/2026/state-of-llms.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;关于过去十二个月LLM的发展，我曾在&lt;a href="https://simonwillison.net/2023/Dec/31/ai-in-2023/"&gt;2023年12月&lt;/a&gt;、&lt;a href="https://simonwillison.net/2024/Dec/31/llms-in-2024/"&gt;2024年12月&lt;/a&gt;和&lt;a href="https://simonwillison.net/2025/Dec/31/the-year-in-llms/"&gt;2025年12月&lt;/a&gt;写过文章。我还在2025年6月的AI工程师世界博览会上做了题为&lt;a href="https://simonwillison.net/2025/Jun/6/six-months-in-llms/"&gt;《过去六个月的LLM，由骑自行车的鹈鹕图解》&lt;/a&gt;的演讲。这是我第一次将涵盖的时间缩短到仅仅三个月，这巧妙地说明了这个领域的发展速度有多快，考虑到&lt;a href="https://simonwillison.net/2026/Jan/4/inflection/"&gt;2025年11月的拐点&lt;/a&gt;，这样做感觉很合适。&lt;/p&gt;
&lt;p&gt;（为了进一步说明这种加速，我穿着Gemini 3的毛衣去演讲，这件毛衣是几周前别人给我的，现在已经过时了，&lt;a href="https://simonwillison.net/2026/Feb/19/gemini-31-pro/"&gt;多亏了Gemini 3.1&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;基于我在&lt;a href="https://simonwillison.net/2019/Dec/10/better-presentations/"&gt;斯坦福学到的&lt;/a&gt;STAR时刻原则——包含一些他们总会记住的东西，以帮助你的演讲脱颖而出——我总是喜欢在我的任何演讲中至少安排一个“噱头”。&lt;/p&gt;
&lt;p&gt;这次演讲我准备了两个噱头。我围绕编码智能体辅助分析鸮鹦鹉繁殖季节的数据来构建演讲的第一部分（这意味着我可以&lt;a href="https://simonwillison.net/2026/Feb/8/kakapo-mug/"&gt;炫耀我的马克杯&lt;/a&gt;），然后快速浏览了一些骑自行车的新鹈鹕图片，最后揭晓整个演示文稿都是使用一个全新的macOS应用程序呈现的，而这个应用是我在演讲前一晚花了大约45分钟即兴编码完成的。&lt;/p&gt;
&lt;h4 id="present-app"&gt;Present.app&lt;/h4&gt;
&lt;p&gt;这个应用叫做&lt;strong&gt;Present&lt;/strong&gt;——字面意思就是我想到的第一个名字。它是用Swift和SwiftUI构建的，大小为355KB，或者&lt;a href="https://github.com/simonw/present/releases/tag/0.1a0"&gt;压缩后76KB&lt;/a&gt;。Swift应用真是小巧！&lt;/p&gt;&lt;p&gt;虽然构建过程可能很快，但这一整套功能是我多年来一直梦寐以求的。&lt;/p&gt;
&lt;p&gt;我通常使用 Keynote 来做演示，但有时我喜欢通过一系列网页来展示，以变换方式。我的做法是在浏览器窗口中为每个页面打开一个标签页，然后在讲解时依次点击这些标签页。&lt;/p&gt;
&lt;p&gt;这方法效果很好，但有一个非常可怕的缺点：如果浏览器崩溃，我就失去了整个演示文稿！&lt;/p&gt;
&lt;p&gt;我总是把网址保存在一个笔记文件里，这样在需要时可以点击它并手动重新打开所有页面，但在演讲中途处理这种事可不是我想要的。&lt;/p&gt;
&lt;p&gt;这是我的初始提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构建一个用于演示的 SwiftUI 应用，其中每一张幻灯片都是一个 URL。应用启动时是一个窗口，右侧是网页视图，左侧是用于添加、删除和重新排序 URL 序列的界面。然后点击菜单中的“播放”，应用会进入全屏模式，左右方向键可以在 URL 之间切换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这产生了一个计划。你可以在这里查看实现该计划的对话记录。&lt;/p&gt;
&lt;p&gt;在 Present 应用中，一个演讲就是一个有序的 URL 序列，侧边栏界面用于添加、删除和重新排序这些 URL。这就是全部编辑体验。&lt;/p&gt;
&lt;p&gt;&lt;img alt='一个名为"Present"的macOS应用窗口截图，显示谷歌图片搜索"kakapo"的结果。网页视图显示了一个谷歌图片搜索页面，包含带有标题的鸮鹦鹉缩略图。左侧边栏显示了一个带编号的URL列表，大部分来自simonwillison.net和static.simonwillison.net，其中第4项（https://www.google.com/search?...）以蓝色高亮显示。' src="https://static.simonwillison.net/static/2026/present.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;当你选择菜单中的“播放”选项（或按下 Cmd+Shift+P）时，应用会切换到全屏模式。左右方向键可以前后导航，如果需要，你还可以增大或减小字体大小，或者滚动页面。完成后按 Escape 键。&lt;/p&gt;
&lt;p&gt;关键的是，Present 会在你进行任何更改时自动保存你的 URL。如果应用崩溃，你可以重新启动它并恢复你的演示状态。&lt;/p&gt;
&lt;p&gt;你还可以将演示文稿保存为 .txt 文件（实际上就是一个以换行符分隔的 URL 序列），并在以后重新加载。&lt;/p&gt;
&lt;h4 id="remote-controlled-via-my-phone"&gt;通过手机远程控制&lt;/h4&gt;
&lt;p&gt;让初始应用运行起来花费的时间如此之少，以至于我决定追求更宏大的目标。&lt;/p&gt;
&lt;p&gt;为演示配备一个遥控器会很酷……&lt;/p&gt;
&lt;p&gt;所以我提示道：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;添加一个监听在0.0.0.0:9123的网页服务器——该服务器提供一个适配移动设备的单页面，页面左右两侧设有醒目的按钮——点击这些按钮可以左右切换幻灯片——还有一个按钮用于根据当前模式启动或停止演示模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的笔记本电脑和手机上都安装了&lt;a href="https://tailscale.com/"&gt;Tailscale&lt;/a&gt;，这意味着我不必担心Wi-Fi网络会阻止两台设备之间的访问。我的手机可以直接从世界任何地方访问&lt;code&gt;http://100.122.231.116:9123/&lt;/code&gt;，并控制在我笔记本电脑上运行的演示文稿。&lt;/p&gt;
&lt;p&gt;经过几次迭代提示后，最终界面如下所示：&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img alt="手机网页浏览器应用，带有大按钮，顶部显示Slide 4/31，Prev、Next和Start按钮，一个带有上下滚动图标和文字大小加减按钮的细长条，底部显示当前幻灯片URL。" src="https://static.simonwillison.net/static/2026/present-mobile.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;顶部有一个幻灯片指示器，前进和后退按钮，一个漂亮的大“开始”按钮，以及调整字体大小的按钮。&lt;/p&gt;
&lt;p&gt;最复杂的功能是开始按钮旁边的那个细长条。那是一个支持触摸的滚动条——你可以在上面上下滑动手指，在屏幕上上下滚动当前可见的网页。&lt;/p&gt;
&lt;p&gt;它&lt;em&gt;非常&lt;/em&gt;笨拙，但足以解决页面加载时最有趣的内容在首屏下方的问题。&lt;/p&gt;
&lt;h4 id="learning-from-the-code"&gt;从代码中学习&lt;/h4&gt;
&lt;p&gt;当我意识到我应该看看代码时，我已经&lt;a href="https://github.com/simonw/present"&gt;将代码推送到GitHub&lt;/a&gt;了（附带一个大的免责声明：“这个应用是凭感觉编码的……除了它在我机器上能运行之外，我不做任何保证！”）。&lt;/p&gt;
&lt;p&gt;我利用这个机会记录了我最近一直在使用的一个模式：要求模型对整个代码库进行线性讲解。以下是我正在进行的&lt;a href="https://simonwillison.net/2026/Feb/23/agentic-engineering-patterns/"&gt;Agentic Engineering Patterns指南&lt;/a&gt;中产生的&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/linear-walkthroughs/"&gt;线性讲解&lt;/a&gt;模式，包括我使用的提示。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/simonw/present/blob/main/walkthrough.md"&gt;生成的讲解文档&lt;/a&gt;确实很有用。事实证明，Claude Code决定&lt;a href="https://github.com/simonw/present/blob/main/walkthrough.md#request-routing"&gt;在不使用库的情况下使用套接字编程&lt;/a&gt;来实现远程控制功能的网页服务器！以下是它用于路由的最小HTTP解析器：&lt;/p&gt;&lt;div class="highlight highlight-source-swift"&gt;&lt;pre&gt;    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-en"&gt;func&lt;/span&gt; route&lt;span class="pl-kos"&gt;(&lt;/span&gt;_ raw&lt;span class="pl-kos"&gt;:&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt; &lt;span class="pl-c1"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-kos"&gt;{&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-s1"&gt;firstLine&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; raw&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;components&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;separatedBy&lt;span class="pl-kos"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;\r&lt;/span&gt;&lt;span class="pl-s"&gt;\n&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;&lt;span class="pl-kos"&gt;.&lt;/span&gt;first &lt;span class="pl-c1"&gt;??&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-s1"&gt;parts&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; firstLine&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;split&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;separator&lt;span class="pl-kos"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt; &lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-s1"&gt;path&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; parts&lt;span class="pl-kos"&gt;.&lt;/span&gt;count &lt;span class="pl-c1"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-c1"&gt;?&lt;/span&gt; &lt;span class="pl-en"&gt;String&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-en"&gt;parts&lt;/span&gt;&lt;span class="pl-kos"&gt;[&lt;/span&gt;&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-kos"&gt;]&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;/&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;

        &lt;span class="pl-k"&gt;switch&lt;/span&gt; path &lt;span class="pl-kos"&gt;{&lt;/span&gt;
        &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;/next&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;:&lt;/span&gt;
            state&lt;span class="pl-c1"&gt;&lt;span class="pl-c1"&gt;?&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;goToNext&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
            &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-en"&gt;jsonResponse&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;ok&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
        &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;/prev&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;:&lt;/span&gt;
            state&lt;span class="pl-c1"&gt;&lt;span class="pl-c1"&gt;?&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;goToPrevious&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
            &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-en"&gt;jsonResponse&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;ok&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
&lt;span class="pl-kos"&gt;&lt;/span&gt;&lt;span class="pl-kos"&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用GET请求进行状态变更会带来一些有趣的CSRF漏洞。不过对于这个特定应用，我并不太在意。&lt;/p&gt;
&lt;h4 id="expanding-our-horizons"&gt;拓展视野&lt;/h4&gt;
&lt;p&gt;如今这类氛围编程故事比比皆是。我认为这个故事值得分享有几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift这门我不熟悉的语言，在这里绝对是正确选择。我想要一个全屏应用，既能嵌入网页内容，又能通过网络控制。Swift完全满足了我的需求。&lt;/li&gt;
&lt;li&gt;当我最终查看代码时，它简洁明了，完全符合我的需求，没有一丝多余。&lt;/li&gt;
&lt;li&gt;这真正解决了我的实际问题。我一直想要一种将演示文稿作为页面序列呈现的好方法，现在终于实现了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这并不意味着原生Mac开发者已经过时。我仍然运用了大量自己积累的技术知识（以及我已经安装了Xcode等工具的事实）才取得这个成果，而专业人士本可以在相同时间内构建出更优秀的解决方案。&lt;/p&gt;
&lt;p&gt;这很好地说明了我们这些拥有软件工程经验的人，如何能够朝着有趣的方向拓展视野。我不再害怕Swift了！下次我需要开发小型个人macOS应用时，我知道用现有工具集完全可以实现。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/macos"&gt;macos&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;vibe-coding&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/swift"&gt;swift&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 16:46:19 +0000</pubDate></item><item><title>引用凯兰·埃利奥特-麦克雷</title><link>https://simonwillison.net/2026/Feb/25/kellan-elliott-mccrea/#atom-everything</link><description>&lt;blockquote cite="https://laughingmeme.org/2026/02/09/code-has-always-been-the-easy-part.html"&gt;&lt;p&gt;对于在过去几十年里因为这是一份好工作，或者因为他们喜欢编程而进入科技行业的人来说，此刻感到一种真切的失落感也是合理的。然而，这种失落感对于像我这样年纪、因为沉迷于科技赋予我们的能动感而进入这个行业的人来说，在情感上可能难以理解。作为一种技术，网络在客观上曾经是糟糕的，但也确实令人惊叹，而且没有人是因为觉得用Perl编程在美学上令人愉悦而投身其中的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://laughingmeme.org/2026/02/09/code-has-always-been-the-easy-part.html"&gt;Kellan Elliott-McCrea&lt;/a&gt;, 代码&lt;em&gt;一直&lt;/em&gt;都是容易的部分&lt;/p&gt;

    &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/perl"&gt;perl&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/kellan-elliott-mccrea"&gt;kellan-elliott-mccrea&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/deep-blue"&gt;deep-blue&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 03:30:32 +0000</pubDate></item><item><title>线性演练</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/linear-walkthroughs/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;有时，让一个编码智能体为你提供一份代码库的结构化讲解会很有用。&lt;/p&gt;
&lt;p&gt;也许是你需要快速上手的现有代码，也许是你自己写但已忘记细节的代码，又或者是你凭感觉一气呵成写出来的代码，现在需要理解它到底是如何工作的。&lt;/p&gt;
&lt;p&gt;配备合适智能体工具的前沿模型，能够构建详细的讲解，帮助你理解代码的工作原理。&lt;/p&gt;
&lt;h2&gt;使用 Showboat 和 Present 的示例&lt;/h2&gt;
&lt;p&gt;我最近&lt;a href="https://simonwillison.net/2026/Feb/25/present/"&gt;在 Mac 上使用 Claude Code 和 Opus 4.6 凭感觉编写了一个 SwiftUI 幻灯片演示应用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我当时在谈论 2025 年 11 月到 2026 年 2 月间前沿模型的进展，并且我喜欢在我的演讲中至少包含一个噱头（一个&lt;a href="https://simonwillison.net/2019/Dec/10/better-presentations/"&gt;STAR 时刻&lt;/a&gt;——Something They'll Always Remember，即“他们会永远记住的东西”）。这次我决定，噱头就是在演讲结束时揭示，幻灯片机制本身就是一个展示凭感觉编码能做到什么的例子。&lt;/p&gt;
&lt;p&gt;我把代码&lt;a href="https://github.com/simonw/present"&gt;发布到 GitHub&lt;/a&gt;，然后意识到我对它的实际工作原理一无所知——我完全是靠提示词把它变出来的（&lt;a href="https://gisthost.github.io/?bfbc338977ceb71e298e4d4d5ac7d63c"&gt;部分对话记录在此&lt;/a&gt;），根本没注意它写了什么代码。&lt;/p&gt;
&lt;p&gt;于是，我启动了一个新的 Claude Code for Web 实例，指向我的代码仓库，并给出提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读源代码，然后规划一个线性的代码讲解，详细解释所有内容是如何工作的&lt;/p&gt;
&lt;p&gt;然后运行“uvx showboat –help”来了解 showboat——使用 showboat 在仓库中创建一个 walkthrough.md 文件，并在其中构建讲解，使用 showboat note 添加注释，使用 showboat exec 加上 sed 或 grep 或 cat 或任何你需要的工具来包含你正在谈论的代码片段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/simonw/showboat"&gt;Showboat&lt;/a&gt; 是我构建的一个工具，用于帮助编码智能体编写展示其工作的文档。你可以查看&lt;a href="https://github.com/simonw/showboat/blob/main/help.txt"&gt;showboat --help 的输出内容&lt;/a&gt;，它的设计目的是为模型提供使用该工具所需的一切信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;showboat note&lt;/code&gt; 命令向文档添加 Markdown 内容。&lt;code&gt;showboat exec&lt;/code&gt; 命令接受一个 shell 命令，执行它，然后将命令及其输出都添加到文档中。&lt;/p&gt;
&lt;p&gt;通过告诉它使用“sed 或 grep 或 cat 或任何你需要的工具来包含你正在谈论的代码片段”，我确保了 Claude Code 不会手动将代码片段复制到文档中，因为那样可能会引入幻觉或错误的风险。&lt;/p&gt;&lt;p&gt;这个方法效果极佳。这是&lt;a href="https://github.com/simonw/present/blob/main/walkthrough.md"&gt;Claude Code 与 Showboat 共同创建的文档&lt;/a&gt;，它详细讲解了所有六个 &lt;code&gt;.swift&lt;/code&gt; 文件，并对代码的工作原理提供了清晰且可操作的说明。&lt;/p&gt;
&lt;p&gt;仅仅通过阅读这份文档，我就对 SwiftUI 应用的结构有了深入的了解，并吸收了一些关于 Swift 语言本身的扎实细节。&lt;/p&gt;
&lt;p&gt;如果你担心大型语言模型可能会降低你学习新技能的速度，我强烈建议你采用类似这样的模式。即使是一个大约 40 分钟凭感觉编码的玩具项目，也能成为探索新生态系统并学到一些有趣新技巧的机会。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;vibe-coding&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/swift"&gt;swift&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/showboat"&gt;showboat&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 01:07:10 +0000</pubDate></item><item><title>go-size-analyzer</title><link>https://simonwillison.net/2026/Feb/24/go-size-analyzer/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/Zxilly/go-size-analyzer"&gt;go-size-analyzer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Go 生态系统的工具链&lt;em&gt;确实&lt;/em&gt;非常出色。我刚了解到这个工具，它可以通过美观的树状图来可视化分析 Go 二进制文件的大小及其捆绑的依赖项。&lt;/p&gt;
&lt;p&gt;你可以在本地安装并运行此工具，但它也编译成了 WebAssembly 版本，并托管在 &lt;a href="https://gsa.zxilly.dev/"&gt;gsa.zxilly.dev&lt;/a&gt;——这意味着你可以在浏览器中直接打开已编译的 Go 二进制文件并进行分析。&lt;/p&gt;
&lt;p&gt;我用我编译的一个 8.1MB 的 macOS 版 Go 工具 &lt;a href="https://github.com/simonw/showboat"&gt;Showboat&lt;/a&gt; 试了一下，得到了这个结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="一个名为'showboat'的Go二进制文件的树状图可视化，按四大类别显示大小细分：'未知部分大小'（包含__rodata __TEXT, __rodata __DATA_CONST, __data __DATA，以及包含__zdebug_line __DWARF, __zdebug_loc __DWARF, __zdebug_info __DWARF的调试部分大小），'标准库包大小'（显示标准库包如runtime, net, crypto, reflect, math, os, fmt, strings, syscall, context，以及许多子包如crypto/tls, crypto/x509, net/http，在更深层次可见单个.go文件），'主包大小'（显示main, showboat, cmd），以及'生成包大小'（显示&amp;lt;autogenerated&amp;gt;）。鼠标悬停在__zdebug_line __DWARF上显示提示信息：部分：__zdebug_line __DWARF，大小：404.44 KB，文件大小：404.44 KB，已知大小：0 B，未知大小：404.44 KB，偏移量：0x52814a – 0x58d310，地址：0x1005c014a – 0x1005c5310，内存：false，调试：true。树状图中，主包/生成包使用绿色，未知部分使用蓝灰色，标准库包使用紫色/粉色系。" src="https://static.simonwillison.net/static/2026/showboat-treemap.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;来自 &lt;a href="https://www.datadoghq.com/blog/engineering/agent-go-binaries/"&gt;Datadog：我们如何将Agent Go二进制文件的大小减少了高达77%&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/go"&gt;go&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/webassembly"&gt;webassembly&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/showboat"&gt;showboat&lt;/a&gt;&lt;/p&gt;</description><pubDate>Tue, 24 Feb 2026 16:10:06 +0000</pubDate></item><item><title>首先运行测试</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/first-run-the-tests/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
    &lt;p&gt;在使用编码智能体时，自动化测试不再是可选项。&lt;/p&gt;
&lt;p&gt;那些不写测试的老借口——在代码库快速演进时，不断重写测试既耗时又昂贵——当智能体能在几分钟内搞定它们时，就不再成立了。&lt;/p&gt;
&lt;p&gt;测试对于确保AI生成的代码能如其声称的那样工作也&lt;em&gt;至关重要&lt;/em&gt;。如果代码从未被执行过，那么它部署到生产环境后能正常工作纯属运气。&lt;/p&gt;
&lt;p&gt;测试也是帮助智能体快速熟悉现有代码库的绝佳工具。观察一下当你向Claude Code或类似工具询问现有功能时会发生什么——它们很可能会找到并阅读相关的测试。&lt;/p&gt;
&lt;p&gt;智能体本身就已经倾向于测试，但现有测试套件的存在几乎肯定会推动智能体对其所做的更改进行测试。&lt;/p&gt;
&lt;p&gt;每当我针对现有项目启动一个新的智能体会话时，我都会先给出类似以下的提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先运行测试
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于我的Python项目，我已经&lt;a href="https://til.simonwillison.net/uv/dependency-groups"&gt;设置好了pyproject.toml&lt;/a&gt;，这样我就可以改用这个提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;运行 "uv run pytest"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些四个字的提示有几个目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它告诉智能体存在一个测试套件，并迫使其弄清楚如何运行测试。这使得智能体几乎肯定会在未来运行测试，以确保没有破坏任何东西。&lt;/li&gt;
&lt;li&gt;大多数测试框架会给智能体一个关于测试数量的大致指示。这可以作为项目规模和复杂性的一个参考，也暗示了如果智能体想了解更多，应该搜索测试本身。&lt;/li&gt;
&lt;li&gt;它让智能体进入测试思维模式。运行了测试之后，它很自然地会在之后用自己的测试来扩展它们。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似于&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/red-green-tdd/"&gt;"使用红/绿TDD"&lt;/a&gt;，"首先运行测试"提供了一个四个字的提示，它包含了大量已经内置于模型中的软件工程规范。&lt;/p&gt;
    
        &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/tdd"&gt;tdd&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/testing"&gt;测试&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai辅助编程&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;编码智能体&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;智能体工程&lt;/a&gt;&lt;/p&gt;</description><pubDate>Tue, 24 Feb 2026 12:30:05 +0000</pubDate></item><item><title>Ladybird 在 AI 的帮助下采用 Rust</title><link>https://simonwillison.net/2026/Feb/23/ladybird-adopts-rust/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://ladybird.org/posts/adopting-rust/"&gt;Ladybird 在 AI 协助下采用 Rust&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来自 Andreas Kling 的一个非常有趣的案例研究，探讨了在涉及关键代码的雄心勃勃的编码项目中，如何高级且复杂地使用编码智能体。在期待 Swift 在苹果生态系统之外的平台支持能够成熟几年后，他们转而选择了 Rust 作为其内存安全语言，并从一个关键库的 AI 辅助移植开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们的第一个目标是 &lt;strong&gt;LibJS&lt;/strong&gt;，即 Ladybird 的 JavaScript 引擎。其词法分析器、解析器、抽象语法树和字节码生成器相对独立，并且通过 &lt;a href="https://github.com/tc39/test262"&gt;test262&lt;/a&gt; 拥有广泛的测试覆盖，这使其成为一个自然的起点。&lt;/p&gt;
&lt;p&gt;我使用了 &lt;a href="https://docs.anthropic.com/en/docs/claude-code"&gt;Claude Code&lt;/a&gt; 和 &lt;a href="https://openai.com/codex/"&gt;Codex&lt;/a&gt; 进行翻译。这是由人引导的，而非自主的代码生成。我决定移植什么、按什么顺序移植，以及 Rust 代码应该是什么样子。这是数百个小型提示，引导智能体处理需要完成的工作。[...]&lt;/p&gt;
&lt;p&gt;从一开始的要求就是两个流水线输出的字节级完全一致。结果产生了大约 25,000 行 Rust 代码，整个移植过程大约花费了两周时间。同样的工作如果手动完成，将花费我数月时间。我们已经验证，Rust 解析器生成的每个抽象语法树都与 C++ 版本相同，并且 Rust 编译器生成的所有字节码也与 C++ 编译器的输出完全相同。整体零回归。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拥有像 &lt;code&gt;test262&lt;/code&gt; 这样高质量的现有一致性测试套件，对于这种规模的项目来说是一个巨大的解锁器，而能够将输出与现有可信实现进行比较，使得智能体工程更加稳妥可靠。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Via &lt;a href="https://news.ycombinator.com/item?id=47120899"&gt;Hacker News&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/browsers"&gt;browsers&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/javascript"&gt;javascript&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/rust"&gt;rust&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/andreas-kling"&gt;andreas-kling&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ladybird"&gt;ladybird&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/swift"&gt;swift&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/conformance-suites"&gt;conformance-suites&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Mon, 23 Feb 2026 18:52:53 +0000</pubDate></item><item><title>撰写关于智能体工程模式</title><link>https://simonwillison.net/2026/Feb/23/agentic-engineering-patterns/#atom-everything</link><description>&lt;p&gt;我启动了一个新项目，旨在收集和记录&lt;strong&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt;&lt;/strong&gt;——这是一些编码实践和模式，旨在帮助我们在这个正在进入的编码智能体开发新时代中获得最佳成果。&lt;/p&gt;
&lt;p&gt;我使用&lt;strong&gt;智能体工程&lt;/strong&gt;来指代使用编码智能体构建软件——例如Claude Code和OpenAI Codex这类工具，其定义性特征是它们既能生成也能&lt;em&gt;执行&lt;/em&gt;代码，这使得它们能够测试代码并在无需人类监督者逐步指导的情况下独立进行迭代。&lt;/p&gt;
&lt;p&gt;我认为&lt;strong&gt;氛围编码&lt;/strong&gt;使用的是其&lt;a href="https://simonwillison.net/2025/Mar/19/vibe-coding/"&gt;原始定义&lt;/a&gt;，即你完全不在意代码本身，如今这通常与非程序员使用LLM来编写代码相关联。&lt;/p&gt;
&lt;p&gt;智能体工程则代表了天平的另一端：专业的软件工程师利用编码智能体来增强他们现有的专业知识，从而改进和加速他们的工作。&lt;/p&gt;
&lt;p&gt;关于这个新领域，有太多东西需要学习和探索！我已经&lt;a href="https://simonwillison.net/tags/ai-assisted-programming/"&gt;在我的ai-assisted-programming标签下&lt;/a&gt;发表了很多内容（345篇文章且仍在增加），但相对而言比较零散。我的新目标是创建一个能在一个地方帮助回答“我如何从这些东西中获得好结果”这个问题的内容。&lt;/p&gt;
&lt;p&gt;我将在我的博客上以一系列章节式模式的形式来发展和壮大这个项目，其格式灵感大致来源于1994年流行的&lt;a href="https://en.wikipedia.org/wiki/Design_Patterns"&gt;《设计模式：可复用面向对象软件的基础》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我今天发布了前两章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/code-is-cheap/"&gt;现在编写代码很廉价&lt;/a&gt;&lt;/strong&gt;讨论了智能体工程的核心挑战：产出初始可用代码的成本已降至几乎为零，这如何影响我们现有的关于个人和团队工作方式的直觉？&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/red-green-tdd/"&gt;红/绿测试驱动开发&lt;/a&gt;&lt;/strong&gt;描述了测试优先开发如何帮助智能体以最少的额外提示编写更简洁、更可靠的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我希望以每周1-2章的速度添加更多内容。我真的不知道什么时候会停止，要涵盖的内容太多了！&lt;/p&gt;
&lt;h4 id="written-by-me-not-by-an-llm"&gt;由我本人撰写，非LLM生成&lt;/h4&gt;&lt;p&gt;我有一条坚定的个人原则：不以自己的名义发布AI生成的文章。这一原则同样适用于《智能体工程模式》。我会使用大语言模型进行校对、充实示例代码以及处理各类辅助任务，但您在这里读到的文字都将出自我本人之手。&lt;/p&gt;
&lt;h4 id="chapters-and-guides"&gt;章节与指南&lt;/h4&gt;
&lt;p&gt;《智能体工程模式》并不完全是一本书，但它具有类似书籍的形态。我将在我的网站上以一种我称之为“指南”的新内容形式发布它。指南是章节的集合，其中每个章节本质上是一篇博客文章，其发布日期不那么显眼，设计初衷是随时间推移而更新，而非在首次发布时便固定不变。&lt;/p&gt;
&lt;p&gt;指南和章节是我对在博客上发布“常青”内容这一挑战的回应。我一直在尝试寻找实现这一目标的方法。这种形式感觉可能会持续下去。&lt;/p&gt;
&lt;p&gt;如果您对实现细节感兴趣，可以在&lt;a href="https://github.com/simonw/simonwillisonblog/blob/b9cd41a0ac4a232b2a6c90ca3fff9ae465263b02/blog/models.py#L262-L280"&gt;Guide&lt;/a&gt;、&lt;a href="https://github.com/simonw/simonwillisonblog/blob/b9cd41a0ac4a232b2a6c90ca3fff9ae465263b02/blog/models.py#L349-L405"&gt;Chapter&lt;/a&gt;和&lt;a href="https://github.com/simonw/simonwillisonblog/blob/b9cd41a0ac4a232b2a6c90ca3fff9ae465263b02/blog/models.py#L408-L423"&gt;ChapterChange&lt;/a&gt;模型以及&lt;a href="https://github.com/simonw/simonwillisonblog/blob/b9cd41a0ac4a232b2a6c90ca3fff9ae465263b02/blog/views.py#L775-L923"&gt;相关的Django视图&lt;/a&gt;中找到代码，其中几乎全部是由Claude Opus 4.6通过我的iPhone访问Claude Code for web编写完成的。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/blogging"&gt;blogging&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/design-patterns"&gt;design-patterns&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/projects"&gt;projects&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/writing"&gt;writing&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;vibe-coding&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Mon, 23 Feb 2026 17:43:02 +0000</pubDate></item><item><title>如今写代码的成本很低</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/code-is-cheap/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;采用智能体工程实践的最大挑战，在于适应一个事实带来的后果：&lt;em&gt;现在写代码很便宜了&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;代码一直以来都很昂贵。产出几百行干净、经过测试的代码，对大多数软件开发者来说需要一整天甚至更长时间。我们许多工程习惯，无论是宏观还是微观层面，都是围绕这个核心约束建立起来的。&lt;/p&gt;
&lt;p&gt;在宏观层面，我们花费大量时间进行设计、评估和项目规划，以确保我们昂贵的编码时间能被尽可能高效地利用。产品功能想法的评估标准是它们能提供多少价值&lt;em&gt;以换取那些时间&lt;/em&gt;——一个功能需要数倍地赚回其开发成本才算值得！&lt;/p&gt;
&lt;p&gt;在微观层面，我们每天做出数百个决策，这些决策都基于可用时间和预期的权衡。如果重构那个函数能让它稍微更优雅，但会增加一个小时的编码时间，我该做吗？写文档呢？为这个边界情况写个测试值得吗？我能证明为这个功能构建一个调试界面是合理的吗？&lt;/p&gt;
&lt;p&gt;编码智能体极大地降低了向计算机输入代码的成本，这颠覆了我们现有的关于哪些权衡是合理的&lt;em&gt;大量&lt;/em&gt;个人和组织直觉。&lt;/p&gt;
&lt;p&gt;运行并行智能体的能力使这种评估变得更加困难，因为现在一个人类工程师可以同时在多个地方实现、重构、测试和编写代码文档。&lt;/p&gt;
&lt;h2 id="good-code"&gt;好代码仍然有成本&lt;/h2&gt;
&lt;p&gt;交付新代码的价格已经下降到几乎免费……但交付&lt;em&gt;好&lt;/em&gt;代码的成本仍然比那要高得多。&lt;/p&gt;
&lt;p&gt;我所说的“好代码”是指：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;代码能运行。它能实现预期功能，没有错误。&lt;/li&gt;
&lt;li&gt;我们&lt;em&gt;知道代码能运行&lt;/em&gt;。我们已经采取措施向自己和他人确认，代码符合其用途。&lt;/li&gt;
&lt;li&gt;它解决了正确的问题。&lt;/li&gt;
&lt;li&gt;它能优雅且可预测地处理错误情况：它不仅仅考虑顺利的情况。错误应提供足够的信息，以帮助未来的维护者理解问题所在。&lt;/li&gt;
&lt;li&gt;它简单且最小化——只做必要的事情，并且以人类和机器现在都能理解、未来都能维护的方式实现。&lt;/li&gt;
&lt;li&gt;它受到测试的保护。测试表明它现在能运行，并作为回归测试套件，避免它在未来悄无声息地失效。&lt;/li&gt;
&lt;li&gt;它在适当的层面上有文档记录，并且该文档反映了系统的当前状态——如果代码改变了现有行为，则需要更新现有文档以匹配。&lt;/li&gt;
&lt;li&gt;设计为未来的变更留有余地。保持&lt;a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it"&gt;YAGNI&lt;/a&gt;（你不会需要它）原则很重要——为预见可能永远不会发生的未来变化而增加复杂性的代码通常是糟糕的代码——但同样重要的是，不要编写让未来变更变得比应有难度大得多的代码。&lt;/li&gt;
&lt;li&gt;所有其他相关的“能力”——可访问性、可测试性、可靠性、安全性、可维护性、可观测性、可扩展性、可用性——这些适用于所开发特定类别软件的非功能性质量指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编码智能体工具可以帮助完成其中大部分工作，但驱动这些工具的开发者仍然承担着相当大的责任，以确保生成的代码是“好代码”，符合当前项目所需的那部分“好”的标准。&lt;/p&gt;
&lt;h2&gt;我们需要建立新习惯&lt;/h2&gt;
&lt;p&gt;挑战在于培养新的个人和组织习惯，以应对智能体工程所提供的便利和机遇。&lt;/p&gt;
&lt;p&gt;这些最佳实践仍在整个行业中探索。我自己也仍在摸索。&lt;/p&gt;
&lt;p&gt;目前我认为我们能做的最好的事情就是质疑自己的直觉：任何时候，当我们的本能说“别构建那个，不值得花时间”时，无论如何都发送一个提示，在一个异步智能体会话中进行，最坏的情况不过是十分钟后你检查发现它不值得消耗那些令牌。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Mon, 23 Feb 2026 16:20:42 +0000</pubDate></item><item><title>引用保罗·福特的话</title><link>https://simonwillison.net/2026/Feb/23/paul-ford/#atom-everything</link><description>&lt;blockquote cite="https://ftrain.com/leading-thoughts"&gt;&lt;p&gt;报纸请我解释氛围编程，我照做了，因为我认为那里即将发生大事，而我深陷其中，我担心普通人无法看到这一点，我希望他们能有所准备。但人们不能只是读点东西然后默默讨厌你；他们看不到你为他们提供了某种效用或警告；他们需要发出尖叫。你被分发给数百万人，并成为也许几十个人情绪的本地代理，他们意见不一并要求你的关注，而因为你是报纸上的人，你需要以牧师的微笑和深切的同理心来欢迎他们，如果你为自己辩护一句，他们会叫得更大声。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://ftrain.com/leading-thoughts"&gt;保罗·福特&lt;/a&gt;，谈为《纽约时报》撰写关于氛围编程的文章&lt;/p&gt;

    &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;氛围编程&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/new-york-times"&gt;纽约时报&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/paul-ford"&gt;保罗·福特&lt;/a&gt;&lt;/p&gt;</description><pubDate>Mon, 23 Feb 2026 16:00:32 +0000</pubDate></item></channel></rss>