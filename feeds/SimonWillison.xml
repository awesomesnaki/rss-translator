<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Willison's Weblog (中文)</title><link>http://simonwillison.net/</link><description/><language>zh-CN</language><lastBuildDate>Thu, 26 Feb 2026 04:28:55 +0000</lastBuildDate><item><title>谷歌API密钥本非秘密。但随后Gemini改变了规则。</title><link>https://simonwillison.net/2026/Feb/26/google-api-keys/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://trufflesecurity.com/blog/google-api-keys-werent-secrets-but-then-gemini-changed-the-rules"&gt;谷歌API密钥本非机密。但随后Gemini改变了规则。&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哎呀！原来Gemini和谷歌地图（以及其他服务）共享相同的API密钥……但谷歌地图API密钥设计为公开，因为它们直接嵌入在网页中。而Gemini API密钥可用于访问私人文件并进行计费API请求，因此绝对不应共享。&lt;/p&gt;
&lt;p&gt;如果你不了解这一点，很容易意外地为一个已存在于公开环境中的、原本公开的API密钥启用Gemini计费功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使其成为权限提升而非配置错误的，是事件发生的顺序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者创建一个API密钥并将其嵌入网站用于地图服务。（此时，该密钥是无害的。）&lt;/li&gt;
&lt;li&gt;在同一项目上启用了Gemini API。（现在，同一个密钥可以访问敏感的Gemini端点。）&lt;/li&gt;
&lt;li&gt;开发者从未收到密钥权限已在其不知情下发生改变的警告。（该密钥从公开标识符变成了秘密凭证）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Truffle Security在2025年11月的Common Crawl数据中发现了2,863个可以访问Gemini的API密钥，这是通过调用&lt;code&gt;/models&lt;/code&gt;列表端点验证的。其中包括几个属于谷歌自身的密钥，其中一个自2023年2月就已部署（根据互联网档案馆记录），因此早于它现在能够访问的Gemini API。&lt;/p&gt;
&lt;p&gt;谷歌正在努力撤销受影响的密钥，但检查一下你自己的密钥是否受此影响仍然是个好主意。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Via &lt;a href="https://news.ycombinator.com/item?id=47156925"&gt;Hacker News&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/api-keys"&gt;api-keys&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/google"&gt;google&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/security"&gt;security&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/gemini"&gt;gemini&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 26 Feb 2026 04:28:55 +0000</pubDate></item><item><title>引用本尼迪克特·埃文斯</title><link>https://simonwillison.net/2026/Feb/26/benedict-evans/#atom-everything</link><description>&lt;blockquote cite="https://www.ben-evans.com/benedictevans/2026/2/19/how-will-openai-compete-nkg2x"&gt;&lt;p&gt;如果人们最多每周只使用几次，并且在平常日子里想不出能用它来做什么，那它就没有改变他们的生活。OpenAI自己也承认这个问题，他们谈到模型的能力与人们实际使用之间存在“能力差距”，在我看来，这像是一种避免直接说你没有明确产品市场契合度的说法。&lt;/p&gt;
&lt;p&gt;因此，OpenAI的广告项目部分只是为了覆盖服务那90%或更多不付费用户的成本（并在广告商中抢占早期领先地位，以及学习这种模式如何运作），但从更战略性的角度看，它也是为了能够向这些用户提供最新、最强大（即最昂贵）的模型，希望这能加深他们的参与度。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://www.ben-evans.com/benedictevans/2026/2/19/how-will-openai-compete-nkg2x"&gt;Benedict Evans&lt;/a&gt;, OpenAI将如何竞争？&lt;/p&gt;

    &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/openai"&gt;openai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/chatgpt"&gt;chatgpt&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/benedict-evans"&gt;benedict-evans&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 26 Feb 2026 03:44:56 +0000</pubDate></item><item><title>tldraw 问题：将测试迁移至闭源仓库</title><link>https://simonwillison.net/2026/Feb/25/closed-tests/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/tldraw/tldraw/issues/8082"&gt;tldraw 议题：将测试移至闭源仓库&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过去几个月的情况已经非常清楚地表明，一套全面的测试套件足以让人从头开始、甚至可能用另一种语言，完整地重新实现任何开源库。&lt;/p&gt;
&lt;p&gt;这对于采用商业商业模式的开源项目来说，蕴含着令人担忧的后果。这里有一个回应的例子：出色的协作绘图库 tldraw（参见&lt;a href="https://simonwillison.net/2023/Nov/16/tldrawdraw-a-ui/"&gt;之前的报道&lt;/a&gt;）正在将其测试套件转移到一个私有仓库——这显然是对&lt;a href="https://blog.cloudflare.com/vinext/"&gt;Cloudflare 利用 AI 在一周内将 Next.js 移植到使用 Vite 的项目&lt;/a&gt;的回应。&lt;/p&gt;
&lt;p&gt;他们还提交了一个玩笑性质的议题，现已关闭：&lt;a href="https://github.com/tldraw/tldraw/issues/8092"&gt;将源代码翻译为繁体中文&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当前的 tldraw 代码库是英文的，这使得外部 AI 编码代理很容易复制。我们必须捍卫我们的知识产权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;值得注意的是，tldraw 在技术上并非开源——其&lt;a href="https://github.com/tldraw/tldraw?tab=License-1-ov-file#readme"&gt;自定义许可证&lt;/a&gt;规定，如果你想在“生产环境”中使用它，就需要商业许可。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Via &lt;a href="https://twitter.com/steveruizok/status/2026581824428753211"&gt;@steveruizok&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/open-source"&gt;open-source&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/cloudflare"&gt;cloudflare&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-ethics"&gt;ai-ethics&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 21:06:53 +0000</pubDate></item><item><title>Claude 代码远程控制</title><link>https://simonwillison.net/2026/Feb/25/claude-code-remote-control/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://code.claude.com/docs/en/remote-control"&gt;Claude Code 远程控制&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
昨天推出了新的 Claude Code 功能：你现在可以在电脑上运行一个“远程控制”会话，然后使用 Claude Code 的网页界面（网页版、iOS 版和原生桌面应用）向该会话发送指令。
&lt;p&gt;目前它还有点不稳定。我最初尝试时遇到了错误“您的账户未启用远程控制功能。请联系您的管理员。”（但我&lt;em&gt;就是&lt;/em&gt;我的管理员？）——然后我退出并重新登录 Claude Code 终端应用，它就开始工作了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;claude remote-control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你一次只能在一台机器上运行一个会话。如果你升级了 Claude iOS 应用，它会在 Code 标签页中显示为“远程控制会话（Mac）”。&lt;/p&gt;
&lt;p&gt;它似乎不支持 &lt;code&gt;--dangerously-skip-permissions&lt;/code&gt; 标志（我将其传递给 &lt;code&gt;claude remote-control&lt;/code&gt;，它没有拒绝该选项，但似乎也没有效果）——这意味着你必须批准它采取的每一个新操作。&lt;/p&gt;
&lt;p&gt;我还设法让它进入了一种状态，即我尝试的每个指令都会遇到 API 500 错误。&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img alt="“远程控制会话”（Mac:dev:817b）聊天界面的截图。用户消息：“在音乐应用中播放 Olivia Rodrigo 的 vampire”。响应显示一个 API 错误：500 {&amp;quot;type&amp;quot;:&amp;quot;error&amp;quot;,&amp;quot;error&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;api_error&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Internal server error&amp;quot;},&amp;quot;request_id&amp;quot;:&amp;quot;req_011CYVBLH9yt2ze2qehrX8nk&amp;quot;}，带有一个“重试”按钮。下方，助手回复：“我将使用 AppleScript 在音乐应用中播放 Olivia Rodrigo 的‘Vampire’。”一个 Bash 命令面板打开，显示一个 osascript 命令：osascript -e 'tell application &amp;quot;Music&amp;quot; activate set searchResults to search playlist &amp;quot;Library&amp;quot; for &amp;quot;vampire Olivia Rodrigo&amp;quot; if (count of searchResults) &amp;gt; 0 then play item 1 of searchResults else return &amp;quot;Song not found in library&amp;quot; end if end tell'" src="https://static.simonwillison.net/static/2026/vampire-remote.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;在机器上重启程序也会导致现有会话开始返回神秘的 API 错误，而不是清晰地说明会话已终止。&lt;/p&gt;
&lt;p&gt;我预计他们会相对较快地解决所有这些问题。有趣的是，可以将此与 OpenClaw 等解决方案进行对比，后者的主要卖点之一就是能够从手机控制你的个人设备。&lt;/p&gt;
&lt;p&gt;Claude Code 仍然没有记录在案的机制来按计划运行任务，而这是 Claw 类软件的另一个杀手级功能。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：我话说得太早了：今天Anthropic还宣布了&lt;a href="https://support.claude.com/en/articles/13854387-schedule-recurring-tasks-in-cowork"&gt;在Cowork中安排重复任务&lt;/a&gt;，这是Claude Code的&lt;a href="https://simonwillison.net/2026/Jan/12/claude-cowork/"&gt;通用智能体兄弟产品&lt;/a&gt;。这其中确实包含一个重要限制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计划任务仅在您的计算机处于唤醒状态且Claude桌面应用程序处于打开状态时运行。如果任务计划运行时您的计算机处于睡眠状态或应用程序已关闭，Cowork将跳过该任务，并在您的计算机唤醒或您再次打开桌面应用程序后自动运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我真心希望他们正在开发Cowork云端产品。

    &lt;p&gt;&lt;small&gt;&lt;/small&gt;通过&lt;a href="https://twitter.com/claudeai/status/2026418433911603668"&gt;@claudeai&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/applescript"&gt;applescript&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/anthropic"&gt;anthropic&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/claude"&gt;claude&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/claude-code"&gt;claude-code&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/openclaw"&gt;openclaw&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 17:33:24 +0000</pubDate></item><item><title>我通过氛围编码打造了我的梦想macOS演示应用</title><link>https://simonwillison.net/2026/Feb/25/present/#atom-everything</link><description>&lt;p&gt;这个周末，我在山景城的社会科学FOO营做了一场演讲。活动采用经典的“非会议”形式，任何人都可以上台演讲，无需提前提交提案。我抢到了一个时段，演讲题目是“2026年2月版LLM现状”，副标题是“自十一月以来，一切都变了！”。演讲前一晚，我即兴编写了一个定制的macOS应用程序来做演示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="FOO营公告板上的一张便利贴。上面写着：LLM现状，2026年2月版 - 自十一月以来，一切都变了！Simon Willison - 卡片上布满了新模型的名字：Qwen 3.5, DeepSeek 3.2, Sonnet 4.6, Kimi K2.5, GLM5, Opus 4.5/4.6, Gemini 3.1 Pro, Codex 5.3。旁边的卡片上写着：为什么社会科学家认为他们需要遗传学？Bill January（并不全是因为AI）" src="https://static.simonwillison.net/static/2026/state-of-llms.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;关于过去十二个月LLM的发展，我曾在&lt;a href="https://simonwillison.net/2023/Dec/31/ai-in-2023/"&gt;2023年12月&lt;/a&gt;、&lt;a href="https://simonwillison.net/2024/Dec/31/llms-in-2024/"&gt;2024年12月&lt;/a&gt;和&lt;a href="https://simonwillison.net/2025/Dec/31/the-year-in-llms/"&gt;2025年12月&lt;/a&gt;写过文章。我还在2025年6月的AI工程师世界博览会上做了题为&lt;a href="https://simonwillison.net/2025/Jun/6/six-months-in-llms/"&gt;《过去六个月的LLM，由骑自行车的鹈鹕图解》&lt;/a&gt;的演讲。这是我第一次将涵盖的时间缩短到仅仅三个月，这巧妙地说明了这个领域的发展速度有多快，考虑到&lt;a href="https://simonwillison.net/2026/Jan/4/inflection/"&gt;2025年11月的拐点&lt;/a&gt;，这样做感觉很合适。&lt;/p&gt;
&lt;p&gt;（为了进一步说明这种加速，我穿着Gemini 3的毛衣去演讲，这件毛衣是几周前别人给我的，现在已经过时了，&lt;a href="https://simonwillison.net/2026/Feb/19/gemini-31-pro/"&gt;多亏了Gemini 3.1&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;基于我在&lt;a href="https://simonwillison.net/2019/Dec/10/better-presentations/"&gt;斯坦福学到的&lt;/a&gt;STAR时刻原则——包含一些他们总会记住的东西，以帮助你的演讲脱颖而出——我总是喜欢在我的任何演讲中至少安排一个“噱头”。&lt;/p&gt;
&lt;p&gt;这次演讲我准备了两个噱头。我围绕编码智能体辅助分析鸮鹦鹉繁殖季节的数据来构建演讲的第一部分（这意味着我可以&lt;a href="https://simonwillison.net/2026/Feb/8/kakapo-mug/"&gt;炫耀我的马克杯&lt;/a&gt;），然后快速浏览了一些骑自行车的新鹈鹕图片，最后揭晓整个演示文稿都是使用一个全新的macOS应用程序呈现的，而这个应用是我在演讲前一晚花了大约45分钟即兴编码完成的。&lt;/p&gt;
&lt;h4 id="present-app"&gt;Present.app&lt;/h4&gt;
&lt;p&gt;这个应用叫做&lt;strong&gt;Present&lt;/strong&gt;——字面意思就是我想到的第一个名字。它是用Swift和SwiftUI构建的，大小为355KB，或者&lt;a href="https://github.com/simonw/present/releases/tag/0.1a0"&gt;压缩后76KB&lt;/a&gt;。Swift应用真是小巧！&lt;/p&gt;&lt;p&gt;虽然构建过程可能很快，但这一整套功能是我多年来一直梦寐以求的。&lt;/p&gt;
&lt;p&gt;我通常使用 Keynote 来做演示，但有时我喜欢通过一系列网页来展示，以变换方式。我的做法是在浏览器窗口中为每个页面打开一个标签页，然后在讲解时依次点击这些标签页。&lt;/p&gt;
&lt;p&gt;这方法效果很好，但有一个非常可怕的缺点：如果浏览器崩溃，我就失去了整个演示文稿！&lt;/p&gt;
&lt;p&gt;我总是把网址保存在一个笔记文件里，这样在需要时可以点击它并手动重新打开所有页面，但在演讲中途处理这种事可不是我想要的。&lt;/p&gt;
&lt;p&gt;这是我的初始提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构建一个用于演示的 SwiftUI 应用，其中每一张幻灯片都是一个 URL。应用启动时是一个窗口，右侧是网页视图，左侧是用于添加、删除和重新排序 URL 序列的界面。然后点击菜单中的“播放”，应用会进入全屏模式，左右方向键可以在 URL 之间切换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这产生了一个计划。你可以在这里查看实现该计划的对话记录。&lt;/p&gt;
&lt;p&gt;在 Present 应用中，一个演讲就是一个有序的 URL 序列，侧边栏界面用于添加、删除和重新排序这些 URL。这就是全部编辑体验。&lt;/p&gt;
&lt;p&gt;&lt;img alt='一个名为"Present"的macOS应用窗口截图，显示谷歌图片搜索"kakapo"的结果。网页视图显示了一个谷歌图片搜索页面，包含带有标题的鸮鹦鹉缩略图。左侧边栏显示了一个带编号的URL列表，大部分来自simonwillison.net和static.simonwillison.net，其中第4项（https://www.google.com/search?...）以蓝色高亮显示。' src="https://static.simonwillison.net/static/2026/present.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;当你选择菜单中的“播放”选项（或按下 Cmd+Shift+P）时，应用会切换到全屏模式。左右方向键可以前后导航，如果需要，你还可以增大或减小字体大小，或者滚动页面。完成后按 Escape 键。&lt;/p&gt;
&lt;p&gt;关键的是，Present 会在你进行任何更改时自动保存你的 URL。如果应用崩溃，你可以重新启动它并恢复你的演示状态。&lt;/p&gt;
&lt;p&gt;你还可以将演示文稿保存为 .txt 文件（实际上就是一个以换行符分隔的 URL 序列），并在以后重新加载。&lt;/p&gt;
&lt;h4 id="remote-controlled-via-my-phone"&gt;通过手机远程控制&lt;/h4&gt;
&lt;p&gt;让初始应用运行起来花费的时间如此之少，以至于我决定追求更宏大的目标。&lt;/p&gt;
&lt;p&gt;为演示配备一个遥控器会很酷……&lt;/p&gt;
&lt;p&gt;所以我提示道：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;添加一个监听在0.0.0.0:9123的网页服务器——该服务器提供一个适配移动设备的单页面，页面左右两侧设有醒目的按钮——点击这些按钮可以左右切换幻灯片——还有一个按钮用于根据当前模式启动或停止演示模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的笔记本电脑和手机上都安装了&lt;a href="https://tailscale.com/"&gt;Tailscale&lt;/a&gt;，这意味着我不必担心Wi-Fi网络会阻止两台设备之间的访问。我的手机可以直接从世界任何地方访问&lt;code&gt;http://100.122.231.116:9123/&lt;/code&gt;，并控制在我笔记本电脑上运行的演示文稿。&lt;/p&gt;
&lt;p&gt;经过几次迭代提示后，最终界面如下所示：&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img alt="手机网页浏览器应用，带有大按钮，顶部显示Slide 4/31，Prev、Next和Start按钮，一个带有上下滚动图标和文字大小加减按钮的细长条，底部显示当前幻灯片URL。" src="https://static.simonwillison.net/static/2026/present-mobile.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;顶部有一个幻灯片指示器，前进和后退按钮，一个漂亮的大“开始”按钮，以及调整字体大小的按钮。&lt;/p&gt;
&lt;p&gt;最复杂的功能是开始按钮旁边的那个细长条。那是一个支持触摸的滚动条——你可以在上面上下滑动手指，在屏幕上上下滚动当前可见的网页。&lt;/p&gt;
&lt;p&gt;它&lt;em&gt;非常&lt;/em&gt;笨拙，但足以解决页面加载时最有趣的内容在首屏下方的问题。&lt;/p&gt;
&lt;h4 id="learning-from-the-code"&gt;从代码中学习&lt;/h4&gt;
&lt;p&gt;当我意识到我应该看看代码时，我已经&lt;a href="https://github.com/simonw/present"&gt;将代码推送到GitHub&lt;/a&gt;了（附带一个大的免责声明：“这个应用是凭感觉编码的……除了它在我机器上能运行之外，我不做任何保证！”）。&lt;/p&gt;
&lt;p&gt;我利用这个机会记录了我最近一直在使用的一个模式：要求模型对整个代码库进行线性讲解。以下是我正在进行的&lt;a href="https://simonwillison.net/2026/Feb/23/agentic-engineering-patterns/"&gt;Agentic Engineering Patterns指南&lt;/a&gt;中产生的&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/linear-walkthroughs/"&gt;线性讲解&lt;/a&gt;模式，包括我使用的提示。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/simonw/present/blob/main/walkthrough.md"&gt;生成的讲解文档&lt;/a&gt;确实很有用。事实证明，Claude Code决定&lt;a href="https://github.com/simonw/present/blob/main/walkthrough.md#request-routing"&gt;在不使用库的情况下使用套接字编程&lt;/a&gt;来实现远程控制功能的网页服务器！以下是它用于路由的最小HTTP解析器：&lt;/p&gt;&lt;div class="highlight highlight-source-swift"&gt;&lt;pre&gt;    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-en"&gt;func&lt;/span&gt; route&lt;span class="pl-kos"&gt;(&lt;/span&gt;_ raw&lt;span class="pl-kos"&gt;:&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt; &lt;span class="pl-c1"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-kos"&gt;{&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-s1"&gt;firstLine&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; raw&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;components&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;separatedBy&lt;span class="pl-kos"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;\r&lt;/span&gt;&lt;span class="pl-s"&gt;\n&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;&lt;span class="pl-kos"&gt;.&lt;/span&gt;first &lt;span class="pl-c1"&gt;??&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-s1"&gt;parts&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; firstLine&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;split&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;separator&lt;span class="pl-kos"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt; &lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-s1"&gt;path&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; parts&lt;span class="pl-kos"&gt;.&lt;/span&gt;count &lt;span class="pl-c1"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-c1"&gt;?&lt;/span&gt; &lt;span class="pl-en"&gt;String&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-en"&gt;parts&lt;/span&gt;&lt;span class="pl-kos"&gt;[&lt;/span&gt;&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-kos"&gt;]&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;/&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;

        &lt;span class="pl-k"&gt;switch&lt;/span&gt; path &lt;span class="pl-kos"&gt;{&lt;/span&gt;
        &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;/next&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;:&lt;/span&gt;
            state&lt;span class="pl-c1"&gt;&lt;span class="pl-c1"&gt;?&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;goToNext&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
            &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-en"&gt;jsonResponse&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;ok&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
        &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;/prev&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;:&lt;/span&gt;
            state&lt;span class="pl-c1"&gt;&lt;span class="pl-c1"&gt;?&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-kos"&gt;.&lt;/span&gt;&lt;span class="pl-en"&gt;goToPrevious&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
            &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-en"&gt;jsonResponse&lt;/span&gt;&lt;span class="pl-kos"&gt;(&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-s"&gt;ok&lt;/span&gt;&lt;span class="pl-s"&gt;"&lt;/span&gt;&lt;span class="pl-kos"&gt;)&lt;/span&gt;
&lt;span class="pl-kos"&gt;&lt;/span&gt;&lt;span class="pl-kos"&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用GET请求进行状态变更会带来一些有趣的CSRF漏洞。不过对于这个特定应用，我并不太在意。&lt;/p&gt;
&lt;h4 id="expanding-our-horizons"&gt;拓展视野&lt;/h4&gt;
&lt;p&gt;如今这类氛围编程故事比比皆是。我认为这个故事值得分享有几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift这门我不熟悉的语言，在这里绝对是正确选择。我想要一个全屏应用，既能嵌入网页内容，又能通过网络控制。Swift完全满足了我的需求。&lt;/li&gt;
&lt;li&gt;当我最终查看代码时，它简洁明了，完全符合我的需求，没有一丝多余。&lt;/li&gt;
&lt;li&gt;这真正解决了我的实际问题。我一直想要一种将演示文稿作为页面序列呈现的好方法，现在终于实现了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这并不意味着原生Mac开发者已经过时。我仍然运用了大量自己积累的技术知识（以及我已经安装了Xcode等工具的事实）才取得这个成果，而专业人士本可以在相同时间内构建出更优秀的解决方案。&lt;/p&gt;
&lt;p&gt;这很好地说明了我们这些拥有软件工程经验的人，如何能够朝着有趣的方向拓展视野。我不再害怕Swift了！下次我需要开发小型个人macOS应用时，我知道用现有工具集完全可以实现。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/macos"&gt;macos&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;vibe-coding&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/swift"&gt;swift&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 16:46:19 +0000</pubDate></item><item><title>引用凯兰·埃利奥特-麦克雷</title><link>https://simonwillison.net/2026/Feb/25/kellan-elliott-mccrea/#atom-everything</link><description>&lt;blockquote cite="https://laughingmeme.org/2026/02/09/code-has-always-been-the-easy-part.html"&gt;&lt;p&gt;对于在过去几十年里因为这是一份好工作，或者因为他们喜欢编程而进入科技行业的人来说，此刻感到一种真切的失落感也是合理的。然而，这种失落感对于像我这样年纪、因为沉迷于科技赋予我们的能动感而进入这个行业的人来说，在情感上可能难以理解。作为一种技术，网络在客观上曾经是糟糕的，但也确实令人惊叹，而且没有人是因为觉得用Perl编程在美学上令人愉悦而投身其中的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://laughingmeme.org/2026/02/09/code-has-always-been-the-easy-part.html"&gt;Kellan Elliott-McCrea&lt;/a&gt;, 代码&lt;em&gt;一直&lt;/em&gt;都是容易的部分&lt;/p&gt;

    &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/perl"&gt;perl&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/kellan-elliott-mccrea"&gt;kellan-elliott-mccrea&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/deep-blue"&gt;deep-blue&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 03:30:32 +0000</pubDate></item><item><title>线性演练</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/linear-walkthroughs/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;有时，让一个编码智能体为你提供一份代码库的结构化讲解会很有用。&lt;/p&gt;
&lt;p&gt;也许是你需要快速上手的现有代码，也许是你自己写但已忘记细节的代码，又或者是你凭感觉一气呵成写出来的代码，现在需要理解它到底是如何工作的。&lt;/p&gt;
&lt;p&gt;配备合适智能体工具的前沿模型，能够构建详细的讲解，帮助你理解代码的工作原理。&lt;/p&gt;
&lt;h2&gt;使用 Showboat 和 Present 的示例&lt;/h2&gt;
&lt;p&gt;我最近&lt;a href="https://simonwillison.net/2026/Feb/25/present/"&gt;在 Mac 上使用 Claude Code 和 Opus 4.6 凭感觉编写了一个 SwiftUI 幻灯片演示应用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我当时在谈论 2025 年 11 月到 2026 年 2 月间前沿模型的进展，并且我喜欢在我的演讲中至少包含一个噱头（一个&lt;a href="https://simonwillison.net/2019/Dec/10/better-presentations/"&gt;STAR 时刻&lt;/a&gt;——Something They'll Always Remember，即“他们会永远记住的东西”）。这次我决定，噱头就是在演讲结束时揭示，幻灯片机制本身就是一个展示凭感觉编码能做到什么的例子。&lt;/p&gt;
&lt;p&gt;我把代码&lt;a href="https://github.com/simonw/present"&gt;发布到 GitHub&lt;/a&gt;，然后意识到我对它的实际工作原理一无所知——我完全是靠提示词把它变出来的（&lt;a href="https://gisthost.github.io/?bfbc338977ceb71e298e4d4d5ac7d63c"&gt;部分对话记录在此&lt;/a&gt;），根本没注意它写了什么代码。&lt;/p&gt;
&lt;p&gt;于是，我启动了一个新的 Claude Code for Web 实例，指向我的代码仓库，并给出提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读源代码，然后规划一个线性的代码讲解，详细解释所有内容是如何工作的&lt;/p&gt;
&lt;p&gt;然后运行“uvx showboat –help”来了解 showboat——使用 showboat 在仓库中创建一个 walkthrough.md 文件，并在其中构建讲解，使用 showboat note 添加注释，使用 showboat exec 加上 sed 或 grep 或 cat 或任何你需要的工具来包含你正在谈论的代码片段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/simonw/showboat"&gt;Showboat&lt;/a&gt; 是我构建的一个工具，用于帮助编码智能体编写展示其工作的文档。你可以查看&lt;a href="https://github.com/simonw/showboat/blob/main/help.txt"&gt;showboat --help 的输出内容&lt;/a&gt;，它的设计目的是为模型提供使用该工具所需的一切信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;showboat note&lt;/code&gt; 命令向文档添加 Markdown 内容。&lt;code&gt;showboat exec&lt;/code&gt; 命令接受一个 shell 命令，执行它，然后将命令及其输出都添加到文档中。&lt;/p&gt;
&lt;p&gt;通过告诉它使用“sed 或 grep 或 cat 或任何你需要的工具来包含你正在谈论的代码片段”，我确保了 Claude Code 不会手动将代码片段复制到文档中，因为那样可能会引入幻觉或错误的风险。&lt;/p&gt;&lt;p&gt;这个方法效果极佳。这是&lt;a href="https://github.com/simonw/present/blob/main/walkthrough.md"&gt;Claude Code 与 Showboat 共同创建的文档&lt;/a&gt;，它详细讲解了所有六个 &lt;code&gt;.swift&lt;/code&gt; 文件，并对代码的工作原理提供了清晰且可操作的说明。&lt;/p&gt;
&lt;p&gt;仅仅通过阅读这份文档，我就对 SwiftUI 应用的结构有了深入的了解，并吸收了一些关于 Swift 语言本身的扎实细节。&lt;/p&gt;
&lt;p&gt;如果你担心大型语言模型可能会降低你学习新技能的速度，我强烈建议你采用类似这样的模式。即使是一个大约 40 分钟凭感觉编码的玩具项目，也能成为探索新生态系统并学到一些有趣新技巧的机会。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;vibe-coding&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/swift"&gt;swift&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/showboat"&gt;showboat&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 25 Feb 2026 01:07:10 +0000</pubDate></item><item><title>go-size-analyzer</title><link>https://simonwillison.net/2026/Feb/24/go-size-analyzer/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/Zxilly/go-size-analyzer"&gt;go-size-analyzer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Go 生态系统的工具链&lt;em&gt;确实&lt;/em&gt;非常出色。我刚了解到这个工具，它可以通过美观的树状图来可视化分析 Go 二进制文件的大小及其捆绑的依赖项。&lt;/p&gt;
&lt;p&gt;你可以在本地安装并运行此工具，但它也编译成了 WebAssembly 版本，并托管在 &lt;a href="https://gsa.zxilly.dev/"&gt;gsa.zxilly.dev&lt;/a&gt;——这意味着你可以在浏览器中直接打开已编译的 Go 二进制文件并进行分析。&lt;/p&gt;
&lt;p&gt;我用我编译的一个 8.1MB 的 macOS 版 Go 工具 &lt;a href="https://github.com/simonw/showboat"&gt;Showboat&lt;/a&gt; 试了一下，得到了这个结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="一个名为'showboat'的Go二进制文件的树状图可视化，按四大类别显示大小细分：'未知部分大小'（包含__rodata __TEXT, __rodata __DATA_CONST, __data __DATA，以及包含__zdebug_line __DWARF, __zdebug_loc __DWARF, __zdebug_info __DWARF的调试部分大小），'标准库包大小'（显示标准库包如runtime, net, crypto, reflect, math, os, fmt, strings, syscall, context，以及许多子包如crypto/tls, crypto/x509, net/http，在更深层次可见单个.go文件），'主包大小'（显示main, showboat, cmd），以及'生成包大小'（显示&amp;lt;autogenerated&amp;gt;）。鼠标悬停在__zdebug_line __DWARF上显示提示信息：部分：__zdebug_line __DWARF，大小：404.44 KB，文件大小：404.44 KB，已知大小：0 B，未知大小：404.44 KB，偏移量：0x52814a – 0x58d310，地址：0x1005c014a – 0x1005c5310，内存：false，调试：true。树状图中，主包/生成包使用绿色，未知部分使用蓝灰色，标准库包使用紫色/粉色系。" src="https://static.simonwillison.net/static/2026/showboat-treemap.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;来自 &lt;a href="https://www.datadoghq.com/blog/engineering/agent-go-binaries/"&gt;Datadog：我们如何将Agent Go二进制文件的大小减少了高达77%&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/go"&gt;go&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/webassembly"&gt;webassembly&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/showboat"&gt;showboat&lt;/a&gt;&lt;/p&gt;</description><pubDate>Tue, 24 Feb 2026 16:10:06 +0000</pubDate></item><item><title>首先运行测试</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/first-run-the-tests/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
    &lt;p&gt;在使用编码智能体时，自动化测试不再是可选项。&lt;/p&gt;
&lt;p&gt;那些不写测试的老借口——在代码库快速演进时，不断重写测试既耗时又昂贵——当智能体能在几分钟内搞定它们时，就不再成立了。&lt;/p&gt;
&lt;p&gt;测试对于确保AI生成的代码能如其声称的那样工作也&lt;em&gt;至关重要&lt;/em&gt;。如果代码从未被执行过，那么它部署到生产环境后能正常工作纯属运气。&lt;/p&gt;
&lt;p&gt;测试也是帮助智能体快速熟悉现有代码库的绝佳工具。观察一下当你向Claude Code或类似工具询问现有功能时会发生什么——它们很可能会找到并阅读相关的测试。&lt;/p&gt;
&lt;p&gt;智能体本身就已经倾向于测试，但现有测试套件的存在几乎肯定会推动智能体对其所做的更改进行测试。&lt;/p&gt;
&lt;p&gt;每当我针对现有项目启动一个新的智能体会话时，我都会先给出类似以下的提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先运行测试
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于我的Python项目，我已经&lt;a href="https://til.simonwillison.net/uv/dependency-groups"&gt;设置好了pyproject.toml&lt;/a&gt;，这样我就可以改用这个提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;运行 "uv run pytest"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些四个字的提示有几个目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它告诉智能体存在一个测试套件，并迫使其弄清楚如何运行测试。这使得智能体几乎肯定会在未来运行测试，以确保没有破坏任何东西。&lt;/li&gt;
&lt;li&gt;大多数测试框架会给智能体一个关于测试数量的大致指示。这可以作为项目规模和复杂性的一个参考，也暗示了如果智能体想了解更多，应该搜索测试本身。&lt;/li&gt;
&lt;li&gt;它让智能体进入测试思维模式。运行了测试之后，它很自然地会在之后用自己的测试来扩展它们。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似于&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/red-green-tdd/"&gt;"使用红/绿TDD"&lt;/a&gt;，"首先运行测试"提供了一个四个字的提示，它包含了大量已经内置于模型中的软件工程规范。&lt;/p&gt;
    
        &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/tdd"&gt;tdd&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/testing"&gt;测试&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai辅助编程&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;编码智能体&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;智能体工程&lt;/a&gt;&lt;/p&gt;</description><pubDate>Tue, 24 Feb 2026 12:30:05 +0000</pubDate></item><item><title>Ladybird 在 AI 的帮助下采用 Rust</title><link>https://simonwillison.net/2026/Feb/23/ladybird-adopts-rust/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://ladybird.org/posts/adopting-rust/"&gt;Ladybird 在 AI 协助下采用 Rust&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来自 Andreas Kling 的一个非常有趣的案例研究，探讨了在涉及关键代码的雄心勃勃的编码项目中，如何高级且复杂地使用编码智能体。在期待 Swift 在苹果生态系统之外的平台支持能够成熟几年后，他们转而选择了 Rust 作为其内存安全语言，并从一个关键库的 AI 辅助移植开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们的第一个目标是 &lt;strong&gt;LibJS&lt;/strong&gt;，即 Ladybird 的 JavaScript 引擎。其词法分析器、解析器、抽象语法树和字节码生成器相对独立，并且通过 &lt;a href="https://github.com/tc39/test262"&gt;test262&lt;/a&gt; 拥有广泛的测试覆盖，这使其成为一个自然的起点。&lt;/p&gt;
&lt;p&gt;我使用了 &lt;a href="https://docs.anthropic.com/en/docs/claude-code"&gt;Claude Code&lt;/a&gt; 和 &lt;a href="https://openai.com/codex/"&gt;Codex&lt;/a&gt; 进行翻译。这是由人引导的，而非自主的代码生成。我决定移植什么、按什么顺序移植，以及 Rust 代码应该是什么样子。这是数百个小型提示，引导智能体处理需要完成的工作。[...]&lt;/p&gt;
&lt;p&gt;从一开始的要求就是两个流水线输出的字节级完全一致。结果产生了大约 25,000 行 Rust 代码，整个移植过程大约花费了两周时间。同样的工作如果手动完成，将花费我数月时间。我们已经验证，Rust 解析器生成的每个抽象语法树都与 C++ 版本相同，并且 Rust 编译器生成的所有字节码也与 C++ 编译器的输出完全相同。整体零回归。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拥有像 &lt;code&gt;test262&lt;/code&gt; 这样高质量的现有一致性测试套件，对于这种规模的项目来说是一个巨大的解锁器，而能够将输出与现有可信实现进行比较，使得智能体工程更加稳妥可靠。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Via &lt;a href="https://news.ycombinator.com/item?id=47120899"&gt;Hacker News&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/browsers"&gt;browsers&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/javascript"&gt;javascript&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/rust"&gt;rust&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/andreas-kling"&gt;andreas-kling&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ladybird"&gt;ladybird&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/swift"&gt;swift&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/conformance-suites"&gt;conformance-suites&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Mon, 23 Feb 2026 18:52:53 +0000</pubDate></item></channel></rss>