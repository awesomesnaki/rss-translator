<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Willison's Weblog (中文)</title><link>http://simonwillison.net/</link><description/><language>zh-CN</language><lastBuildDate>Sun, 01 Mar 2026 11:21:45 +0000</lastBuildDate><item><title>引用 claude.com/import-memory</title><link>https://simonwillison.net/2026/Mar/1/claude-import-memory/#atom-everything</link><description>&lt;blockquote cite="https://claude.com/import-memory"&gt;&lt;p&gt;&lt;code&gt;我正在迁移到另一项服务，需要导出我的数据。请列出你存储的关于我的所有记忆，以及你从过往对话中了解到的关于我的任何背景信息。将所有内容输出在单个代码块中，以便我轻松复制。将每个条目格式化为：[保存日期，如可用] - 记忆内容。请确保涵盖以下所有方面——尽可能逐字保留我的原话：我给你的关于如何回应的指示（语气、格式、风格、“总是做X”、“绝不做Y”）。个人详情：姓名、地点、工作、家庭、兴趣。项目、目标和反复出现的话题。我使用的工具、语言和框架。我对你行为的偏好和纠正。任何上述未涵盖的其他存储背景信息。不要总结、分组或省略任何条目。在代码块之后，请确认这是完整集合还是仍有遗漏。&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://claude.com/import-memory"&gt;claude.com/import-memory&lt;/a&gt;, Anthropic的“将你的记忆导入Claude”功能是一个提示&lt;/p&gt;

    &lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/prompt-engineering"&gt;提示工程&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llm-memory"&gt;llm-记忆&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/anthropic"&gt;anthropic&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/claude"&gt;claude&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式人工智能&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 01 Mar 2026 11:21:45 +0000</pubDate></item><item><title>交互式解释</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/interactive-explanations/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当我们无法理解智能体编写的代码如何工作时，我们就背负上了&lt;strong&gt;认知债务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于很多事情来说，这无关紧要：如果代码只是从数据库获取一些数据并以JSON格式输出，其实现细节可能足够简单，我们无需关心。我们可以试用新功能，对其工作原理做出非常可靠的猜测，然后快速浏览一下代码以确认。&lt;/p&gt;
&lt;p&gt;然而，细节往往确实很重要。如果我们应用程序的核心变成了一个我们不完全理解的“黑匣子”，我们就无法再自信地对其进行推理，这使得规划新功能变得更加困难，并最终像累积的技术债务一样拖慢我们的进度。&lt;/p&gt;
&lt;p&gt;我们如何偿还认知债务？通过增进我们对代码工作原理的理解。&lt;/p&gt;
&lt;p&gt;我最喜欢的方法之一是构建&lt;strong&gt;交互式解释&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="understanding-word-clouds"&gt;理解词云&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://minimaxir.com/2026/02/ai-agent-coding/"&gt;《一个AI智能体编码怀疑论者尝试AI智能体编码，细节详尽》&lt;/a&gt;一文中，Max Woolf提到他用提示词&lt;code&gt;创建一个Rust应用，能够根据给定的长输入文本生成“词云”数据可视化&lt;/code&gt;来测试LLMs的Rust能力。&lt;/p&gt;
&lt;p&gt;这激发了我的想象力：我一直想知道词云是如何工作的，所以我启动了一个&lt;a href="https://simonwillison.net/2025/Nov/6/async-code-research/"&gt;异步研究项目&lt;/a&gt;——&lt;a href="https://github.com/simonw/research/pull/91#issue-4002426963"&gt;初始提示在此&lt;/a&gt;，&lt;a href="https://github.com/simonw/research/tree/main/rust-wordcloud"&gt;代码和报告在此&lt;/a&gt;——来探索这个想法。&lt;/p&gt;
&lt;p&gt;效果非常好：Claude Code for web为我构建了一个Rust CLI工具，可以生成像这样的图片：&lt;/p&gt;
&lt;p&gt;&lt;img alt="一个词云，包含许多单词，颜色和大小各异，较大的单词在中间。" src="https://raw.githubusercontent.com/simonw/research/refs/heads/main/rust-wordcloud/wordcloud.png"/&gt;&lt;/p&gt;
&lt;p&gt;但它实际上是如何工作的呢？&lt;/p&gt;
&lt;p&gt;Claude的报告说它使用了“&lt;strong&gt;阿基米德螺旋布局&lt;/strong&gt;，并带有每个单词的随机角度偏移，以实现自然外观的布局”。这对我帮助不大！&lt;/p&gt;
&lt;p&gt;我请求对代码库进行&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/linear-walkthroughs/"&gt;线性走查&lt;/a&gt;，这帮助我更详细地理解了Rust代码——这是&lt;a href="https://github.com/simonw/research/blob/main/rust-wordcloud/walkthrough.md"&gt;那份走查记录&lt;/a&gt;（以及&lt;a href="https://github.com/simonw/research/commit/2cb8c62477173ef6a4c2e274be9f712734df6126"&gt;提示词&lt;/a&gt;）。这帮助我理解了Rust代码的结构，但我仍然对那个“阿基米德螺旋布局”部分实际上如何工作缺乏直观的理解。&lt;/p&gt;&lt;p&gt;于是我请求生成一个&lt;strong&gt;动画解释&lt;/strong&gt;。我的做法是，将现有&lt;code&gt;walkthrough.md&lt;/code&gt;文档的链接粘贴到Claude Code会话中，并附上以下内容：&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;textarea&gt;使用curl获取 https://raw.githubusercontent.com/simonw/research/refs/heads/main/rust-wordcloud/walkthrough.md 到 /tmp 目录，以便你能阅读全文

受此启发，构建一个animated-word-cloud.html页面——该页面接受粘贴的文本（文本会保存在URL的`#fragment`中，这样加载带有该`#`的页面时就会使用该文本作为输入并自动提交），当你提交文本时，它会使用该文档中描述的算法生成词云，但以动画形式呈现，以使算法更易于理解。包含一个动画滑块，可以暂停、调整速度，甚至在暂停时逐帧步进。在任何阶段，都可以将当前可见的进行中的词云下载为PNG图片。&lt;/textarea&gt;&lt;/div&gt;
你可以&lt;ahref="https://tools.simonwillison.net/animated-word-cloud"&gt;在这里体验结果&lt;/a&gt;。这是一个动画GIF演示：&lt;/p&gt;
&lt;p&gt;&lt;imgalt="词云上的单词逐个出现，并显示小方框指示算法尝试放置它们的位置——如果这些方框与现有单词重叠，它会再次尝试。"src="https://static.simonwillison.net/static/2026/animated-word-cloud-demo.gif"/&gt;&lt;/p&gt;
&lt;p&gt;这是使用Claude Opus 4.6完成的，事实证明它在构建解释性动画方面品味相当不错。&lt;/p&gt;
&lt;p&gt;如果你仔细观察动画，可以看到对于每个单词，它都会尝试通过显示一个方框将其放置在页面上的某个位置，然后检查该方框是否与现有单词相交。如果是，它会继续尝试寻找合适的位置，从中心向外螺旋移动。&lt;/p&gt;
&lt;p&gt;我发现这个动画确实帮助我理解了算法的工作原理。&lt;/p&gt;
&lt;p&gt;我一直是动画和交互式界面的粉丝，它们有助于解释不同的概念。一个好的编码代理可以按需生成这些内容，以帮助解释代码——无论是它自己的代码还是他人编写的代码。&lt;/p&gt;
&lt;p&gt;标签：&lt;ahref="https://simonwillison.net/tags/explorables"&gt;explorables&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/cognitive-debt"&gt;cognitive-debt&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;ahref="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 28 Feb 2026 23:09:39 +0000</pubDate></item><item><title>求求你们，求求你们，求求你们别再使用通行密钥来加密用户数据了。</title><link>https://simonwillison.net/2026/Feb/27/passkeys/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://blog.timcappalli.me/p/passkeys-prf-warning/"&gt;求求了，求求了，求求你们别再使用通行密钥来加密用户数据了&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为用户&lt;em&gt;总是&lt;/em&gt;会丢失他们的通行密钥，并且可能不明白他们的数据已被这些密钥不可逆转地加密，再也无法恢复。&lt;/p&gt;
&lt;p&gt;蒂姆·卡帕利：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;致更广泛的身份识别行业：&lt;em&gt;请停止推广和使用通行密钥来加密用户数据。我恳求你们。让它们成为出色的、防网络钓鱼的身份验证凭证吧&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

    &lt;p&gt;&lt;small&gt;Via &lt;a href="https://lobste.rs/s/tf8j5h/please_stop_using_passkeys_for"&gt;lobste.rs&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;


    &lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/security"&gt;security&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/usability"&gt;usability&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/passkeys"&gt;passkeys&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 27 Feb 2026 22:49:32 +0000</pubDate></item><item><title>一位对AI代理编码持怀疑态度的人尝试了AI代理编码，过程极其详尽</title><link>https://simonwillison.net/2026/Feb/27/ai-agent-coding-in-excessive-detail/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://minimaxir.com/2026/02/ai-agent-coding/"&gt;一位AI智能体编码怀疑论者尝试AI智能体编码，事无巨细&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是又一篇属于“好吧，编码智能体在11月变强了”类型的文章，作者是马克斯·伍尔夫，非常值得你花时间阅读。他描述了一系列编码智能体项目，一个比一个更雄心勃勃——从简单的YouTube元数据抓取器开始，最终演变成这样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将Python的&lt;a href="https://scikit-learn.org/stable/"&gt;scikit-learn&lt;/a&gt;——数据科学和机器学习库的黄金标准——移植到Rust，并包含其所有功能，这听起来很狂妄。&lt;/p&gt;
&lt;p&gt;但讽刺的是，这确实是个好主意，所以我决定无论如何都要尝试一下。借助智能体的帮助，我现在正在开发&lt;code&gt;rustlearn&lt;/code&gt;（一个极端的占位名称），这是一个Rust库，它不仅实现了标准机器学习算法（如&lt;a href="https://en.wikipedia.org/wiki/Logistic_regression"&gt;逻辑回归&lt;/a&gt;和&lt;a href="https://en.wikipedia.org/wiki/K-means_clustering"&gt;k均值聚类&lt;/a&gt;）的快速实现，还包含了上述算法的快速实现：即使对于更简单的算法，我上面描述的三步流程仍然有效，足以超越scikit-learn的实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;马克斯还捕捉到了试图向现有的怀疑论听众解释这些模型变得有多好时的那种挫败感：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Opus 4.6/Codex 5.3真正恼人的一点是，你不可能公开说“Opus 4.5（以及其后发布的模型）比仅仅几个月前发布的编码大语言模型好了一个数量级”而不听起来像一个炒作AI、制造点击诱饵的人，但这却是我个人挫败感背后反直觉的真相。我一直在尝试通过给它一些复杂的任务来“搞垮”这个该死的模型，这些任务即使以我的编码资历也需要数月才能完成，但Opus和Codex却总能正确完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章中一句随口提及的话启发了我&lt;a href="https://github.com/simonw/research/tree/main/rust-wordcloud#readme"&gt;让Claude Code构建一个Rust词云命令行工具&lt;/a&gt;，而它愉快地照做了。&lt;/p&gt;

    &lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/python"&gt;python&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/rust"&gt;rust&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/max-woolf"&gt;max-woolf&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/november-2025-inflection"&gt;november-2025-inflection&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 27 Feb 2026 20:43:41 +0000</pubDate></item><item><title>免费Claude Max面向（大型项目）开源维护者</title><link>https://simonwillison.net/2026/Feb/27/claude-max-oss-six-months/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://claude.com/contact-sales/claude-for-oss"&gt;为（大型项目）开源维护者提供免费的Claude Max&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Anthropic现在为开源维护者免费提供其价值200美元/月的Claude Max 20x计划...为期六个月...但您需要满足以下条件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;维护者：&lt;/strong&gt; 您是一个拥有5000+ GitHub星标&lt;em&gt;或&lt;/em&gt;100万+月NPM下载量的公共仓库的主要维护者或核心团队成员。您在过去3个月内进行过提交、发布或PR审查。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不完全符合条件？&lt;/strong&gt; 如果您维护着生态系统默默依赖的项目，也请申请并告诉我们具体情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;细则中还提到：“申请将滚动审核。我们最多接受10,000名贡献者”。&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Via &lt;a href="https://news.ycombinator.com/item?id=47178371"&gt;Hacker News&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/open-source"&gt;open-source&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/anthropic"&gt;anthropic&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/claude"&gt;claude&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 27 Feb 2026 18:08:22 +0000</pubDate></item><item><title>Unicode浏览器：基于fetch() HTTP范围请求的二分查找实现</title><link>https://simonwillison.net/2026/Feb/27/unicode-explorer/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://tools.simonwillison.net/unicode-binary-search"&gt;使用 fetch() HTTP 范围请求进行二分查找的 Unicode 探索器&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
这是我今天早上在手机上构建的一个小原型，作为 HTTP 范围请求的实验，也是使用 LLM 来满足好奇心的一个通用示例。
&lt;p&gt;我收集&lt;a href="https://simonwillison.net/tags/http-range-requests/"&gt;HTTP 范围请求技巧&lt;/a&gt;已经有一段时间了，我决定自己用它们构建一些有趣的东西，利用二分查找来处理一个大文件，并做一些有用的事情。&lt;/p&gt;
&lt;p&gt;于是我和&lt;a href="https://claude.ai/share/47860666-cb20-44b5-8cdb-d0ebe363384f"&gt;Claude 进行了头脑风暴&lt;/a&gt;。挑战在于为二分查找想出一个用例，其中数据可以自然地以有利于二分查找的方式进行排序。&lt;/p&gt;
&lt;p&gt;Claude 的建议之一是查找 Unicode 码点的信息，这意味着要搜索许多 MB 的元数据。&lt;/p&gt;
&lt;p&gt;我让 Claude 为我写了一个规范，准备喂给 Claude Code——&lt;a href="https://github.com/simonw/research/pull/90#issue-4001466642"&gt;可以在这里看到&lt;/a&gt;——然后针对我的&lt;a href="https://github.com/simonw/research"&gt;simonw/research&lt;/a&gt;仓库，启动了一个&lt;a href="https://simonwillison.net/2025/Nov/6/async-code-research/"&gt;异步研究项目&lt;/a&gt;，使用 Claude Code for web 来将其转化为可运行的代码。&lt;/p&gt;
&lt;p&gt;这是&lt;a href="https://github.com/simonw/research/tree/main/unicode-explorer-binary-search#readme"&gt;最终的报告和代码&lt;/a&gt;。我学到的一个有趣的事情是，范围请求技巧与 HTTP 压缩不兼容，因为它们会扰乱字节偏移量的计算。我在 &lt;code&gt;fetch()&lt;/code&gt; 调用中添加了 &lt;code&gt;'Accept-Encoding': 'identity'&lt;/code&gt;，但这实际上并不必要，因为 Cloudflare 和其他 CDN 如果检测到 &lt;code&gt;content-range&lt;/code&gt; 头，会自动跳过压缩。&lt;/p&gt;
&lt;p&gt;我将结果&lt;a href="https://tools.simonwillison.net/unicode-binary-search"&gt;部署到了我的 tools.simonwillison.net 网站&lt;/a&gt;，在此之前，我先调整了它，使其通过范围请求查询一个存储在 S3 桶中、由 Cloudflare 提供前端服务并启用了 CORS 的 76.6MB 文件。&lt;/p&gt;
&lt;p&gt;这个演示玩起来很有趣——输入一个像 &lt;code&gt;ø&lt;/code&gt; 这样的单个字符，或者像 &lt;code&gt;1F99C&lt;/code&gt; 这样的十六进制码点指示符，它就会通过二分查找遍历这个大文件，并向你展示它沿途采取的步骤：&lt;/p&gt;&lt;p&gt;&lt;img alt="一个名为Unicode Explore的网页工具的动态演示。我输入&amp;符号并点击搜索。下方框内显示了一系列HTTP二分查找请求，经过17步找到结果，传输了3,864字节，并告诉我&amp;符号是基本拉丁语中其他标点符号的U+0026" src="https://static.simonwillison.net/static/2026/unicode-explore.gif"/&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/algorithms"&gt;算法&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/http"&gt;http&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/research"&gt;研究&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/tools"&gt;工具&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/unicode"&gt;unicode&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式人工智能&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;人工智能辅助编程&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;氛围编程&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/http-range-requests"&gt;http范围请求&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Fri, 27 Feb 2026 17:50:54 +0000</pubDate></item><item><title>囤积你擅长的事情</title><link>https://simonwillison.net/guides/agentic-engineering-patterns/hoard-things-you-know-how-to-do/#atom-everything</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://simonwillison.net/guides/agentic-engineering-patterns/"&gt;智能体工程模式&lt;/a&gt; &amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我关于如何高效使用编码智能体的许多技巧，其实是我职业生涯中一些有用建议的延伸，即使没有智能体时这些建议也很有用。这里有一个很好的例子：&lt;strong&gt;囤积你掌握的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;构建软件技能的一个重要部分是理解什么是可能的、什么是不可能的，并且至少对如何实现这些事情有一个粗略的想法。&lt;/p&gt;
&lt;p&gt;这些问题可能很宽泛，也可能相当冷僻。一个网页能否仅用JavaScript运行OCR操作？iPhone应用在不运行时能否与蓝牙设备配对？我们能否在Python中处理一个100GB的JSON文件，而不需要先将整个文件加载到内存中？&lt;/p&gt;
&lt;p&gt;你掌握的这类问题的答案越多，你就越有可能发现机会，以他人可能未曾想到的方式运用技术来解决问题。&lt;/p&gt;
&lt;p&gt;知道某件事在理论上是可能的，与亲眼见过它被实现是不同的。作为一名软件专业人士，需要培养的一项关键资产就是大量收集这类问题的答案，最好有可运行的代码作为例证。&lt;/p&gt;
&lt;p&gt;我通过多种不同的方式来囤积这类解决方案。我的&lt;a href="https://simonwillison.net"&gt;博客&lt;/a&gt;和&lt;a href="https://til.simonwillison.net"&gt;TIL博客&lt;/a&gt;里塞满了关于我如何搞定某些事情的笔记。我拥有&lt;a href="https://github.com/simonw"&gt;超过一千个GitHub仓库&lt;/a&gt;，收集了为不同项目编写的代码，其中很多是展示关键想法的小型概念验证。&lt;/p&gt;
&lt;p&gt;最近，我开始使用LLM来帮助扩展我针对有趣问题的代码解决方案集。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://tools.simonwillison.net"&gt;tools.simonwillison.net&lt;/a&gt;是我最大的LLM辅助工具和原型集合。我用它来收集我称之为&lt;a href="https://simonwillison.net/2025/Dec/10/html-tools/"&gt;HTML工具&lt;/a&gt;的东西——即嵌入JavaScript和CSS并解决特定问题的单个HTML页面。&lt;/p&gt;
&lt;p&gt;我的&lt;a href="https://github.com/simonw/research"&gt;simonw/research&lt;/a&gt;仓库包含更大、更复杂的示例，在这些示例中，我挑战编码智能体去研究一个问题，并带回可运行的代码和一份详细说明其发现的书面报告。&lt;/p&gt;
&lt;h2 id="recombining-things-from-your-hoard"&gt;重组你的囤积物&lt;/h2&gt;
&lt;p&gt;为什么要收集所有这些材料？除了帮助你构建和扩展自己的能力之外，你在此过程中生成的资产会成为编码智能体极其强大的输入。&lt;/p&gt;
&lt;p&gt;我最喜欢的提示模式之一，就是告诉智能体通过组合两个或多个现有的工作示例来构建新东西。&lt;/p&gt;&lt;p&gt;一个帮助我明确认识到这种方法有多有效的项目，是我添加到工具集合中的第一个工具——一个基于浏览器的&lt;a href="https://tools.simonwillison.net/ocr"&gt;OCR工具&lt;/a&gt;，&lt;a href="https://simonwillison.net/2024/Mar/30/ocr-pdfs-images/"&gt;这里有更详细的描述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我想要一个简单、基于浏览器的工具，用于对PDF文件中的页面进行OCR识别——特别是那些完全由扫描图像组成、完全没有提供文本版本的PDF。&lt;/p&gt;
&lt;p&gt;我之前尝试过在浏览器中运行&lt;a href="https://tesseract.projectnaptha.com/"&gt;Tesseract.js OCR库&lt;/a&gt;，发现它功能非常强大。该库提供了成熟的Tesseract OCR引擎的WebAssembly版本，让你可以从JavaScript调用它来从图像中提取文本。&lt;/p&gt;
&lt;p&gt;但我不想处理图像，我想处理PDF。然后我想起来，我也用过Mozilla的&lt;a href="https://mozilla.github.io/pdf.js/"&gt;PDF.js&lt;/a&gt;库，它可以将PDF的单个页面转换成渲染后的图像。&lt;/p&gt;
&lt;p&gt;我的笔记里有这两个库的JavaScript代码片段。&lt;/p&gt;
&lt;p&gt;以下是我输入给模型（当时是Claude 3 Opus）的完整提示，它结合了我的两个例子，并描述了我正在寻找的解决方案：&lt;/p&gt;&lt;div&gt;&lt;textarea&gt;这段代码展示了如何打开PDF并将其每页转换为图像：
```html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;PDF转图像&lt;/title&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"&gt;&lt;/script&gt;
  &lt;style&gt;
    .image-container img {
      margin-bottom: 10px;
    }
    .image-container p {
      margin: 0;
      font-size: 14px;
      color: #888;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;input type="file" id="fileInput" accept=".pdf" /&gt;
  &lt;div class="image-container"&gt;&lt;/div&gt;

  &lt;script&gt;
  const desiredWidth = 800;
    const fileInput = document.getElementById('fileInput');
    const imageContainer = document.querySelector('.image-container');

    fileInput.addEventListener('change', handleFileUpload);

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

    async function handleFileUpload(event) {
      const file = event.target.files[0];
      const imageIterator = convertPDFToImages(file);

      for await (const { imageURL, size } of imageIterator) {
        const imgElement = document.createElement('img');
        imgElement.src = imageURL;
        imageContainer.appendChild(imgElement);

        const sizeElement = document.createElement('p');
        sizeElement.textContent = `大小：${formatSize(size)}`;
        imageContainer.appendChild(sizeElement);
      }
    }

    async function* convertPDFToImages(file) {
      try {
        const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
        const numPages = pdf.numPages;

        for (let i = 1; i &lt;= numPages; i++) {
          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: 1 });
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = desiredWidth;
          canvas.height = (desiredWidth / viewport.width) * viewport.height;
          const renderContext = {
            canvasContext: context,
            viewport: page.getViewport({ scale: desiredWidth / viewport.width }),
          };
          await page.render(renderContext).promise;
          const imageURL = canvas.toDataURL('image/jpeg', 0.8);
          const size = calculateSize(imageURL);
          yield { imageURL, size };
        }
      } catch (error) {
        console.error('错误：', error);
      }
    }

    function calculateSize(imageURL) {
      const base64Length = imageURL.length - 'data:image/jpeg;base64,'.length;
      const sizeInBytes = Math.ceil(base64Length * 0.75);
      return sizeInBytes;
    }

    function formatSize(size) {
      const sizeInKB = (size / 1024).toFixed(2);
      return `${sizeInKB} KB`;
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
```
这段代码展示了如何对图像进行OCR识别：
```javascript
async function ocrMissingAltText() {
    // 加载Tesseract
    var s = document.createElement("script");
    s.src = "https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js";
    document.head.appendChild(s);

    s.onload = async () =&gt; {
      const images = document.getElementsByTagName("img");
      const worker = Tesseract.createWorker();
      await worker.load();
      await worker.loadLanguage("eng");
      await worker.initialize("eng");
      ocrButton.innerText = "正在运行OCR...";

      // 遍历输出div中的所有图像
      for (const img of images) {
        const altTextarea = img.parentNode.querySelector(".textarea-alt");
        // 检查alt文本区域是否为空
        if (altTextarea.value === "") {
          const imageUrl = img.src;
          var {
            data: { text },
          } = await worker.recognize(imageUrl);
          altTextarea.value = text; // 将OCR结果设置到alt文本区域
          progressBar.value += 1;
        }
      }

      await worker.terminate();
      ocrButton.innerText = "OCR完成";
    };
  }
```
请使用这些示例来整合一个包含嵌入式HTML、CSS和JavaScript的单一HTML页面，该页面提供一个大的正方形区域，用户可以将PDF文件拖放到该区域上，当用户这样做时，PDF的每一页都会被转换为JPEG格式并显示在页面下方，然后使用tesseract运行OCR，并将结果显示在每个图像下方的文本区域块中。&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;这简直完美无缺！模型直接生成了一个概念验证页面，完全满足了我的需求。&lt;/p&gt;
&lt;p&gt;我最终&lt;a href="https://gist.github.com/simonw/6a9f077bf8db616e44893a24ae1d36eb"&gt;与它进行了几次迭代&lt;/a&gt;才得到最终结果，但只花了几分钟就构建了一个真正有用的工具，从那以后我一直从中受益。&lt;/p&gt;
&lt;h2 id="coding-agents-make-this-even-more-powerful"&gt;编码智能体让这一切更加强大&lt;/h2&gt;
&lt;p&gt;我是在2024年3月构建那个OCR示例的，那是在Claude Code首次发布前近一年。编码智能体使得囤积可运行的示例变得更有价值。&lt;/p&gt;
&lt;p&gt;如果你的编码智能体可以访问互联网，你可以让它做这样的事情：&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;textarea&gt;使用curl获取`https://tools.simonwillison.net/ocr`和`https://tools.simonwillison.net/gemini-bbox`的源代码，并构建一个新工具，让你可以从PDF中选择一页并将其传递给Gemini，以返回该页面上插图的边界框。&lt;/textarea&gt;&lt;/div&gt;
（我在那里指定了&lt;code&gt;curl&lt;/code&gt;，因为Claude Code默认使用WebFetch工具，该工具会总结页面内容而不是返回原始HTML。）&lt;/p&gt;
&lt;p&gt;编码智能体非常擅长搜索，这意味着你可以在自己的机器上运行它们，并告诉它们去哪里找你希望它们做的事情的示例：
&lt;div&gt;&lt;textarea&gt;为`~/dev/ecosystem/datasette-oauth`项目添加模拟HTTP测试，灵感来自`~/dev/ecosystem/llm-mistral`项目的做法。&lt;/textarea&gt;&lt;/div&gt;
通常这就足够了——智能体会启动一个搜索子智能体来调查并提取完成任务所需的细节。&lt;/p&gt;
&lt;p&gt;由于我的大部分研究代码都是公开的，我经常告诉编码智能体将我的仓库克隆到&lt;code&gt;/tmp&lt;/code&gt;目录并将其用作输入：
&lt;div&gt;&lt;textarea&gt;从GitHub克隆`simonw/research`到`/tmp`目录，找到将Rust编译为WebAssembly的示例，然后用它来为这个项目构建一个演示HTML页面。&lt;/textarea&gt;&lt;/div&gt;
这里的关键思想是，编码智能体意味着我们只需要&lt;em&gt;一次&lt;/em&gt;弄明白一个有用的技巧。如果这个技巧随后在某个地方被记录下来并附有可运行的代码示例，我们的智能体就可以参考该示例，并用它来解决未来任何类似的项目。&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 26 Feb 2026 20:33:27 +0000</pubDate></item><item><title>引用安德烈·卡帕西的话</title><link>https://simonwillison.net/2026/Feb/26/andrej-karpathy/#atom-everything</link><description>&lt;blockquote cite="https://twitter.com/karpathy/status/2026731645169185220"&gt;&lt;p&gt;很难描述过去两个月里，AI 给编程带来了多大的改变：这种改变并非以“常规进展”的方式逐渐发生，而是特别集中在去年十二月。这其中有许多值得注意的细节，但在我看来，编码智能体在十二月之前基本上无法有效工作，而自十二月起则基本可以了——模型的质量、长期连贯性和持久性都有了显著提升，它们能够攻克庞大而长期的任务，其程度足以对默认的编程工作流程造成极大的颠覆。[...]&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://twitter.com/karpathy/status/2026731645169185220"&gt;Andrej Karpathy&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/andrej-karpathy"&gt;andrej-karpathy&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/agentic-engineering"&gt;agentic-engineering&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/november-2025-inflection"&gt;november-2025-inflection&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 26 Feb 2026 19:03:27 +0000</pubDate></item><item><title>谷歌API密钥本非秘密。但随后Gemini改变了规则。</title><link>https://simonwillison.net/2026/Feb/26/google-api-keys/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://trufflesecurity.com/blog/google-api-keys-werent-secrets-but-then-gemini-changed-the-rules"&gt;谷歌API密钥本非机密。但随后Gemini改变了规则。&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哎呀！原来Gemini和谷歌地图（以及其他服务）共享相同的API密钥……但谷歌地图API密钥设计为公开，因为它们直接嵌入在网页中。而Gemini API密钥可用于访问私人文件并进行计费API请求，因此绝对不应共享。&lt;/p&gt;
&lt;p&gt;如果你不了解这一点，很容易意外地为一个已存在于公开环境中的、原本公开的API密钥启用Gemini计费功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使其成为权限提升而非配置错误的，是事件发生的顺序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者创建一个API密钥并将其嵌入网站用于地图服务。（此时，该密钥是无害的。）&lt;/li&gt;
&lt;li&gt;在同一项目上启用了Gemini API。（现在，同一个密钥可以访问敏感的Gemini端点。）&lt;/li&gt;
&lt;li&gt;开发者从未收到密钥权限已在其不知情下发生改变的警告。（该密钥从公开标识符变成了秘密凭证）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Truffle Security在2025年11月的Common Crawl数据中发现了2,863个可以访问Gemini的API密钥，这是通过调用&lt;code&gt;/models&lt;/code&gt;列表端点验证的。其中包括几个属于谷歌自身的密钥，其中一个自2023年2月就已部署（根据互联网档案馆记录），因此早于它现在能够访问的Gemini API。&lt;/p&gt;
&lt;p&gt;谷歌正在努力撤销受影响的密钥，但检查一下你自己的密钥是否受此影响仍然是个好主意。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Via &lt;a href="https://news.ycombinator.com/item?id=47156925"&gt;Hacker News&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/api-keys"&gt;api-keys&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/google"&gt;google&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/security"&gt;security&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/gemini"&gt;gemini&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 26 Feb 2026 04:28:55 +0000</pubDate></item><item><title>引用本尼迪克特·埃文斯</title><link>https://simonwillison.net/2026/Feb/26/benedict-evans/#atom-everything</link><description>&lt;blockquote cite="https://www.ben-evans.com/benedictevans/2026/2/19/how-will-openai-compete-nkg2x"&gt;&lt;p&gt;如果人们最多每周只使用几次，并且在平常日子里想不出能用它来做什么，那它就没有改变他们的生活。OpenAI自己也承认这个问题，他们谈到模型的能力与人们实际使用之间存在“能力差距”，在我看来，这像是一种避免直接说你没有明确产品市场契合度的说法。&lt;/p&gt;
&lt;p&gt;因此，OpenAI的广告项目部分只是为了覆盖服务那90%或更多不付费用户的成本（并在广告商中抢占早期领先地位，以及学习这种模式如何运作），但从更战略性的角度看，它也是为了能够向这些用户提供最新、最强大（即最昂贵）的模型，希望这能加深他们的参与度。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;&amp;mdash; &lt;a href="https://www.ben-evans.com/benedictevans/2026/2/19/how-will-openai-compete-nkg2x"&gt;Benedict Evans&lt;/a&gt;, OpenAI将如何竞争？&lt;/p&gt;

    &lt;p&gt;标签： &lt;a href="https://simonwillison.net/tags/openai"&gt;openai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/chatgpt"&gt;chatgpt&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/benedict-evans"&gt;benedict-evans&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 26 Feb 2026 03:44:56 +0000</pubDate></item></channel></rss>