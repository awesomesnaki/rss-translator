<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Willison's Weblog (中文)</title><link>http://simonwillison.net/</link><description/><language>zh-CN</language><lastBuildDate>Wed, 11 Feb 2026 20:59:03 +0000</lastBuildDate><item><title>引自尼曼实验室的安德鲁·德克</title><link>https://simonwillison.net/2026/Feb/11/manosphere-report/#atom-everything</link><description>&lt;blockquote cite="https://www.niemanlab.org/2026/02/how-the-new-york-times-uses-a-custom-ai-tool-to-track-the-manosphere/"&gt;&lt;p&gt;一份直接发送至记者邮箱的AI生成报告，成为《纽约时报》报道的重要工具。这也是保守派媒体开始反对政府的最初信号之一[...]

这款内部开发、代号为"男性圈层报告"的工具，利用大语言模型对数十档播客的新节目进行转录和摘要分析。

"男性圈层报告让我们快速清晰地意识到，总统的部分基本盘对此并不买账，"苏厄德表示，"看到这份报告后，我们立即跟进并展开深入报道。"

——  
安德鲁·德克为尼曼实验室撰稿  
《纽约时报如何运用定制AI工具追踪"男性圈层"动态》

标签：  
生成式人工智能  
纽约时报  
新闻业  
人工智能  
数据新闻  
大语言模型&lt;/p&gt;
&lt;p&gt;Built in-house and known internally as the “Manosphere Report,” the tool uses large language models (LLMs) to transcribe and summarize new episodes of dozens of podcasts.&lt;/p&gt;
&lt;p&gt;“The Manosphere Report gave us a really fast and clear signal that this was not going over well with that segment of the President’s base,” said Seward. “There was a direct link between seeing that and then diving in to actually cover it.”&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;— &lt;a href="https://www.niemanlab.org/2026/02/how-the-new-york-times-uses-a-custom-ai-tool-to-track-the-manosphere/"&gt;Andrew Deck for Niemen Lab&lt;/a&gt;, How The New York Times uses a custom AI tool to track the “manosphere”&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/new-york-times"&gt;new-york-times&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/journalism"&gt;journalism&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/data-journalism"&gt;data-journalism&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 11 Feb 2026 20:59:03 +0000</pubDate></item><item><title>OpenAI API 使用技巧</title><link>https://simonwillison.net/2026/Feb/11/skills-in-openai-api/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.openai.com/cookbook/examples/skills_in_api"&gt;OpenAI API中的技能应用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;OpenAI对技能的采用持续深入。现在您可以直接通过其&lt;a href="https://developers.openai.com/api/docs/guides/tools-shell/"&gt;shell工具&lt;/a&gt;在OpenAI API中使用技能。虽然您可以先将技能打包为zip文件上传，但我认为更简洁的交互方式是通过JSON请求以内联base64编码的zip数据形式发送技能，正如&lt;a href="https://github.com/simonw/research/blob/main/openai-api-skills/openai_inline_skills.py"&gt;此脚本&lt;/a&gt;所示：
&lt;pre&gt;&lt;span class="pl-s1"&gt;r&lt;/span&gt; &lt;span class="pl-c1"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;OpenAI&lt;/span&gt;().&lt;span class="pl-c1"&gt;responses&lt;/span&gt;.&lt;span class="pl-c1"&gt;create&lt;/span&gt;(
    &lt;span class="pl-s1"&gt;model&lt;/span&gt;&lt;span class="pl-c1"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;"gpt-5.2"&lt;/span&gt;,
    &lt;span class="pl-s1"&gt;tools&lt;/span&gt;&lt;span class="pl-c1"&gt;=&lt;/span&gt;[
      {
        &lt;span class="pl-s"&gt;"type"&lt;/span&gt;: &lt;span class="pl-s"&gt;"shell"&lt;/span&gt;,
        &lt;span class="pl-s"&gt;"environment"&lt;/span&gt;: {
          &lt;span class="pl-s"&gt;"type"&lt;/span&gt;: &lt;span class="pl-s"&gt;"container_auto"&lt;/span&gt;,
          &lt;span class="pl-s"&gt;"skills"&lt;/span&gt;: [
            {
              &lt;span class="pl-s"&gt;"type"&lt;/span&gt;: &lt;span class="pl-s"&gt;"inline"&lt;/span&gt;,
              &lt;span class="pl-s"&gt;"name"&lt;/span&gt;: &lt;span class="pl-s"&gt;"wc"&lt;/span&gt;,
              &lt;span class="pl-s"&gt;"description"&lt;/span&gt;: &lt;span class="pl-s"&gt;"统计文件中的字数。"&lt;/span&gt;,
              &lt;span class="pl-s"&gt;"source"&lt;/span&gt;: {
                &lt;span class="pl-s"&gt;"type"&lt;/span&gt;: &lt;span class="pl-s"&gt;"base64"&lt;/span&gt;,
                &lt;span class="pl-s"&gt;"media_type"&lt;/span&gt;: &lt;span class="pl-s"&gt;"application/zip"&lt;/span&gt;,
                &lt;span class="pl-s"&gt;"data"&lt;/span&gt;: &lt;span class="pl-s1"&gt;b64_encoded_zip_file&lt;/span&gt;,
              },
            }
          ],
        },
      }
    ],
    &lt;span class="pl-s1"&gt;input&lt;/span&gt;&lt;span class="pl-c1"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;"使用wc技能统计其自身SKILL.md文件中的字数。"&lt;/span&gt;,
)
&lt;span class="pl-en"&gt;print&lt;/span&gt;(&lt;span class="pl-s1"&gt;r&lt;/span&gt;.&lt;span class="pl-c1"&gt;output_text&lt;/span&gt;)&lt;/pre&gt;
&lt;p&gt;我在构建这个示例脚本前，首先让Claude Code的网页版工具&lt;a href="https://simonwillison.net/2026/Feb/10/showboat-and-rodney/"&gt;Showboat&lt;/a&gt;为我探索API并生成&lt;a href="https://github.com/simonw/research/blob/main/openai-api-skills/README.md"&gt;这份报告&lt;/a&gt;。这项研究项目的初始提示是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Run uvx showboat --help - you will use this tool later&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Fetch https://developers.openai.com/cookbook/examples/skills_in_api.md to /tmp with curl, then read it&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Use the OpenAI API key you have in your environment variables&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Use showboat to build up a detailed demo of this, replaying the examples from the documents and then trying some experiments of your own&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/openai"&gt;openai&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;AI辅助编程&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/skills"&gt;技能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/showboat"&gt;showboat&lt;/a&gt;&lt;/p&gt;</description><pubDate>Wed, 11 Feb 2026 19:19:22 +0000</pubDate></item><item><title>GLM-5：从氛围编程到智能体工程</title><link>https://simonwillison.net/2026/Feb/11/glm-5/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://z.ai/blog/glm-5"&gt;GLM-5：从氛围编程到智能体工程&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;这是一个&lt;em&gt;庞大的&lt;/em&gt;全新MIT许可模型：7540亿参数，&lt;a href="https://huggingface.co/zai-org/GLM-5"&gt;在Hugging Face上占用1.51TB空间&lt;/a&gt;规模达到&lt;a href="https://huggingface.co/zai-org/GLM-4.7"&gt;GLM-4.7&lt;/a&gt;的两倍（后者为3680亿参数/717GB，4.5和4.6版本也接近该规模）。
&lt;p&gt;有趣的是Z.ai对使用大语言模型构建系统的专业软件工程师提出了命名主张——近期我在多个场合看到“智能体工程”这个表述，最引人注目的&lt;a href="https://twitter.com/karpathy/status/2019137879310836075"&gt;来自安德烈·卡帕西&lt;/a&gt;和&lt;a href="https://addyosmani.com/blog/agentic-engineering/"&gt;艾迪·奥斯马尼&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我通过&lt;a href="https://openrouter.ai/"&gt;OpenRouter&lt;/a&gt;向GLM-5输入“生成鹈鹕骑自行车的SVG图像”提示词，得到的结果是&lt;a href="https://gist.github.com/simonw/cc4ca7815ae82562e89a9fdd99f0725d"&gt;一只精美的鹈鹕搭配着令人失望的自行车骨架&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="The pelican is good and has a well defined beak. The bicycle frame is a wonky red triangle. Nice sun and motion lines." src="https://static.simonwillison.net/static/2026/glm-5-pelican.png"/&gt;
&lt;p&gt;&lt;small&gt;&lt;/small&gt;来源：&lt;a href="https://news.ycombinator.com/item?id=46977210"&gt;黑客新闻&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/definitions"&gt;定义&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;AI辅助编程&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/pelican-riding-a-bicycle"&gt;鹈鹕骑自行车&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llm-release"&gt;大语言模型发布&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/vibe-coding"&gt;氛围编程&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/openrouter"&gt;OpenRouter&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-in-china"&gt;中国人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/glm"&gt;GLM&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Wed, 11 Feb 2026 18:56:14 +0000</pubDate></item><item><title>cysqlite - 一款新的SQLite驱动程序</title><link>https://simonwillison.net/2026/Feb/11/cysqlite/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://charlesleifer.com/blog/cysqlite---a-new-sqlite-driver/"&gt;cysqlite - 一款全新的SQLite驱动

查尔斯·莱弗自2018年以来持续维护着pysqlite3——这是Python标准库模块的分支版本，能显著简化升级版SQLite的运行部署。

与此同时，他几乎耗费同等时间从头开发了基于Cython重构的cysqlite，如今终于进入可供试用的阶段。

相较于原模块最显著的变革在于事务处理机制。查尔斯详尽阐述了他对原实现方案的不适——该库提供的两种变体均无法精准对应SQLite自身的自动提交机制。

特别令人振奋的是对自定义虚拟表的支持，这项我期待已久的功能终于得以实现。

该库提供由C语言编译的Python扩展模块，这意味着通常无法在Pyodide环境中使用。我通过Claude Code工具成功构建出cysqlite-0.1.4-cp311-cp311-emscripten_3_1_46_wasm32.whl——这个688KB的wheel文件包含库的WASM构建版本，可通过以下方式载入Pyodide：

import micropip
await micropip.install("https://simonw.github.io/research/cysqlite-wasm-wheel/cysqlite-0.1.4-cp311-cp311-emscripten_3_1_46_wasm32.whl")
import cysqlite
print(cysqlite.connect(":memory:").execute("select sqlite_version()").fetchone())

（同时了解到此类wheel文件必须针对Pyodide版本对应的emscripten进行构建——我的实验性wheel可在Pyodide 0.25.1运行，但在0.27.5版本会报错）

您可以在全新打造的Pyodide REPL中试用这个wheel文件，这是我为移动设备优化的Pyodide托管控制台替代方案。

我还通过Claude构建了演示页面，可在浏览器中执行原始测试套件并展示结果：

消息来源：lobste.rs
标签：python, sqlite, charles-leifer, webassembly, pyodide, ai-assisted-programming, claude-code&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
Charles Leifer has been maintaining &lt;a href="https://github.com/coleifer/pysqlite3"&gt;pysqlite3&lt;/a&gt; - a fork of the Python standard library's &lt;code&gt;sqlite3&lt;/code&gt; module that makes it much easier to run upgraded SQLite versions - since 2018.
&lt;p&gt;He's been working on a ground-up &lt;a href="https://cython.org/"&gt;Cython&lt;/a&gt; rewrite called &lt;a href="https://github.com/coleifer/cysqlite"&gt;cysqlite&lt;/a&gt; for almost as long, but it's finally at a stage where it's ready for people to try out.&lt;/p&gt;
&lt;p&gt;The biggest change from the &lt;code&gt;sqlite3&lt;/code&gt; module involves transactions. Charles explains his discomfort with the &lt;code&gt;sqlite3&lt;/code&gt; implementation at length - that library provides two different variants neither of which exactly match the autocommit mechanism in SQLite itself.&lt;/p&gt;
&lt;p&gt;I'm particularly excited about the support for &lt;a href="https://cysqlite.readthedocs.io/en/latest/api.html#tablefunction"&gt;custom virtual tables&lt;/a&gt;, a feature I'd love to see in &lt;code&gt;sqlite3&lt;/code&gt; itself.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cysqlite&lt;/code&gt; provides a Python extension compiled from C, which means it normally wouldn't be available in Pyodide. I &lt;a href="https://github.com/simonw/research/tree/main/cysqlite-wasm-wheel"&gt;set Claude Code on it&lt;/a&gt; and it built me &lt;a href="https://github.com/simonw/research/blob/main/cysqlite-wasm-wheel/cysqlite-0.1.4-cp311-cp311-emscripten_3_1_46_wasm32.whl"&gt;cysqlite-0.1.4-cp311-cp311-emscripten_3_1_46_wasm32.whl&lt;/a&gt;, a 688KB wheel file with a WASM build of the library that can be loaded into Pyodide like this:&lt;/p&gt;
&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-s1"&gt;micropip&lt;/span&gt;
&lt;span class="pl-k"&gt;await&lt;/span&gt; &lt;span class="pl-s1"&gt;micropip&lt;/span&gt;.&lt;span class="pl-c1"&gt;install&lt;/span&gt;(
    &lt;span class="pl-s"&gt;"https://simonw.github.io/research/cysqlite-wasm-wheel/cysqlite-0.1.4-cp311-cp311-emscripten_3_1_46_wasm32.whl"&lt;/span&gt;
)
&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-s1"&gt;cysqlite&lt;/span&gt;
&lt;span class="pl-en"&gt;print&lt;/span&gt;(&lt;span class="pl-s1"&gt;cysqlite&lt;/span&gt;.&lt;span class="pl-c1"&gt;connect&lt;/span&gt;(&lt;span class="pl-s"&gt;":memory:"&lt;/span&gt;).&lt;span class="pl-c1"&gt;execute&lt;/span&gt;(
    &lt;span class="pl-s"&gt;"select sqlite_version()"&lt;/span&gt;
).&lt;span class="pl-c1"&gt;fetchone&lt;/span&gt;())&lt;/pre&gt;
&lt;p&gt;(I also learned that wheels like this have to be built for the emscripten version used by that edition of Pyodide - my experimental wheel loads in Pyodide 0.25.1 but fails in 0.27.5 with a &lt;code&gt;Wheel was built with Emscripten v3.1.46 but Pyodide was built with Emscripten v3.1.58&lt;/code&gt; error.)&lt;/p&gt;
&lt;p&gt;You can try my wheel in &lt;a href="https://7ebbff98.tools-b1q.pages.dev/pyodide-repl"&gt;this new Pyodide REPL&lt;/a&gt; i had Claude build as a mobile-friendly alternative to Pyodide's &lt;a href="https://pyodide.org/en/stable/console.html"&gt;own hosted console&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I also had Claude build &lt;a href="https://simonw.github.io/research/cysqlite-wasm-wheel/demo.html"&gt;this demo page&lt;/a&gt; that executes the original test suite in the browser and displays the results:&lt;/p&gt;
&lt;p&gt;&lt;img alt='Screenshot of the cysqlite WebAssembly Demo page with a dark theme. Title reads "cysqlite — WebAssembly Demo" with subtitle "Testing cysqlite compiled to WebAssembly via Emscripten, running in Pyodide in the browser." Environment section shows Pyodide 0.25.1, Python 3.11.3, cysqlite 0.1.4, SQLite 3.51.2, Platform Emscripten-3.1.46-wasm32-32bit, Wheel file cysqlite-0.1.4-cp311-cp311-emscripten_3_1_46_wasm32.wh (truncated). A green progress bar shows "All 115 tests passed! (1 skipped)" at 100%, with Passed: 115, Failed: 0, Errors: 0, Skipped: 1, Total: 116. Test Results section lists TestBackup 1/1 passed, TestBlob 6/6 passed, TestCheckConnection 4/4 passed, TestDataTypesTableFunction 1/1 passed, all with green badges.' src="https://static.simonwillison.net/static/2026/cysqlite-tests.jpg"/&gt;
&lt;p&gt;&lt;small&gt;&lt;/small&gt;Via &lt;a href="https://lobste.rs/s/gipvta/cysqlite_new_sqlite_driver"&gt;lobste.rs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/python"&gt;python&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/sqlite"&gt;sqlite&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/charles-leifer"&gt;charles-leifer&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/webassembly"&gt;webassembly&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/pyodide"&gt;pyodide&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/claude-code"&gt;claude-code&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Wed, 11 Feb 2026 17:34:40 +0000</pubDate></item><item><title>隆重推出Showboat与Rodney，让智能体们展示他们的杰作。</title><link>https://simonwillison.net/2026/Feb/10/showboat-and-rodney/#atom-everything</link><description>&lt;p&gt;与编码智能体协作的一个关键挑战在于，既要让它们测试自己构建的软件，又要向监督者（即我们）展示软件成果。这超越了自动化测试的范畴——我们需要能直观呈现进展、帮助我们清晰了解智能体所产软件实际功能的载体。为此，我刚刚发布了两款新工具：

**Showboat** 与 **Rodney**。

**验证代码实际运行效果**  
Showboat：智能体通过构建文档来演示其工作成果  
Rodney：专为配合Showboat设计的CLI浏览器自动化工具  

测试驱动开发固然有效，但我们仍需要人工测试环节。值得一提的是，这两款工具我都是在手机上完成的开发。

**验证代码实际运行效果**  
我最近撰文探讨过，软件工程师的核心职责并非编写代码，而是**交付可运行的代码**。其中至关重要的一环，就是向自己和他人证明我们负责的代码能够按预期运行。

随着编码智能体逐渐成为软件开发流程的核心组成部分，这项工作变得愈发重要且充满挑战。智能体产出的代码越多，能减少人工测试时间的工具就越显珍贵。

**StrongDM软件工厂模式**最引人深思的一点在于，他们如何在坚持“代码禁止人工审查”政策的同时，确保软件经过充分测试并实现价值交付。其解决方案部分依赖于运行“场景测试”的高成本QA智能体集群。这种模式虽令人着迷，但若能避免，我并不愿在QA机器人上投入数千美元！

我需要的工具，既要让智能体清晰展示工作成果，又要最大限度减少其成果造假的可能性。

**Showboat：智能体通过构建文档来演示其工作成果**  
Showboat正是我为解决这一问题而打造的工具。它是一个CLI工具（基于Go的二进制程序，也可选择用Python封装）。&lt;a href="https://github.com/simonw/showboat"&gt;Showboat&lt;/a&gt; and &lt;a href="https://github.com/simonw/rodney"&gt;Rodney&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://simonwillison.net/2026/Feb/10/showboat-and-rodney/#proving-code-actually-works"&gt;Proving code actually works&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://simonwillison.net/2026/Feb/10/showboat-and-rodney/#showboat-agents-build-documents-to-demo-their-work"&gt;Showboat: Agents build documents to demo their work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://simonwillison.net/2026/Feb/10/showboat-and-rodney/#rodney-cli-browser-automation-designed-to-work-with-showboat"&gt;Rodney: CLI browser automation designed to work with Showboat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://simonwillison.net/2026/Feb/10/showboat-and-rodney/#test-driven-development-helps-but-we-still-need-manual-testing"&gt;Test-driven development helps, but we still need manual testing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://simonwillison.net/2026/Feb/10/showboat-and-rodney/#i-built-both-of-these-tools-on-my-phone"&gt;I built both of these tools on my phone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="proving-code-actually-works"&gt;Proving code actually works&lt;/h4&gt;
&lt;p&gt;I recently wrote about how the job of a software engineer isn't to write code, it's to &lt;em&gt;&lt;a href="https://simonwillison.net/2025/Dec/18/code-proven-to-work/"&gt;deliver code that works&lt;/a&gt;&lt;/em&gt;. A big part of that is proving to ourselves and to other people that the code we are responsible for behaves as expected.&lt;/p&gt;
&lt;p&gt;This becomes even more important - and challenging - as we embrace coding agents as a core part of our software development process.&lt;/p&gt;
&lt;p&gt;The more code we churn out with agents, the more valuable tools are that reduce the amount of manual QA time we need to spend.&lt;/p&gt;
&lt;p&gt;One of the most interesting things about &lt;a href="https://simonwillison.net/2026/Feb/7/software-factory/"&gt;the StrongDM software factory model&lt;/a&gt; is how they ensure that their software is well tested and delivers value despite their policy that "code must not be reviewed by humans". Part of their solution involves expensive swarms of QA agents running through "scenarios" to exercise their software. It's fascinating, but I don't want to spend thousands of dollars on QA robots if I can avoid it!&lt;/p&gt;
&lt;p&gt;I need tools that allow agents to clearly demonstrate their work to me, while minimizing the opportunities for them to cheat about what they've done.&lt;/p&gt;
&lt;h4 id="showboat-agents-build-documents-to-demo-their-work"&gt;Showboat: Agents build documents to demo their work&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/simonw/showboat"&gt;Showboat&lt;/a&gt;&lt;/strong&gt; is the tool I built to help agents demonstrate their work to me.&lt;/p&gt;
&lt;p&gt;It's a CLI tool (a Go binary, optionally &lt;a href="https://simonwillison.net/2026/Feb/4/distributing-go-binaries/"&gt;wrapped in Python&lt;/a&gt;（为便于安装）该工具能帮助智能体构建Markdown文档，直观展示其新开发代码的功能。

虽然并非设计给人类直接运行，但以下是运行方法：

如何使用curl和jq

"
如何结合使用curl和jq
"

执行
'
curl -s https://api.github.com/repos/simonw/rodney | jq .description
'

'
以及curl徽标，用于演示图像命令：
'

'
curl -o curl-logo.png https://curl.se/logo/curl-logo.png &amp;amp;&amp;amp; echo curl-logo.png
'

在VS Code中打开并预览Markdown的效果如下：

这是演示文档在Gist中的链接。

通过一系列命令，可以逐步构建Markdown文档，这些命令的输出会自动附加在已执行命令之后。

命令较为特殊——它会从命令输出中查找图像文件路径，将该图像复制到当前文件夹并在文档中引用。

这基本就是全部功能！还包含命令用于在出错时删除最近添加的章节，命令用于重新运行文档以检查内容是否变更（我对该功能的设计尚未完全信服），以及命令用于逆向解析创建文档时使用的CLI指令。

相当简洁——仅172行Go代码。

我使用工具进行打包，这意味着您无需预先安装即可直接运行：

该命令至关重要：它旨在为编码智能体提供使用此工具所需的全部信息。这是完整的帮助文本。

这意味着您可以打开Claude Code并输入：

至此完成！这段文本的作用类似于技能模块。您的智能体通过阅读帮助文本，就能运用Showboat的所有功能来创建展示所需内容的文档。&lt;/p&gt;
&lt;p&gt;It's not designed for humans to run, but here's how you would run it anyway:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;showboat init demo.md &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;How to use curl and jq&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
showboat note demo.md &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Here's how to use curl and jq together.&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
showboat &lt;span class="pl-c1"&gt;exec&lt;/span&gt; demo.md bash &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;curl -s https://api.github.com/repos/simonw/rodney | jq .description&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
showboat note demo.md &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;And the curl logo, to demonstrate the image command:&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
showboat image demo.md &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;curl -o curl-logo.png https://curl.se/logo/curl-logo.png &amp;amp;&amp;amp; echo curl-logo.png&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's what the result looks like if you open it up in VS Code and preview the Markdown:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot showing a Markdown file &amp;quot;demo.md&amp;quot; side-by-side with its rendered preview. The Markdown source (left) shows: &amp;quot;# How to use curl and jq&amp;quot;, italic timestamp &amp;quot;2026-02-10T01:12:30Z&amp;quot;, prose &amp;quot;Here's how to use curl and jq together.&amp;quot;, a bash code block with &amp;quot;curl -s https://api.github.com/repos/simonw/rodney | jq .description&amp;quot;, output block showing '&amp;quot;CLI tool for interacting with the web&amp;quot;', text &amp;quot;And the curl logo, to demonstrate the image command:&amp;quot;, a bash {image} code block with &amp;quot;curl -o curl-logo.png https://curl.se/logo/curl-logo.png &amp;amp;&amp;amp; echo curl-logo.png&amp;quot;, and a Markdown image reference &amp;quot;2056e48f-2026-02-10&amp;quot;. The rendered preview (right) displays the formatted heading, timestamp, prose, styled code blocks, and the curl logo image in dark teal showing &amp;quot;curl://&amp;quot; with circuit-style design elements." src="https://static.simonwillison.net/static/2026/curl-demo.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;Here's that &lt;a href="https://gist.github.com/simonw/fb0b24696ed8dd91314fe41f4c453563#file-demo-md"&gt;demo.md file in a Gist&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So a sequence of &lt;code&gt;showboat init&lt;/code&gt;, &lt;code&gt;showboat note&lt;/code&gt;, &lt;code&gt;showboat exec&lt;/code&gt; and &lt;code&gt;showboat image&lt;/code&gt; commands constructs a Markdown document one section at a time, with the output of those &lt;code&gt;exec&lt;/code&gt; commands automatically added to the document directly following the commands that were run.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;image&lt;/code&gt; command is a little special - it looks for a file path to an image in the output of the command and copies that image to the current folder and references it in the file.&lt;/p&gt;
&lt;p&gt;That's basically the whole thing! There's a &lt;code&gt;pop&lt;/code&gt; command to remove the most recently added section if something goes wrong, a &lt;code&gt;verify&lt;/code&gt; command to re-run the document and check nothing has changed (I'm not entirely convinced by the design of that one) and a &lt;code&gt;extract&lt;/code&gt; command that reverse-engineers the CLI commands that were used to create the document.&lt;/p&gt;
&lt;p&gt;It's pretty simple - just 172 lines of Go.&lt;/p&gt;
&lt;p&gt;I packaged it up with my &lt;a href="https://github.com/simonw/go-to-wheel"&gt;go-to-wheel&lt;/a&gt; tool which means you can run it without even installing it first like this:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;uvx showboat --help&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That &lt;code&gt;--help&lt;/code&gt; command is really important: it's designed to provide a coding agent with &lt;em&gt;everything it needs to know&lt;/em&gt; in order to use the tool. Here's &lt;a href="https://github.com/simonw/showboat/blob/main/help.txt"&gt;that help text in full&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This means you can pop open Claude Code and tell it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Run "uvx showboat --help" and then use showboat to create a demo.md document describing the feature you just built&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that's it! The &lt;code&gt;--help&lt;/code&gt; text acts &lt;a href="https://simonwillison.net/2025/Oct/16/claude-skills/"&gt;a bit like a Skill&lt;/a&gt;. Your agent can read the help text and use every feature of Showboat to create a document that demonstrates whatever it is you need demonstrated.&lt;/p&gt;
&lt;p&gt;有个有趣的小技巧：如果你让Claude生成Showboat演示文档，可以在VS Code中打开它，当智能体运行演示时，你能实时看到预览窗格的动态更新。这有点像同事通过屏幕共享向你讲解他们的最新成果。

最后来看几个实例。以下是我让Claude使用Showboat创建的文档，用于展示我在其他项目中开发的功能：

**shot-scraper：完整功能演示**
完整演示了我的浏览器自动化工具shot-scraper的全套功能，主要为了测试命令行操作。

**sqlite-history-json命令行演示**
展示了我为新的Python库sqlite-history-json添加的命令行功能。

**row-state-sql命令行演示**
展示了我在同一项目中新增的另一个命令。

**带备注的变更分组演示**
展示了另一项功能：同一事务中的变更组可以附加备注说明。

**krunsh：将Shell命令传输到临时libkrun微虚拟机**
这是个特别复杂的案例——我成功让Claude Code在QEMU模拟的Linux环境中运行libkrun微虚拟机，而这个环境又运行在Claude的gVisor沙箱内。

经过频繁使用Showboat后，我已完全确信其实用价值。

（不过我也发现智能体会"作弊"！由于演示文件是Markdown格式，智能体有时会直接编辑文件而非使用Showboat，这可能导致命令输出与实际执行结果不符。相关讨论可参见这个issue。）

**Rodney：专为Showboat设计的命令行浏览器自动化工具**
我的许多项目都涉及网页界面。智能体经常为这些项目构建全新页面，我希望在演示中能看到这些内容。

Showboat的截图功能专为智能体设计，允许他们在演示过程中捕获屏幕图像。该功能最初使用我的shot-scraper工具或Playwright实现。&lt;/p&gt;
&lt;p&gt;And finally, some examples. Here are documents I had Claude create using Showboat to help demonstrate features I was working on in other projects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/simonw/showboat-demos/blob/main/shot-scraper/README.md"&gt;shot-scraper: A Comprehensive Demo&lt;/a&gt; runs through the full suite of features of my &lt;a href="https://shot-scraper.datasette.io/"&gt;shot-scraper&lt;/a&gt; browser automation tool, mainly to exercise the &lt;code&gt;showboat image&lt;/code&gt; command.&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/simonw/sqlite-history-json/blob/main/demos/cli.md"&gt;sqlite-history-json CLI demo&lt;/a&gt; demonstrates the CLI feature I added to my new &lt;a href="https://github.com/simonw/sqlite-history-json"&gt;sqlite-history-json&lt;/a&gt; Python library.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/simonw/sqlite-history-json/blob/main/demos/row-state-sql.md"&gt;row-state-sql CLI Demo&lt;/a&gt; shows a new &lt;code&gt;row-state-sql&lt;/code&gt; command I added to that same project.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/simonw/sqlite-history-json/blob/main/demos/change-grouping.md"&gt;Change grouping with Notes&lt;/a&gt; demonstrates another feature where groups of changes within the same transaction can have a note attached to them.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/simonw/research/blob/main/libkrun-go-cli-tool/demo.md"&gt;krunsh: Pipe Shell Commands to an Ephemeral libkrun MicroVM&lt;/a&gt; is a particularly convoluted example where I managed to get Claude Code for web to run a libkrun microVM inside a QEMU emulated Linux environment inside the Claude gVisor sandbox.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I've now used Showboat often enough that I've convinced myself of its utility.&lt;/p&gt;
&lt;p&gt;(I've also seen agents cheat! Since the demo file is Markdown the agent will sometimes edit that file directly rather than using Showboat, which could result in command outputs that don't reflect what actually happened. Here's &lt;a href="https://github.com/simonw/showboat/issues/12"&gt;an issue about that&lt;/a&gt;.)&lt;/p&gt;
&lt;h4 id="rodney-cli-browser-automation-designed-to-work-with-showboat"&gt;Rodney: CLI browser automation designed to work with Showboat&lt;/h4&gt;
&lt;p&gt;Many of the projects I work on involve web interfaces. Agents often build entirely new pages for these, and I want to see those represented in the demos.&lt;/p&gt;
&lt;p&gt;Showboat's image feature was designed to allow agents to capture screenshots as part of their demos, originally using my &lt;a href="https://shot-scraper.datasette.io/"&gt;shot-scraper tool&lt;/a&gt; or &lt;a href="https://www.playwright.dev"&gt;Playwright&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Showboat格式受益于命令行工具。我本想寻找一个能通过命令行管理多轮浏览器会话的好方案，但没找到满意的，于是决定尝试构建新工具。

Claude Opus 4.6指引我发现了Rod——这个用于与Chrome DevTools协议交互的Go库。它非常出色，几乎封装了所有自动化Chrome操作的功能，并且是一个独立的库，编译后仅几MB大小。

Rod唯一缺少的就是命令行界面。

我最初将其构建为异步报告原型，这让我确信值得将其独立成一个项目。

我将其命名为Rodney，既致敬它所基于的Rod库，又影射英剧《只有傻瓜和马》——当然也因为PyPI上这个包名尚未被占用。

你可以通过以下方式运行Rodney，或这样安装：
（也可以从发布页面直接获取Go二进制文件。）

以下是一个简单的使用示例：
# 在后台启动Chrome
'Array.from(document.links).map(el =&amp;gt; el.href).slice(0, 5)'
'a[href="/for"]'

终端中的效果如图所示：
与Showboat一样，这个工具并非为人类使用设计！目标是让编码智能体能通过运行命令，就能看到开始使用所需的所有信息。你可以在GitHub仓库中查看完整的帮助输出。

以下是我用Showboat创建的三个Rodney演示：
1. Rodney的原始功能集，包括页面截图和执行JavaScript
2. Rodney在开发过程中构建的新无障碍测试功能展示
3. 使用这些功能对页面进行基础无障碍审计。Claude Opus 4.6对"使用showboat和rodney对https://latest.datasette.io/fixtures进行无障碍审计"这个提示的响应令我印象深刻——完整记录在此。

测试驱动开发固然重要，但我们仍需要人工测试
作为长期对"测试优先、追求全覆盖"开发理念持怀疑态度的从业者（虽然我也认可测试的必要性）……&lt;/p&gt;
&lt;p&gt;Claude Opus 4.6 pointed me to the &lt;a href="https://github.com/go-rod/rod"&gt;Rod&lt;/a&gt; Go library for interacting with the Chrome DevTools protocol. It's fantastic - it provides a comprehensive wrapper across basically everything you can do with automated Chrome, all in a self-contained library that compiles to a few MBs.&lt;/p&gt;
&lt;p&gt;All Rod was missing was a CLI.&lt;/p&gt;
&lt;p&gt;I built the first version &lt;a href="https://github.com/simonw/research/blob/main/go-rod-cli/README.md"&gt;as an asynchronous report prototype&lt;/a&gt;, which convinced me it was worth spinning out into its own project.&lt;/p&gt;
&lt;p&gt;I called it Rodney as a nod to the Rod library it builds on and a reference to &lt;a href="https://en.wikipedia.org/wiki/Only_Fools_and_Horses"&gt;Only Fools and Horses&lt;/a&gt; - and because the package name was available on PyPI.&lt;/p&gt;
&lt;p&gt;You can run Rodney using &lt;code&gt;uvx rodney&lt;/code&gt; or install it like this:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;uv tool install rodney&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Or grab a Go binary &lt;a href="https://github.com/simonw/rodney/releases/"&gt;from the releases page&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Here's a simple example session:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;rodney start &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;#&lt;/span&gt; starts Chrome in the background&lt;/span&gt;
rodney open https://datasette.io/
rodney js &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Array.from(document.links).map(el =&amp;gt; el.href).slice(0, 5)&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
rodney click &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;a[href="/for"]&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
rodney js location.href
rodney js document.title
rodney screenshot datasette-for-page.png
rodney stop&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's what that looks like in the terminal:&lt;/p&gt;
&lt;p&gt;&lt;img alt=";~ % rodney start
Chrome started (PID 91462)
Debug URL: ws://127.0.0.1:64623/devtools/browser/cac6988e-8153-483b-80b9-1b75c611868d
~ % rodney open https://datasette.io/
Datasette: An open source multi-tool for exploring and publishing data
~ % rodney js 'Array.from(document.links).map(el =&amp;gt; el.href).slice(0, 5)'
[
&amp;quot;https://datasette.io/for&amp;quot;,
&amp;quot;https://docs.datasette.io/en/stable/&amp;quot;,
&amp;quot;https://datasette.io/tutorials&amp;quot;,
&amp;quot;https://datasette.io/examples&amp;quot;,
&amp;quot;https://datasette.io/plugins&amp;quot;
]
~ % rodney click 'a[href=&amp;quot;/for&amp;quot;]'
Clicked
~ % rodney js location.href
https://datasette.io/for
~ % rodney js document.title
Use cases for Datasette
~ % rodney screenshot datasette-for-page.png
datasette-for-page.png
~ % rodney stop
Chrome stopped" src="https://static.simonwillison.net/static/2026/rodney-demo.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;As with Showboat, this tool is not designed to be used by humans! The goal is for coding agents to be able to run &lt;code&gt;rodney --help&lt;/code&gt; and see everything they need to know to start using the tool. You can see &lt;a href="https://github.com/simonw/rodney/blob/main/help.txt"&gt;that help output&lt;/a&gt; in the GitHub repo.&lt;/p&gt;
&lt;p&gt;Here are three demonstrations of Rodney that I created using Showboat:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/simonw/showboat-demos/blob/main/rodney/README.md"&gt;Rodney's original feature set&lt;/a&gt;, including screenshots of pages and executing JavaScript.&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/simonw/rodney/blob/main/notes/accessibility-features/README.md"&gt;Rodney's new accessibility testing features&lt;/a&gt;, built during development of those features to show what they could do.&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/simonw/showboat-demos/blob/main/datasette-database-page-accessibility-audit/README.md"&gt;Using those features to run a basic accessibility audit of a page&lt;/a&gt;. I was impressed at how well Claude Opus 4.6 responded to the prompt "Use showboat and rodney to perform an accessibility audit of &lt;a href="https://latest.datasette.io/fixtures"&gt;https://latest.datasette.io/fixtures&lt;/a&gt;" - &lt;a href="https://gisthost.github.io/?dce6b2680db4b05c04469ed8f251eb34/index.html"&gt;transcript here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="test-driven-development-helps-but-we-still-need-manual-testing"&gt;Test-driven development helps, but we still need manual testing&lt;/h4&gt;
&lt;p&gt;After being a career-long skeptic of the test-first, maximum test coverage school of software development (I like &lt;a href="https://simonwillison.net/2022/Oct/29/the-perfect-commit/#tests"&gt;tests included&lt;/a&gt;（改用开发模式）最近我开始尝试测试优先流程，以此强制智能体只编写解决当前问题所必需的代码。

我的许多Python编程智能体会话都以相同的方式开始：

告诉智能体如何运行测试，同时也暗示了该项目存在测试且测试很重要。智能体在编写自己的测试前会先阅读现有测试，因此拥有一个模式良好的简洁测试套件，能提高它们编写出高质量测试的可能性。

前沿模型都理解"红绿测试驱动开发"意味着它们应该先写测试，运行并观察其失败，然后编写代码使其通过——这是一个便捷的捷径。

我发现这极大地提高了代码质量，并增加了智能体在最少提示指导下产出正确结果的可能性。

但任何从事测试工作的人都知道，自动化测试通过并不意味着软件真的能正常工作！这正是Showboat和Rodney背后的动机——除非亲眼看到功能运行，我从不信任任何特性。

在构建Showboat之前，我经常在智能体会话中添加"手动"测试步骤，比如：

这两个工具我都是在手机上开发的

Showboat和Rodney最初都是通过Claude iPhone应用为网页项目创建的Claude代码。它们大部分持续的功能开发也是以同样方式进行的。

我现在在手机上完成如此多的编码工作仍让我有些惊讶，但我估计如今提交到GitHub的大部分代码都是由那个iPhone应用驱动的编程智能体为我编写的。

我最初设计这两个工具是为了在异步编程智能体环境中使用，比如网页版的Claude代码。到目前为止效果非常好。

标签：
go
,
项目
,
测试
,
markdown
,
人工智能
,
生成式人工智能
,
大语言模型
,
AI辅助编程
,
编程智能体
,
异步编程智能体
,
showboat&lt;/p&gt;
&lt;p&gt;Many of my Python coding agent sessions start the same way:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Run the existing tests with "uv run pytest". Build using red/green TDD.&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Telling the agents how to run the tests doubles as an indicator that tests on this project exist and matter. Agents will read existing tests before writing their own so having a clean test suite with good patterns makes it more likely they'll write good tests of their own.&lt;/p&gt;
&lt;p&gt;The frontier models all understand that "red/green TDD" means they should write the test first, run it and watch it fail and then write the code to make it pass - it's a convenient shortcut.&lt;/p&gt;
&lt;p&gt;I find this greatly increases the quality of the code and the likelihood that the agent will produce the right thing with the smallest amount of prompts to guide it.&lt;/p&gt;
&lt;p&gt;But anyone who's worked with tests will know that just because the automated tests pass doesn't mean the software actually works! That’s the motivation behind Showboat and Rodney - I never trust any feature until I’ve seen it running with my own eye.&lt;/p&gt;
&lt;p&gt;Before building Showboat I'd often add a “manual” testing step to my agent sessions, something like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Once the tests pass, start a development server and exercise the new feature using curl&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="i-built-both-of-these-tools-on-my-phone"&gt;I built both of these tools on my phone&lt;/h4&gt;
&lt;p&gt;Both Showboat and Rodney started life as Claude Code for web projects created via the Claude iPhone app. Most of the ongoing feature work for them happened in the same way.&lt;/p&gt;
&lt;p&gt;I'm still a little startled at how much of my coding work I get done on my phone now, but I'd estimate that the majority of code I ship to GitHub these days was written for me by coding agents driven via that iPhone app.&lt;/p&gt;
&lt;p&gt;I initially designed these two tools for use in asynchronous coding agent environments like Claude Code for the web. So far that's working out really well.&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/go"&gt;go&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/projects"&gt;projects&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/testing"&gt;testing&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/markdown"&gt;markdown&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/async-coding-agents"&gt;async-coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/showboat"&gt;showboat&lt;/a&gt;&lt;/p&gt;</description><pubDate>Tue, 10 Feb 2026 17:45:29 +0000</pubDate></item><item><title>面向文件原生智能体系统的结构化情境工程</title><link>https://simonwillison.net/2026/Feb/9/structured-context-engineering-for-file-native-agentic-systems/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://arxiv.org/abs/2602.05447"&gt;面向文件原生智能体系统的结构化上下文工程&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;Damon McMillan发表新论文，探索涉及大规模SQL架构（高达10,000张表）的LLM上下文挑战性任务，涵盖不同模型与文件格式：
&lt;blockquote&gt;
&lt;p&gt;我们以SQL生成为程序化智能体操作的代理指标，对结构化数据的上下文工程展开系统性研究，涵盖11种模型、4种格式（YAML、Markdown、JSON、面向令牌的对象标记法[TOON]）以及10至10,000张表的架构，累计完成9,649次实验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不出所料，模型本身的影响最为显著——前沿模型（Opus 4.5、GPT-5.2、Gemini 2.5 Pro）的表现优于领先的开源模型（DeepSeek V3.2、Kimi K2、Llama 4）。&lt;/p&gt;
&lt;p&gt;这些前沿模型受益于基于文件系统的上下文检索，但开源模型在此方面的表现远未达预期，这印证了我的观点：开源权重模型目前尚未充分掌握文件系统编码智能体的循环处理机制。&lt;a href="https://www.tbench.ai/leaderboard/terminal-bench/2.0"&gt;Terminal Bench 2.0&lt;/a&gt;排行榜仍由Anthropic、OpenAI和Gemini主导。&lt;/p&gt;
&lt;p&gt;针对&lt;a href="https://github.com/toon-format/toon"&gt;TOON格式&lt;/a&gt;的“检索代价”现象是个有趣的细节。TOON旨在以最少令牌数呈现结构化数据，但研究发现模型对该格式的陌生导致其在多次迭代中消耗显著更多令牌以尝试解析：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot of a figure from a research paper. Introductory text reads: &amp;quot;As schema size increased, TOON showed dramatically increased token consumption for Claude models despite being ~25% smaller in file size. Scale experiments used Claude models only.&amp;quot; Below is &amp;quot;Figure 7: The 'Grep Tax' - TOON Token Overhead at Scale&amp;quot;, a bar chart with a logarithmic y-axis labeled &amp;quot;Tokens&amp;quot; comparing YAML (teal) and TOON (purple) at two schema sizes: S5 (500 tables) and S9 (10,000 tables). At S5, TOON is +138% more tokens than YAML (~1,100 vs ~450). At S9, TOON is +740% more tokens (~50,000 vs ~7,000). Below the chart, explanatory text reads: &amp;quot;The 'grep tax' emerged as schema size scaled. At S5 (500 tables), TOON consumed 138% more tokens than YAML; at S9 (10,000 tables), this grew to 740%. Root cause: models lacked familiarity with TOON's syntax and could not construct effective refinement patterns.&amp;quot;" src="https://static.simonwillison.net/static/2026/grep-tax.jpg"/&gt;
&lt;p&gt;&lt;small&gt;&lt;/small&gt;经由&lt;a href="https://twitter.com/omarsar0/status/2020150077637997013"&gt;@omarsar0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/prompt-engineering"&gt;提示工程&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/paper-review"&gt;论文评述&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/context-engineering"&gt;上下文工程&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Mon, 09 Feb 2026 23:56:51 +0000</pubDate></item><item><title>AI不减负，反而增负</title><link>https://simonwillison.net/2026/Feb/9/ai-intensifies-work/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://hbr.org/2026/02/ai-doesnt-reduce-work-it-intensifies-it"&gt;AI并未减轻工作负担，反而加剧了工作强度&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;伯克利哈斯商学院的阿鲁娜·兰加纳特和邢琪·玛吉·叶在《哈佛商业评论》上发表了初步研究结果，该研究于2025年4月至12月对一家"美国科技公司"的200名员工展开。
&lt;p&gt;这印证了我在使用大语言模型工作中观察到的现象：这些工具带来的生产力提升&lt;em&gt;令人精疲力竭&lt;/em&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI引入了新的工作节奏：员工同时处理多个任务线程——手动编写代码时AI同步生成替代版本、并行运行多个智能体、或是重启长期搁置的任务只因AI能在后台"处理它们"。部分原因是他们感觉有了能协助推进工作的"合作伙伴"。&lt;/p&gt;
&lt;p&gt;虽然这种"合作伙伴"感带来了前进动力，但现实却是注意力的持续切换、对AI输出的频繁检查以及不断增多的待办事项。即使工作看似高效，却造成了认知负荷和始终疲于奔命的感觉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我经常发现自己同时推进两三个项目。虽然能&lt;em&gt;完成大量工作&lt;/em&gt;，但仅一两个小时后，当天的脑力就几乎消耗殆尽。&lt;/p&gt;
&lt;p&gt;最近与一些人的交流中发现，他们正因难以抗拒"再输入一条指令就能构建新功能"的诱惑而失眠。&lt;/p&gt;
&lt;p&gt;《哈佛商业评论》文章呼吁企业建立"AI实践规范"，构建AI使用框架以避免职业倦怠，并抵制那些"让企业难以区分真实生产力提升与不可持续强度"的效应。&lt;/p&gt;
&lt;p&gt;我认为我们刚刚颠覆了数十年来关于可持续工作模式的固有认知。要找到新的良好平衡点，尚需时日与规则约束。&lt;p&gt;&lt;small&gt;&lt;/small&gt;来源&lt;a href="https://news.ycombinator.com/item?id=46945755"&gt;黑客新闻&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/careers"&gt;职业生涯&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式AI&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;AI辅助编程&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-ethics"&gt;AI伦理&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Mon, 09 Feb 2026 16:43:07 +0000</pubDate></item><item><title>卡卡波马克杯，凯伦·詹姆斯设计</title><link>https://simonwillison.net/2026/Feb/8/kakapo-mug/#atom-everything</link><description>&lt;p&gt;朋友兼邻居凯伦·詹姆斯送了我一个鸮鹦鹉马克杯。杯身绘有一只神气活现的鸮鹦鹉和四只雏鸟（庆祝2026年繁殖季），甚至还点缀着芮木浆果图案！我实在太喜欢了。

标签：鸮鹦鹉，艺术&lt;a href="https://www.etsy.com/shop/KarenJamesMakes"&gt;Karen James&lt;/a&gt; made me a Kākāpō mug. It has a charismatic Kākāpō, four Kākāpō chicks (in celebration of the &lt;a href="https://simonwillison.net/2026/Jan/8/llm-predictions-for-2026/#1-year-k-k-p-parrots-will-have-an-outstanding-breeding-season"&gt;2026 breeding season&lt;/a&gt;) and even has some &lt;a href="https://www.theguardian.com/world/2026/jan/13/nz-kakapo-mating-season"&gt;rimu fruit&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;&lt;img alt="A simply spectacular sgraffito ceramic mug with a bold, charismatic Kākāpō parrot taking up most of the visible space. It has a yellow beard and green feathers." src="https://static.simonwillison.net/static/2026/kakapo-mug-1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Another side of the mug, two cute grey Kākāpō chicks are visible and three red rimu fruit that look like berries, one on the floor and two hanging from wiry branches." src="https://static.simonwillison.net/static/2026/kakapo-mug-2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;I love it so much.&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/kakapo"&gt;kakapo&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/art"&gt;art&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 08 Feb 2026 17:25:07 +0000</pubDate></item><item><title>引用托马斯·普塔切克的话</title><link>https://simonwillison.net/2026/Feb/8/thomas-ptacek/#atom-everything</link><description>&lt;blockquote cite="https://twitter.com/tqbf/status/2019493645888462993"&gt;&lt;p&gt;橙色网站上的人们对此嗤之以鼻，认为这只是广告宣传，没什么实质内容。但我接触的漏洞研究人员并不觉得这是个玩笑。作为曾经的漏洞研究者，我想说：别低估大语言模型在这方面的能力。

Axios报道：Anthropic的Claude Opus 4.6在开源项目中发现了500个零日漏洞

我认为漏洞研究可能是最适合大语言模型解决的软件工程问题。它具有模式驱动、海量公开操作模式库、闭环系统、工具链刺激响应推动进展、搜索问题等特点。

前沿实验室的模型卡片里就记录着漏洞研究成果。这些公司资金雄厚，甚至能影响经济走向。资金可以买来漏洞研究成果，凭什么认为他们需要造假呢？

——
托马斯·普塔切克

标签：
托马斯-普塔切克，
Anthropic，
Claude，
安全，
生成式AI，
人工智能，
大语言模型，
开源&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.axios.com/2026/02/05/anthropic-claude-opus-46-software-hunting"&gt;Axios: Anthropic's Claude Opus 4.6 uncovers 500 zero-day flaws in open-source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I think vulnerability research might be THE MOST LLM-amenable software engineering problem. Pattern-driven. Huge corpus of operational public patterns. Closed loops. Forward progress from stimulus/response tooling. Search problems.&lt;/p&gt;
&lt;p&gt;Vulnerability research outcomes are in THE MODEL CARDS for frontier labs. Those companies have so much money they're literally distorting the economy. Money buys vuln research outcomes. Why would you think they were faking any of this?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;— &lt;a href="https://twitter.com/tqbf/status/2019493645888462993"&gt;Thomas Ptacek&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/thomas-ptacek"&gt;thomas-ptacek&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/anthropic"&gt;anthropic&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/claude"&gt;claude&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/security"&gt;security&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/open-source"&gt;open-source&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sun, 08 Feb 2026 02:25:53 +0000</pubDate></item><item><title>担保</title><link>https://simonwillison.net/2026/Feb/7/vouch/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/mitchellh/vouch"&gt;担保&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;随着开源项目贡献门槛大幅降低，米切尔·哈希莫尼推出新系统应对海量无价值AI生成PR的冲击。
&lt;p&gt;&lt;a href="https://twitter.com/mitchellh/status/2020252149117313349"&gt;他表示&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;核心理念简明：未获担保用户无法向项目提交贡献。劣质用户可被明确“标记”，实质封禁。担保与标记机制通过GitHub议题讨论区评论或CLI由贡献者执行。&lt;/p&gt;
&lt;p&gt;集成至GitHub仅需采用官方发布的GitHub Actions即可完成。该系统本身具备平台通用性，与GitHub无强制绑定。&lt;/p&gt;
&lt;p&gt;担保标准与执行方式由各项目自主决定。我不充当全球价值警察。请根据项目与社区特性自行制定规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/open-source"&gt;开源&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/github-actions"&gt;GitHub-Actions&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式AI&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/mitchell-hashimoto"&gt;米切尔-哈希莫尼&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-ethics"&gt;AI伦理&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 07 Feb 2026 23:57:57 +0000</pubDate></item><item><title>Claude：使用快速模式加速响应</title><link>https://simonwillison.net/2026/Feb/7/claude-fast-mode/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://code.claude.com/docs/en/fast-mode"&gt;Claude：快速模式加速响应&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;Anthropic今日推出全新“研究预览版”：现在通过在Claude Code中输入&lt;code&gt;/fast&lt;/code&gt;即可访问其前沿模型Claude Opus 4.6的加速版本...但价格是常规模式的6倍
&lt;p&gt;Opus常规定价为输入每百万token 5美元/输出每百万token 25美元。全新快速模式定价飙升至输入每百万token 30美元/输出每百万token 150美元！&lt;/p&gt;
&lt;p&gt;2月16日前享受5折优惠，届时价格倍数将降至3倍（！）&lt;/p&gt;
&lt;p&gt;速度提升多少？官方文档未明确说明，但&lt;a href="https://x.com/claudeai/status/2020207322124132504"&gt;在推特平台&lt;/a&gt;Claude团队透露：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们内部测试的Claude Opus 4.6版本已实现2.5倍加速&lt;/p&gt;
&lt;p&gt;现通过Claude Code和API作为早期实验功能开放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Claude Opus 4.5支持20万token上下文。4.6版本提供扩展至100万token的选项，当输入超过20万token时，输入价格翻倍至每百万token 10美元，输出价格增至1.5倍达每百万token 37.5美元。该倍数体系同样适用于快速模式，这意味着2月16日后，为获得Anthropic最快最强的模型，用户需支付高达输入每百万token 60美元/输出每百万token 225美元的费用&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/anthropic"&gt;Anthropic&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/claude"&gt;Claude&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llm-pricing"&gt;大语言模型定价&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/claude-code"&gt;Claude代码&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Sat, 07 Feb 2026 23:10:33 +0000</pubDate></item><item><title>引用大卫·克劳肖的话</title><link>https://simonwillison.net/2026/Feb/7/david-crawshaw/#atom-everything</link><description>&lt;blockquote cite="https://crawshaw.io/blog/eight-more-months-of-agents"&gt;&lt;p&gt;我比以往任何时候都更享受编程的乐趣，因为那些我曾希望有时间编写的程序，如今大多已成现实。我希望能与那些对智能体带来的变革感到担忧的人们分享这份喜悦。我理解这种恐惧——对于智能技术在我们社会中最终将走向何方，我也有着更广泛的忧虑。但就编写计算机程序这一有限领域而言，这些工具为我的工作带来了如此多的探索与快乐。

——
大卫·克劳肖
，《智能体再启八个月》
标签：
编程智能体
、
AI辅助编程
、
生成式AI
、
人工智能
、
大语言模型&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;— &lt;a href="https://crawshaw.io/blog/eight-more-months-of-agents"&gt;David Crawshaw&lt;/a&gt;, Eight more months of agents&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 07 Feb 2026 21:31:44 +0000</pubDate></item><item><title>StrongDM的AI团队如何在不看代码的情况下构建重要软件</title><link>https://simonwillison.net/2026/Feb/7/software-factory/#atom-everything</link><description>&lt;p&gt;上周我提到过一个团队演示，他们实现了丹·夏皮罗所说的"暗黑工厂"级AI应用——人类甚至无需查看编码智能体生成的代码。该团队来自StrongDM公司，他们刚刚首次公开描述了如何在"软件工厂与智能体时刻"中开展工作：

我们构建了"软件工厂"：这是一种非交互式开发模式，由需求规格和场景驱动智能体编写代码、运行测试框架并自动收敛，全程无需人工审核。[...]

以禅语或箴言形式呈现：
为何由我动手？（潜台词：这该由模型代劳）

以规则形式呈现：
代码必须不由人类编写
代码必须不经人类审核

最终以实践形式呈现：
若团队每位人类工程师当日令牌开销未达1000美元，则说明你的软件工厂尚有改进空间

我认为其中最耐人寻味的无疑是"代码必须不经人类审核"。当我们都清楚大语言模型多么容易犯非人类错误时，这怎么可能成为合理策略？

近来我注意到许多开发者开始认同"2025年11月拐点"——当Claude Opus 4.5和GPT 5.2出现时，编码智能体在遵循指令和执行复杂编码任务方面的可靠性发生了质变。StrongDM的AI团队其实早在2025年7月就已成立，其契机是更早的Claude Sonnet 3.5带来的转折：

催化剂是2024年末观察到的转变：随着Claude 3.5第二次版本迭代（2024年10月），长周期智能体编码工作流开始累积正确性而非错误。到2024年12月，通过Cursor的"YOLO模式"已能清晰见证模型在长周期编码任务中的卓越表现。

这个新团队创立时便立下"杜绝手工编码"的准则——这在2025年7月堪称激进，但据我观察，截至2026年1月已有大量资深开发者开始采纳这种模式。&lt;a href="https://simonwillison.net/2026/Jan/28/the-five-levels/"&gt;I hinted at&lt;/a&gt; a demo I had seen from a team implementing what Dan Shapiro called &lt;a href="https://www.danshapiro.com/blog/2026/01/the-five-levels-from-spicy-autocomplete-to-the-software-factory/"&gt;the Dark Factory&lt;/a&gt; level of AI adoption, where no human even looks at the code the coding agents are producing. That team was part of StrongDM, and they've just shared the first public description of how they are working in &lt;a href="https://factory.strongdm.ai"&gt;Software Factories and the Agentic Moment&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We built a &lt;strong&gt;Software Factory&lt;/strong&gt;: non-interactive development where specs + scenarios drive agents that write code, run harnesses, and converge without human review. [...]&lt;/p&gt;
&lt;p&gt;In kōan or mantra form:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why am I doing this? (implied: the model should be doing this instead)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In rule form:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code &lt;strong&gt;must not be&lt;/strong&gt; written by humans&lt;/li&gt;
&lt;li&gt;Code &lt;strong&gt;must not be&lt;/strong&gt; reviewed by humans&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, in practical form:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you haven't spent at least &lt;strong&gt;$1,000 on tokens today&lt;/strong&gt; per human engineer, your software factory has room for improvement&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;I think the most interesting of these, without a doubt, is "Code &lt;strong&gt;must not be&lt;/strong&gt; reviewed by humans". How could that &lt;em&gt;possibly&lt;/em&gt; be a sensible strategy when we all know how prone LLMs are to making &lt;a href="https://simonwillison.net/2025/Mar/2/kellan-elliott-mccrea/"&gt;inhuman mistakes&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;I've seen many developers recently acknowledge the &lt;a href="https://simonwillison.net/2026/Jan/4/inflection/"&gt;November 2025 inflection point&lt;/a&gt;, where Claude Opus 4.5 and GPT 5.2 appeared to turn the corner on how reliably a coding agent could follow instructions and take on complex coding tasks. StrongDM's AI team was founded in July 2025 based on an earlier inflection point relating to Claude Sonnet 3.5:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The catalyst was a transition observed in late 2024: with the second revision of Claude 3.5 (October 2024), long-horizon agentic coding workflows began to compound correctness rather than error.&lt;/p&gt;
&lt;p&gt;By December of 2024, the model's long-horizon coding performance was unmistakable via Cursor's &lt;a href="https://forum.cursor.com/t/yolo-mode-is-amazing/36262"&gt;YOLO mode&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Their new team started with the rule "no hand-coded software" - radical for July 2025, but something I'm seeing significant numbers of experienced developers start to adopt as of January 2026.&lt;/p&gt;
&lt;p&gt;他们很快遇到了一个显而易见的问题：如果不亲手编写任何代码，如何确保代码真正有效？让智能体编写测试只能在不作弊的前提下提供帮助。

这或许是当前软件开发中最关键的问题：当代码实现和测试用例都由编程智能体代劳时，如何证明你正在开发的软件确实能正常运行？

StrongDM的解决方案灵感来源于场景测试理论。他们这样描述其方法：

我们重新定义了"场景"一词，用它来代表端到端的"用户故事"。这些场景通常存储在代码库之外，类似于模型训练中的"保留集"，能够被大语言模型直观理解并进行灵活验证。

由于我们开发的软件本身具有智能体特性，我们将成功标准从布尔判定转变为概率化实证评估。我们使用"满意度"来量化验证结果：在所有场景观察到的运行轨迹中，有多少比例可能满足用户需求？

将场景视为保留集——用于评估软件却不让编程智能体接触——这个构想令人着迷。它模拟了外部质量保证团队进行的严格测试，这种传统软件质量保障方式虽然成本高昂却极为有效。

这引出了StrongDM的"数字孪生宇宙"概念，也是演示中最令我印象深刻的部分。

他们正在开发的软件用于管理跨平台服务的用户权限。这本身就值得关注——安全软件本应是最不可能使用未经审查的大语言模型代码构建的领域！

数字孪生宇宙是我们软件所依赖第三方服务的行为克隆体。我们构建了Okta、Jira、Slack、Google文档、Google云端硬盘和Google表格的数字孪生，完整复现了它们的应用程序接口、边界情况和可观测行为。&lt;code&gt;assert true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This feels like the most consequential question in software development right now: how can you &lt;a href="https://simonwillison.net/2025/Dec/18/code-proven-to-work/"&gt;prove that software you are producing works&lt;/a&gt; if both the implementation and the tests are being written for you by coding agents?&lt;/p&gt;
&lt;p&gt;StrongDM's answer was inspired by &lt;a href="https://en.wikipedia.org/wiki/Scenario_testing"&gt;Scenario testing&lt;/a&gt; (Cem Kaner, 2003). As StrongDM describe it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We repurposed the word &lt;strong&gt;scenario&lt;/strong&gt; to represent an end-to-end "user story", often stored outside the codebase (similar to a "holdout" set in model training), which could be intuitively understood and flexibly validated by an LLM.&lt;/p&gt;
&lt;p&gt;Because much of the software we grow itself has an agentic component, we transitioned from boolean definitions of success ("the test suite is green") to a probabilistic and empirical one. We use the term &lt;strong&gt;satisfaction&lt;/strong&gt; to quantify this validation: of all the observed trajectories through all the scenarios, what fraction of them likely satisfy the user?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That idea of treating scenarios as holdout sets - used to evaluate the software but not stored where the coding agents can see them - is &lt;em&gt;fascinating&lt;/em&gt;. It imitates aggressive testing by an external QA team - an expensive but highly effective way of ensuring quality in traditional software.&lt;/p&gt;
&lt;p&gt;Which leads us to StrongDM's concept of a &lt;strong&gt;Digital Twin Universe&lt;/strong&gt; - the part of the demo I saw that made the strongest impression on me.&lt;/p&gt;
&lt;p&gt;The software they were building helped manage user permissions across a suite of connected services. This in itself was notable - security software is the last thing you would expect to be built using unreviewed LLM code!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[The Digital Twin Universe is] behavioral clones of the third-party services our software depends on. We built twins of Okta, Jira, Slack, Google Docs, Google Drive, and Google Sheets, replicating their APIs, edge cases, and observable behaviors.&lt;/p&gt;
&lt;p&gt;借助DTU，我们能够以远超生产限制的规模和速率进行验证。我们可以测试那些针对真实服务既危险又无法实施的故障模式。每小时运行数千个场景，既不会触及速率限制、触发滥用检测，也不会累积API成本。

如何克隆Okta、Jira、Slack等系统的核心部分？答案是：借助编码智能体！

据我理解，其诀窍在于将某个服务的完整公开API文档导入智能体框架，让它构建一个自包含的Go二进制文件来模拟该API。随后还能在此基础上构建简化版用户界面，以完善整个模拟系统。

最新动态：DTU创建者Jay Taylor在Hacker News上分享了更多背景信息，并透露了一项关键提示策略：

"我最初获得了一个关键洞见，由此形成了一套可复现的策略，确保DTU与官方标准SaaS服务之间保持高度保真度。"

通过建立独立于原服务的克隆系统——摆脱速率限制和使用配额——他们的模拟测试大军得以展开无拘无束的测试。场景测试脚本成为智能体持续验证新建系统的行动指南。

这张Slack孪生系统的截图生动展示了测试流程：模拟Okta用户流即将接入不同模拟系统的实时画面。

快速构建Slack核心功能克隆体的能力，充分展现了新一代编码智能体工具的颠覆性潜力：

创建高保真度的重量级SaaS应用克隆体在技术上始终可行，但经济层面从未具备可行性。历代工程师或许都曾渴望建立完整的CRM内存副本用于测试，却始终自我否定了构建提案。

他们的技术文档页面同样值得关注。除了数字孪生宇宙概念，还引入了"基因输注"等创新术语。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How do you clone the important parts of Okta, Jira, Slack and more? With coding agents!&lt;/p&gt;
&lt;p&gt;As I understood it the trick was effectively to dump the full public API documentation of one of those services into their agent harness and have it build an imitation of that API, as a self-contained Go binary. They could then have it build a simplified UI over the top to help complete the simulation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: DTU creator Jay Taylor posted some extra context about this &lt;a href="https://news.ycombinator.com/item?id=46924426#46931812"&gt;on Hacker News&lt;/a&gt; sharing a key prompting strategy:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I did have an initial key insight which led to a repeatable strategy to ensure a high level of fidelity between DTU vs. the official canonical SaaS services:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Use the top popular publicly available reference SDK client libraries as compatibility targets, with the goal always being 100% compatibility.&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With their own, independent clones of those services - free from rate-limits or usage quotas - their army of simulated testers could go &lt;em&gt;wild&lt;/em&gt;. Their scenario tests became scripts for agents to constantly execute against the new systems as they were being built.&lt;/p&gt;
&lt;p&gt;This screenshot of their Slack twin also helps illustrate how the testing process works, showing a stream of simulated Okta users who are about to need access to different simulated systems.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot of a Slack-like interface titled &amp;quot;DTU Slack&amp;quot; showing a thread view (Thread — C4B9FBB97) with &amp;quot;Focus first&amp;quot; and &amp;quot;Leave&amp;quot; buttons. The left sidebar lists channels including # org-general (182), # general (0) (shared×2), # it-support (0), # channel-0002 (0) (shared×2), # channel-0003 (0) through # channel-0020 (0), # org-finance (1), and a DMs section with a &amp;quot;Start&amp;quot; button. A &amp;quot;Create&amp;quot; button appears at the top of the sidebar. The main thread shows approximately 9 automated introduction messages from users with Okta IDs (e.g. @okta-u-423438-00001, @okta-u-423438-00002, etc.), all timestamped 2025-11-12Z between 18:50:31 and 18:51:51. Each message follows the format &amp;quot;Hi team! I'm [Name], joining as Employee in general. Key skills: [fictional skill phrases]. Excited to contribute!&amp;quot; All users have red/orange &amp;quot;O&amp;quot; avatar icons." src="https://static.simonwillison.net/static/2026/strong-dm-slack.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;This ability to quickly spin up a useful clone of a subset of Slack helps demonstrate how disruptive this new generation of coding agent tools can be:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Creating a high fidelity clone of a significant SaaS application was always possible, but never economically feasible. Generations of engineers may have &lt;em&gt;wanted&lt;/em&gt; a full in-memory replica of their CRM to test against, but self-censored the proposal to build it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;a href="https://factory.strongdm.ai/techniques"&gt;techniques page&lt;/a&gt; is worth a look too. In addition to the Digital Twin Universe they introduce terms like &lt;strong&gt;&lt;a href="https://factory.strongdm.ai/techniques/gene-transfusion"&gt;Gene Transfusion&lt;/a&gt;&lt;/strong&gt;让智能体从现有系统中提取模式并在其他地方复用，  
**Semports**  
用于直接将代码从一种语言移植到另一种语言，  
**Pyramid Summaries**  
提供多层级摘要，使智能体能快速浏览简短版本，并在需要时深入查看更详细信息。  

StrongDM AI 还以非传统的方式发布了一些软件。  
**github.com/strongdm/attractor**  
是 **Attractor**，他们软件工厂的核心非交互式编码智能体。但这个仓库本身没有任何代码——只有三个 Markdown 文件，详细描述了软件规范，并在 README 中注明：你应该将这些规范输入你选择的编码智能体！  

**github.com/strongdm/cxdb**  
则是一个更传统的发布，包含 16,000 行 Rust 代码、9,500 行 Go 代码和 6,700 行 TypeScript 代码。这是他们的“AI 上下文存储”——一个用于在不可变有向无环图中存储对话历史和工具输出的系统。  
它类似于我的 LLM 工具的 **SQLite 日志机制**，但复杂得多。我可能需要从中汲取一些灵感！  

**未来的缩影？**  
去年十月，我作为受邀嘉宾之一拜访了 StrongDM AI 团队。  
Justin McCarthy、Jay Taylor 和 Navan Chauhan 三人团队仅成立三个月，就已经展示了他们的编码智能体框架、多个服务的数字孪生克隆，以及模拟测试智能体运行场景的演示。而这些演示是在 Opus 4.5/GPT 5.2 发布之前进行的——一个月后，这些版本使智能体编码的可靠性显著提升。  
这仿佛瞥见了软件开发的一种潜在未来：软件工程师从编写代码转向构建并半监控那些生成代码的系统。  
**黑暗工厂**。  

等等，每个工程师每天 1,000 美元？&lt;strong&gt;&lt;a href="https://factory.strongdm.ai/techniques/semport"&gt;Semports&lt;/a&gt;&lt;/strong&gt; for directly porting code from one language to another and &lt;strong&gt;&lt;a href="https://factory.strongdm.ai/techniques/pyramid-summaries"&gt;Pyramid Summaries&lt;/a&gt;&lt;/strong&gt; for providing multiple levels of summary such that an agent can enumerate the short ones quickly and zoom in on more detailed information as it is needed.&lt;/p&gt;
&lt;p&gt;StrongDM AI also released some software - in an appropriately unconventional manner.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/strongdm/attractor"&gt;github.com/strongdm/attractor&lt;/a&gt; is &lt;strong&gt;Attractor&lt;/strong&gt;, the non-interactive coding agent at the heart of their software factory. Except the repo itself contains no code at all - just three markdown files describing the spec for the software in meticulous detail, and a note in the README that you should feed those specs into your coding agent of choice!&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/strongdm/cxdb"&gt;github.com/strongdm/cxdb&lt;/a&gt; is a more traditional release, with 16,000 lines of Rust, 9,500 of Go and 6,700 of TypeScript. This is their "AI Context Store" - a system for storing conversation histories and tool outputs in an immutable DAG.&lt;/p&gt;
&lt;p&gt;It's similar to my LLM tool's &lt;a href="https://llm.datasette.io/en/stable/logging.html#sql-schema"&gt;SQLite logging mechanism&lt;/a&gt; but a whole lot more sophisticated. I may have to gene transfuse some ideas out of this one!&lt;/p&gt;
&lt;h4 id="a-glimpse-of-the-future-"&gt;A glimpse of the future?&lt;/h4&gt;
&lt;p&gt;I visited the StrongDM AI team back in October as part of a small group of invited guests.&lt;/p&gt;
&lt;p&gt;The three person team of Justin McCarthy, Jay Taylor and Navan Chauhan had formed just three months earlier, and they already had working demos of their coding agent harness, their Digital Twin Universe clones of half a dozen services and a swarm of simulated test agents running through scenarios. And this was prior to the Opus 4.5/GPT 5.2 releases that made agentic coding significantly more reliable a month after those demos.&lt;/p&gt;
&lt;p&gt;It felt like a glimpse of one potential future of software development, where software engineers move from building the code to building and then semi-monitoring the systems that build the code. The Dark Factory.&lt;/p&gt;
&lt;h4 id="wait-1-000-day-per-engineer-"&gt;Wait, $1,000/day per engineer?&lt;/h4&gt;
&lt;p&gt;我在最初发布的版本中略过了这个细节，但它确实值得认真关注。

如果这些模式真的会让你的预算每月为每位工程师增加两万美元，那它们对我的吸引力就大大降低了。到那时，这更像是一种商业模式验证：你能否创造出足够盈利的产品线，来负担以这种方式开发软件所产生的巨大开销？

当任何竞争对手都可能通过几小时的智能体编码工作就克隆出你的最新功能时，构建可持续的软件业务也会呈现出截然不同的面貌。

我希望这些模式能够以低得多的成本投入实践。我个人发现每月200美元的Claude Max套餐为我提供了充足的空间来试验不同的智能体模式，当然我也不是24小时不间断地运行着一群质量保证测试员！

我认为即使对于那些不会在代币成本上花费数千美元的团队和个人来说，StrongDM也有很多值得学习的地方。我特别关注的问题是：如何让智能体证明它们编写的代码有效，而无需逐行审查它们生成的每一行代码。

标签：
人工智能，
生成式人工智能，
大语言模型，
人工智能辅助编程，
编码智能体，
并行智能体&lt;/p&gt;
&lt;p&gt;If these patterns really do add $20,000/month per engineer to your budget they're far less interesting to me. At that point this becomes more of a business model exercise: can you create a profitable enough line of products that you can afford the enormous overhead of developing software in this way?&lt;/p&gt;
&lt;p&gt;Building sustainable software businesses also looks very different when any competitor can potentially clone your newest features with a few hours of coding agent work.&lt;/p&gt;
&lt;p&gt;I hope these patterns can be put into play with a much lower spend. I've personally found the $200/month Claude Max plan gives me plenty of space to experiment with different agent patterns, but I'm also not running a swarm of QA testers 24/7!&lt;/p&gt;
&lt;p&gt;I think there's a lot to learn from StrongDM even for teams and individuals who aren't going to burn thousands of dollars on token costs. I'm particularly invested in the question of what it takes to have agents prove that their code works without needing to review every line of code they produce.&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/parallel-agents"&gt;parallel-agents&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 07 Feb 2026 15:40:48 +0000</pubDate></item><item><title>引用汤姆·戴尔的话</title><link>https://simonwillison.net/2026/Feb/6/tom-dale/#atom-everything</link><description>&lt;blockquote cite="https://twitter.com/tomdale/status/2019828626972131441"&gt;&lt;p&gt;不知为何这周成了临界点，与我交谈过的几乎每位软件工程师都正经历某种程度的心理健康危机。

[...] 许多人以为我指的是失业焦虑，但这只是表象之一。我目睹着软件从稀缺转向过剩所引发的近乎狂躁的状态。围绕智能体使用的强迫性行为。面对变革时间压缩产生的解离性惊愕。这不一定是恐惧，而是在历史拐点中生存所承受的认知超载。

——
汤姆·戴尔

标签：
人工智能伦理，
职业生涯，
编程智能体，
生成式人工智能，
人工智能，
大语言模型&lt;/p&gt;
&lt;p&gt;[...] Many people assuming I meant job loss anxiety but that's just one presentation. I'm seeing near-manic episodes triggered by watching software shift from scarce to abundant. Compulsive behaviors around agent usage. Dissociative awe at the temporal compression of change. It's not fear necessarily just the cognitive overload from living in an inflection point.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;— &lt;a href="https://twitter.com/tomdale/status/2019828626972131441"&gt;Tom Dale&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/ai-ethics"&gt;ai-ethics&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/careers"&gt;careers&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 06 Feb 2026 23:41:31 +0000</pubDate></item><item><title>在WebAssembly中运行Pydantic的Monty Rust沙盒化Python子集</title><link>https://simonwillison.net/2026/Feb/6/pydantic-monty/#atom-everything</link><description>&lt;p&gt;这标题真是术语满满！现在大家都在为运行不可信代码构建沙箱，而Pydantic的最新尝试——Monty——在Rust中实现了一种自定义类Python语言（Python子集），并同时提供Rust库和Python包两种使用方式。我成功将其运行在WebAssembly环境中，实现了“沙箱中的沙箱”。

以下是他们对Monty的描述：
Monty避免了使用完整容器沙箱运行LLM生成代码所带来的成本、延迟、复杂性和各种繁琐操作。相反，它让你能安全运行嵌入智能体中的LLM编写的Python代码，启动时间仅需个位数微秒而非数百毫秒。

Monty的功能：
- 运行合理的Python代码子集——足以让智能体表达其意图
- 完全隔离宿主环境：文件系统、环境变量和网络访问均通过开发者可控的外部函数调用实现
- 调用宿主函数——仅限你授权访问的功能

快速体验方式是通过uv工具：
然后在Python交互式环境中粘贴以下代码（需启用顶层await）：
```python
import pydantic_monty
code = pydantic_monty.Monty('print("hello " + str(4 * 5))')
await pydantic_monty.run_monty_async(code)
```

Monty目前仅支持极小的Python子集——甚至还不支持类声明！但针对其目标使用场景，这实际上不成问题。为LLM提供此类工具的妙处在于，它们非常擅长根据错误信息进行迭代调整。编码智能体可以运行Python代码，收到不支持类的错误提示后，就能尝试其他实现方式。

我想在浏览器中尝试这个功能，于是在Claude Code网页版中创建了代码研究任务，以下列指令启动：
克隆 https://github.com/pydantic/monty&lt;a href="https://simonwillison.net/2026/Jan/8/llm-predictions-for-2026/#1-year-we-re-finally-going-to-solve-sandboxing"&gt;building sandboxes&lt;/a&gt; for running untrusted code right now, and Pydantic's latest attempt, &lt;a href="https://github.com/pydantic/monty"&gt;Monty&lt;/a&gt;, provides a custom Python-like language (a subset of Python) in Rust and makes it available as both a Rust library and a Python package. I got it working in WebAssembly, providing a sandbox-in-a-sandbox.&lt;/p&gt;
&lt;p&gt;Here's &lt;a href="https://github.com/pydantic/monty"&gt;how they describe Monty&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Monty avoids the cost, latency, complexity and general faff of using full container based sandbox for running LLM generated code.&lt;/p&gt;
&lt;p&gt;Instead, it let's you safely run Python code written by an LLM embedded in your agent, with startup times measured in single digit microseconds not hundreds of milliseconds.&lt;/p&gt;
&lt;p&gt;What Monty &lt;strong&gt;can&lt;/strong&gt; do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run a reasonable subset of Python code - enough for your agent to express what it wants to do&lt;/li&gt;
&lt;li&gt;Completely block access to the host environment: filesystem, env variables and network access are all implemented via external function calls the developer can control&lt;/li&gt;
&lt;li&gt;Call functions on the host - only functions you give it access to [...]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;A quick way to try it out is via &lt;a href="https://github.com/astral-sh/uv"&gt;uv&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uv run --with pydantic-monty python -m asyncio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then paste this into the Python interactive prompt - the &lt;code&gt;-m asyncio&lt;/code&gt; enables top-level await:&lt;/p&gt;
&lt;pre&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;pydantic_monty&lt;/span&gt;
&lt;span&gt;code&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;pydantic_monty&lt;/span&gt;.&lt;span&gt;Monty&lt;/span&gt;(&lt;span&gt;'print("hello " + str(4 * 5))'&lt;/span&gt;)
&lt;span&gt;await&lt;/span&gt; &lt;span&gt;pydantic_monty&lt;/span&gt;.&lt;span&gt;run_monty_async&lt;/span&gt;(&lt;span&gt;code&lt;/span&gt;)&lt;/pre&gt;
&lt;p&gt;Monty supports a &lt;em&gt;very&lt;/em&gt; small subset of Python - it doesn't even support class declarations yet!&lt;/p&gt;
&lt;p&gt;But, given its target use-case, that's not actually a problem.&lt;/p&gt;
&lt;p&gt;The neat thing about providing tools like this for LLMs is that they're really good at iterating against error messages. A coding agent can run some Python code, get an error message telling it that classes aren't supported and then try again with a different approach.&lt;/p&gt;
&lt;p&gt;I wanted to try this in a browser, so I fired up &lt;a href="https://simonwillison.net/2025/Nov/6/async-code-research/"&gt;a code research task&lt;/a&gt; in Claude Code for web and kicked it off with the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Clone &lt;a href="https://github.com/pydantic/monty"&gt;https://github.com/pydantic/monty&lt;/a&gt;将代码编译到 /tmp 目录，并研究如何将其打包成可在 Pyodide 中加载的 Python WebAssembly wheel 文件。该 wheel 文件需与构建脚本、以及通过 pytest playwright 测试的脚本一同提交至代码仓库——这些测试脚本会从 CDN 加载 Pyodide，并通过本地 "python -m http.server" 加载 wheel 文件，以验证其正常运行。

随后需要额外构建一个独立于 Pyodide 的 WASM 文件，使其也能在浏览器中直接运行。同时需配套编写 playwright 测试来验证其功能，并创建两个 HTML 演示文件：demo.html 与 pyodide-demo.html。这两个文件应参考 https://tools.simonwillison.net/micropython 的实现方式（可通过 curl 下载该代码进行研究），其中一个直接加载 WASM 构建文件，另一个则加载 Pyodide 并调用 WASM wheel。由于这些文件将通过 GitHub Pages 提供服务，且 HTML 文件与 wheel/WASM 文件位于同一目录，因此可以使用相对路径进行加载。

以下是完整的开发记录与最终研究报告。

目前我已将 Monty Rust 代码编译成两种形态的 WebAssembly：一种是可直接通过 JavaScript 加载调用的捆绑包，另一种是可在 Pyodide 中加载的 wheel 文件——后者使得在浏览器中的 WebAssembly 环境里，能通过 Pyodide 的 Python 接口进行调用。

这两个演示已部署在 GitHub Pages 上：
- Monty WASM 演示：通过 JavaScript 直接加载 Rust WASM 模块的交互界面。
- Monty Pyodide 演示：提供相同交互界面，但改为加载 Pyodide 后安装 Monty WASM wheel 的实现方式。

作为沙盒技术的鉴赏者——选择越多越好！——Pydantic 推出的这个新方案完全符合我的期待。它体积小巧、运行高效、具备良好的跨平台性（得益于 Rust 与 WebAssembly），并能严格限制内存使用、CPU 时间以及磁盘网络访问权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then a little later:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I want an additional WASM file that works independently of Pyodide, which is also usable in a web browser - build that too along with playwright tests that show it working. Also build two HTML files - one called demo.html and one called pyodide-demo.html - these should work similar to &lt;a href="https://tools.simonwillison.net/micropython"&gt;https://tools.simonwillison.net/micropython&lt;/a&gt; (download that code with curl to inspect it) - one should load the WASM build, the other should load Pyodide and have it use the WASM wheel. These will be served by GitHub Pages so they can load the WASM and wheel from a relative path since the .html files will be served from the same folder as the wheel and WASM file&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's &lt;a href="https://gisthost.github.io/?22d88e6367d7e002c4fb383c213c2df2/page-001.html"&gt;the transcript&lt;/a&gt;, and the &lt;a href="https://github.com/simonw/research/tree/main/monty-wasm-pyodide"&gt;final research report&lt;/a&gt; it produced.&lt;/p&gt;
&lt;p&gt;I now have the Monty Rust code compiled to WebAssembly in two different shapes - as a &lt;code&gt;.wasm&lt;/code&gt; bundle you can load and call from JavaScript, and as a &lt;code&gt;monty-wasm-pyodide/pydantic_monty-0.0.3-cp313-cp313-emscripten_4_0_9_wasm32.whl&lt;/code&gt; wheel file which can be loaded into &lt;a href="https://pyodide.org/"&gt;Pyodide&lt;/a&gt; and then called from Python in Pyodide in WebAssembly in a browser.&lt;/p&gt;
&lt;p&gt;Here are those two demos, hosted on GitHub Pages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://simonw.github.io/research/monty-wasm-pyodide/demo.html"&gt;Monty WASM demo&lt;/a&gt; - a UI over JavaScript that loads the Rust WASM module directly.&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://simonw.github.io/research/monty-wasm-pyodide/pyodide-demo.html"&gt;Monty Pyodide demo&lt;/a&gt; - this one provides an identical interface but here the code is &lt;a href="https://github.com/simonw/research/blob/3add1ffec70b530711fa237d91f546da5bcf1f1c/monty-wasm-pyodide/pyodide-demo.html#L257-L280"&gt;loading Pyodide and then installing the Monty WASM wheel&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Screenshot of a web app titled &amp;quot;Monty via Pyodide&amp;quot; with description &amp;quot;Run Monty (a sandboxed Python interpreter by Pydantic) inside Pyodide (CPython compiled to WebAssembly). This loads the pydantic-monty wheel and uses its full Python API. Code is saved in the URL for sharing.&amp;quot; A green banner reads &amp;quot;Code executed successfully!&amp;quot; Below are example buttons labeled &amp;quot;Basic&amp;quot;, &amp;quot;Inputs&amp;quot;, &amp;quot;Reuse&amp;quot;, &amp;quot;Error Handling&amp;quot;, &amp;quot;Fibonacci&amp;quot;, and &amp;quot;Classes&amp;quot;. A code editor labeled &amp;quot;Python Code (runs inside Monty sandbox via Pyodide):&amp;quot; contains: &amp;quot;import pydantic_monty\n\n# Create interpreter with input variables\nm = pydantic_monty.Monty('x + y', inputs=['x', 'y'])\n\n# Run with different inputs\nresult1 = m.run(inputs={&amp;quot;x&amp;quot;: 10, &amp;quot;y&amp;quot;: 20})\nprint(f&amp;quot;10 + 20 = {result1}&amp;quot;)\n\nresult2 = m.run(inputs={&amp;quot;x&amp;quot;: 100, &amp;quot;y&amp;quot;: 200})&amp;quot; with &amp;quot;Run Code&amp;quot; and &amp;quot;Clear&amp;quot; buttons. The Output section shows &amp;quot;10 + 20 = 30&amp;quot; and &amp;quot;100 + 200 = 300&amp;quot; with a &amp;quot;Copy&amp;quot; button. Footer reads &amp;quot;Executed in 4.0ms&amp;quot;." src="https://static.simonwillison.net/static/2026/monty-pyodide.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;As a connoisseur of sandboxes - the more options the better! - this new entry from Pydantic ticks a lot of my boxes. It's small, fast, widely available (thanks to Rust and WebAssembly) and provides strict limits on memory usage, CPU time and access to disk and network.&lt;/p&gt;
&lt;p&gt;这也是一个绝佳的契机，可以再做一个演示，展示如今将C或Rust这类编译代码转换成WebAssembly是多么容易，它既能在浏览器中运行，也能在Pyodide环境下执行。&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/javascript"&gt;javascript&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/python"&gt;python&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/sandboxing"&gt;sandboxing&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/rust"&gt;rust&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/webassembly"&gt;webassembly&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/pyodide"&gt;pyodide&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/pydantic"&gt;pydantic&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/claude-code"&gt;claude-code&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 06 Feb 2026 22:31:31 +0000</pubDate></item><item><title>Heroku 最新动态</title><link>https://simonwillison.net/2026/Feb/6/an-update-on-heroku/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.heroku.com/blog/an-update-on-heroku/"&gt;Heroku近况更新&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;Heroku官方博客上出现这个不祥的标题，是的，这是个坏消息。
&lt;blockquote&gt;
&lt;p&gt;从今天起，Heroku将转向以稳定性、安全性、可靠性和技术支持为核心的持续性工程模式。该平台仍将保持生产就绪状态并获得积极支持，但工作重心将转向维持服务质量与卓越运营，而非开发新功能。我们理解此类调整可能引发疑问，因此希望向客户明确说明这意味着什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上下文推测，"持续性工程模式"（这绝非行业通用术语）大概意味着他们只维持基础运行。&lt;/p&gt;
&lt;p&gt;这份企业通告实在令人沮丧。"我们希望向客户明确说明这意味着什么"——然后紧接着&lt;em&gt;并未阐明&lt;/em&gt;这对客户意味着什么。&lt;/p&gt;
&lt;p&gt;他们为何如此决策？以下是官方解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将把产品与工程资源集中投入能创造最大长期客户价值的领域，包括帮助企业在安全可信的环境中构建部署企业级人工智能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的博客是唯一还运行在Heroku上的项目。看来最好在Salesforce彻底失去兴趣前迁移出去（或许该选Fly）。&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/salesforce"&gt;salesforce&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/heroku"&gt;heroku&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/fly"&gt;fly&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</description><pubDate>Fri, 06 Feb 2026 18:44:21 +0000</pubDate></item><item><title>引用卡雷尔·杜斯特林克的话</title><link>https://simonwillison.net/2026/Feb/6/karel-doosterlinck/#atom-everything</link><description>&lt;blockquote cite="https://twitter.com/kareldoostrlnck/status/2019477361557926281"&gt;&lt;p&gt;当我想在不熟悉的代码库中快速实现一次性实验时，我会让Codex进行全面的尽职调查。Codex会探索相关的Slack频道，阅读相关讨论，从这些讨论中获取实验分支，并为我的实验精选有用的更改。所有这些都会被总结成一套详尽的笔记，并附有每条信息来源的链接。利用这些笔记，Codex会搭建实验框架，并做出许多超参数决策，这些决策如果没有更多努力，我是不可能做出的。

---

Karel D'Oosterlinck

，我花了10,000美元用Codex在OpenAI自动化我的研究

标签：
codex-cli
,
coding-agents
,
ai-assisted-programming
,
generative-ai
,
openai
,
ai
,
llms&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class="cite"&gt;— &lt;a href="https://twitter.com/kareldoostrlnck/status/2019477361557926281"&gt;Karel D'Oosterlinck&lt;/a&gt;, I spent $10,000 to automate my research at OpenAI with Codex&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/codex-cli"&gt;codex-cli&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/coding-agents"&gt;coding-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;ai-assisted-programming&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/openai"&gt;openai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 06 Feb 2026 00:42:22 +0000</pubDate></item><item><title>米切尔·哈希莫夫：我的人工智能应用之旅</title><link>https://simonwillison.net/2026/Feb/5/ai-adoption-journey/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://mitchellh.com/writing/my-ai-adoption-journey"&gt;Mitchell Hashimoto：我的AI应用之旅&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;文中包含一些非常规但极其实用的技巧，能帮助你将编程助手真正融入工作流并切实提升效率。我特别欣赏以下几点：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mitchellh.com/writing/my-ai-adoption-journey#step-2-reproduce-your-own-work"&gt;复现自己的工作成果&lt;/a&gt;- 在学习使用编程助手时，Mitchell曾经历这样一个阶段：先手动完成任务，再刻意训练助手复现相同解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我确实把每项工作都做了两遍。先手动完成，然后引导助手在无法参考我手动方案的前提下，产出质量与功能完全一致的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mitchellh.com/writing/my-ai-adoption-journey#step-3-end-of-day-agents"&gt;每日收工助手&lt;/a&gt;- 在精力耗尽时让助手接手工作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了提升效率，我开始尝试新模式：&lt;strong&gt;每天预留最后30分钟启动一个或多个助手。&lt;/strong&gt;我的设想是：&lt;em&gt;或许&lt;/em&gt;当我自己无法继续工作时，助手仍能取得&lt;em&gt;实质性进展&lt;/em&gt;从而提升整体效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mitchellh.com/writing/my-ai-adoption-journey#step-4-outsource-the-slam-dunks"&gt;外包确定性任务&lt;/a&gt;- 当你确认助手能胜任某项任务时，就交由它处理，自己则专注于更有挑战性的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;&lt;/small&gt;来源：&lt;a href="https://news.ycombinator.com/item?id=46903558"&gt;Hacker News&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/ai"&gt;人工智能&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/generative-ai"&gt;生成式AI&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/llms"&gt;大语言模型&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/ai-assisted-programming"&gt;AI辅助编程&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/mitchell-hashimoto"&gt;mitchell-hashimoto&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/coding-agents"&gt;编程助手&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 05 Feb 2026 23:39:07 +0000</pubDate></item><item><title>作品4.6与法典5.3</title><link>https://simonwillison.net/2026/Feb/5/two-new-models/#atom-everything</link><description>&lt;p&gt;今天两大新模型相继发布，间隔仅约15分钟。

Anthropic推出了Opus 4.6版本，其宣传图如下：

OpenAI发布了GPT-5.3-Codex，不过目前仅通过其Codex应用程序提供，尚未开放API接口。其宣传图如下：

我提前体验了这两款模型，但说实话很难找到独特的报道角度——它们表现都非常出色，可之前的Codex 5.2和Opus 4.5同样优秀。我一直在寻找前代模型无法处理而新版能轻松胜任的任务，但至今没有明显发现。

目前关于新模型能力最令人信服的案例，来自Anthropic的尼古拉斯·卡里尼对Opus 4.6的介绍，以及他演示的"用并行Claude团队构建C编译器"项目——这相当于Anthropic版的Cursor FastRender项目。

标签：llm-release、anthropic、generative-ai、openai、pelican-riding-a-bicycle、ai、llms、parallel-agents、c、nicholas-carlini&lt;/p&gt;
&lt;p&gt;Anthropic &lt;a href="https://www.anthropic.com/news/claude-opus-4-6"&gt;released Opus 4.6&lt;/a&gt;. Here's &lt;a href="https://gist.github.com/simonw/a6806ce41b4c721e240a4548ecdbe216"&gt;its pelican&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Slightly wonky bicycle frame but an excellent pelican, very clear beak and pouch, nice feathers." src="https://static.simonwillison.net/static/2026/opus-4.6-pelican.png"/&gt;&lt;/p&gt;
&lt;p&gt;OpenAI &lt;a href="https://openai.com/index/introducing-gpt-5-3-codex/"&gt;release GPT-5.3-Codex&lt;/a&gt;, albeit only via their Codex app, not yet in their API. Here's &lt;a href="https://gist.github.com/simonw/bfc4a83f588ac762c773679c0d1e034b"&gt;its pelican&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Not nearly as good - the bicycle is a bit mangled, the pelican not nearly as well rendered - it's more of a line drawing." src="https://static.simonwillison.net/static/2026/codex-5.3-pelican.png"/&gt;&lt;/p&gt;
&lt;p&gt;I've had a bit of preview access to both of these models and to be honest I'm finding it hard to find a good angle to write about them - they're both &lt;em&gt;really good&lt;/em&gt;, but so were their predecessors Codex 5.2 and Opus 4.5. I've been having trouble finding tasks that those previous models couldn't handle but the new ones are able to ace.&lt;/p&gt;
&lt;p&gt;The most convincing story about capabilities of the new model so far is Nicholas Carlini from Anthropic talking about Opus 4.6 and &lt;a href="https://www.anthropic.com/engineering/building-c-compiler"&gt;Building a C compiler with a team of parallel Claudes&lt;/a&gt; - Anthropic's version of Cursor's &lt;a href="https://simonwillison.net/2026/Jan/23/fastrender/"&gt;FastRender project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tags: &lt;a href="https://simonwillison.net/tags/llm-release"&gt;llm-release&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/anthropic"&gt;anthropic&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/generative-ai"&gt;generative-ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/openai"&gt;openai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/pelican-riding-a-bicycle"&gt;pelican-riding-a-bicycle&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/ai"&gt;ai&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/llms"&gt;llms&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/parallel-agents"&gt;parallel-agents&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/c"&gt;c&lt;/a&gt;, &lt;a href="https://simonwillison.net/tags/nicholas-carlini"&gt;nicholas-carlini&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 05 Feb 2026 20:29:20 +0000</pubDate></item><item><title>聚焦《世界概况》，深情告别</title><link>https://simonwillison.net/2026/Feb/5/the-world-factbook/#atom-everything</link><description>&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.cia.gov/stories/story/spotlighting-the-world-factbook-as-we-bid-a-fond-farewell/"&gt;聚焦《世界概况》的告别时刻&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;今日从中央情报局传来令人扼腕的消息：
&lt;blockquote&gt;
&lt;p&gt;中情局历史最悠久、最具辨识度的情报出版物《世界概况》已悄然落幕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方未透露任何&lt;em&gt;终止原因&lt;/em&gt;——这份自1971年起成为该机构最实用的公共窗口、1997年以来作为互联网公共基石的重要出版物，其维护更新戛然而止。&lt;/p&gt;
&lt;p&gt;更令人费解的是，他们不仅彻底关闭网站（包括所有历史版本存档），还将每个页面设置为跳转至停更公告的302重定向，此举堪称数字文化遗产的破坏行为。&lt;/p&gt;
&lt;p&gt;鉴于《世界概况》始终属于公共领域作品，本可继续提供存档版本——只需在页面顶端标注"停止维护"的提示，远比彻底抹去这些珍贵资料更为妥当。&lt;/p&gt;
&lt;p&gt;截至2020年，中情局仍每年发布完整的网站压缩包存档。这些资料（连同《世界概况》其他内容）&lt;a href="https://web.archive.org/web/20260203124934/https://www.cia.gov/the-world-factbook/about/archives/"&gt;现存于互联网档案馆&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我已将2020年度的384MB&lt;code&gt;.zip&lt;/code&gt;压缩包下载解压至新建的GitHub仓库&lt;a href="https://github.com/simonw/cia-world-factbook-2020/"&gt;simonw/cia-world-factbook-2020&lt;/a&gt;，并启用GitHub Pages功能，您可通过&lt;a href="https://simonw.github.io/cia-world-factbook-2020"&gt;simonw.github.io/cia-world-factbook-2020/&lt;/a&gt;浏览这份存档。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot of the CIA World Factbook website homepage. Header reads &amp;quot;THE WORLD FACTBOOK&amp;quot; with a dropdown labeled &amp;quot;Please select a country to view.&amp;quot; Navigation tabs: ABOUT, REFERENCES, APPENDICES, FAQs. Section heading &amp;quot;WELCOME TO THE WORLD FACTBOOK&amp;quot; followed by descriptive text: &amp;quot;The World Factbook provides information on the history, people and society, government, economy, energy, geography, communications, transportation, military, and transnational issues for 267 world entities. The Reference tab includes: a variety of world, regional, country, ocean, and time zone maps; Flags of the World; and a Country Comparison function that ranks the country information and data in more than 75 Factbook fields.&amp;quot; A satellite image of Earth is displayed on the right. Below it: &amp;quot;WHAT'S NEW :: Today is: Wednesday, February 4.&amp;quot; Left sidebar links with icons: WORLD TRAVEL FACTS, ONE-PAGE COUNTRY SUMMARIES, REGIONAL AND WORLD MAPS, FLAGS OF THE WORLD, GUIDE TO COUNTRY COMPARISONS. Right side shows news updates dated December 17, 2020 about Electricity access and new Economy fields, and December 10, 2020 about Nepal and China agreeing on the height of Mount Everest at 8,848.86 meters. A &amp;quot;VIEW ALL UPDATES&amp;quot; button appears at the bottom." src="https://static.simonwillison.net/static/2025/factbook-2020.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;从2020年12月10日的&lt;a href="https://simonw.github.io/cia-world-factbook-2020/docs/whatsnew.html"&gt;更新日志&lt;/a&gt;中，可窥见《世界概况》独特的编辑风格：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尼泊尔与中国官员本周宣布就珠穆朗玛峰海拔达成共识，终结了多年的测量争议。这座位于尼中边境的山峰在2015年地震后高度略有变化，新确认的8848.86米海拔较原有数据高出近一米。&lt;em&gt;《世界概况》&lt;/em&gt;将新数据取整为8849米，并已同步更新至&lt;em&gt;全书数据库&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;small&gt;&lt;/small&gt;消息来源：&lt;a href="https://news.ycombinator.com/item?id=46891794"&gt;黑客新闻&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;a href="https://simonwillison.net/tags/cia"&gt;中情局&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/github"&gt;GitHub&lt;/a&gt;、&lt;a href="https://simonwillison.net/tags/internet-archive"&gt;互联网档案馆&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 05 Feb 2026 00:23:38 +0000</pubDate></item></channel></rss>